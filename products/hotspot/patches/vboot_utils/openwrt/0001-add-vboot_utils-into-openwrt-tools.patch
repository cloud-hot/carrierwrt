diff -Nur tools-org/Makefile tools/Makefile
--- tools-org/Makefile	2014-04-27 13:03:41.567828120 +0000
+++ tools/Makefile	2014-04-27 13:03:45.716114479 +0000
@@ -30,6 +30,10 @@
 tools-y += sdcc
 endif
 
+ifneq ($(CONFIG_PACKAGE_vboot_utils),)
+tools-y += vboot_utils
+endif
+
 ifdef CONFIG_GCC_USE_GRAPHITE
   ifeq ($(CONFIG_GCC_USE_SYSTEM_PPL_CLOOG),)
 	tools-y += ppl cloog
diff -Nur tools-org/vboot_utils/Makefile tools/vboot_utils/Makefile
--- tools-org/vboot_utils/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/Makefile	2014-04-27 13:03:45.720114754 +0000
@@ -0,0 +1,45 @@
+#
+# Copyright (C) 2006-2012 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=vboot_utils
+PKG_VERSION:=2014.04.27
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/vboot_utils-$(PKG_VERSION)
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Prepare
+	$(Host/Prepare/Default)
+	mkdir -p $(HOST_BUILD_DIR)
+	$(CP) ./src/* $(HOST_BUILD_DIR)/
+	$(CP) ./src/host/lib/extra/* $(STAGING_DIR_HOST)/lib/
+endef
+
+define Host/Compile
+	$(MAKE) -C $(HOST_BUILD_DIR)
+endef
+
+define Host/Install
+	$(CP) $(HOST_BUILD_DIR)/build/utility/vbutil_firmware $(STAGING_DIR_HOST)/bin/
+	$(CP) $(HOST_BUILD_DIR)/build/utility/vbutil_keyblock $(STAGING_DIR_HOST)/bin/
+	$(CP) $(HOST_BUILD_DIR)/build/utility/vbutil_key $(STAGING_DIR_HOST)/bin/
+	$(CP) $(HOST_BUILD_DIR)/build/utility/make_keyblock.sh $(STAGING_DIR_HOST)/bin/
+	$(CP) $(HOST_BUILD_DIR)/build/utility/make_pair.sh $(STAGING_DIR_HOST)/bin/
+	$(CP) $(HOST_BUILD_DIR)/build/utility/common.sh $(STAGING_DIR_HOST)/bin/
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/bin/vbutil_firmware
+	rm -f $(STAGING_DIR_HOST)/bin/vbutil_keyblock
+	rm -f $(STAGING_DIR_HOST)/bin/vbutil_key
+	rm -f $(STAGING_DIR_HOST)/bin/make_keyblock.sh
+	rm -f $(STAGING_DIR_HOST)/bin/make_pair.sh
+	rm -f $(STAGING_DIR_HOST)/bin/common.sh
+endef
+
+$(eval $(call HostBuild))
diff -Nur tools-org/vboot_utils/src/firmware/include/vboot_api.h tools/vboot_utils/src/firmware/include/vboot_api.h
--- tools-org/vboot_utils/src/firmware/include/vboot_api.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/include/vboot_api.h	2014-04-27 13:03:45.728115304 +0000
@@ -0,0 +1,893 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/* APIs provided by firmware to vboot_reference.
+ *
+ * General notes:
+ *
+ * All verified boot functions now start with "Vb" for namespace clarity.  This
+ * fixes the problem where uboot and vboot both defined assert().
+ *
+ * Verified boot APIs to be implemented by the calling firmware and exported to
+ * vboot_reference start with "VbEx".
+ *
+ * TODO: split this file into a vboot_entry_points.h file which contains the
+ * entry points for the firmware to call vboot_reference, and a
+ * vboot_firmware_exports.h which contains the APIs to be implemented by the
+ * calling firmware and exported to vboot_reference.
+ */
+
+#ifndef VBOOT_REFERENCE_VBOOT_API_H_
+#define VBOOT_REFERENCE_VBOOT_API_H_
+#include <stdint.h>
+
+/*****************************************************************************/
+/* Error codes */
+
+/*
+ * Functions which return an error all return this type.  This is a 32-bit
+ * value rather than an int so it's consistent across UEFI, which is 32-bit
+ * during PEI and 64-bit during DXE/BDS.
+ */
+typedef uint32_t VbError_t;
+
+/*
+ * Predefined error numbers.  Success is 0.  Errors are non-zero, but differ
+ * between functions.  For example, the TPM functions may pass through TPM
+ * error codes, some of which may be recoverable.
+ */
+enum VbErrorPredefined_t {
+	/* No error; function completed successfully. */
+	VBERROR_SUCCESS                       = 0,
+
+	/*
+	 * The verified boot entry points VbInit(), VbSelectFirmware(),
+	 * VbSelectAndLoadKernel() may return the following errors.
+	 */
+	/* Unknown error */
+	VBERROR_UNKNOWN                       = 0x10000,
+	/* Unable to initialize shared data */
+	VBERROR_INIT_SHARED_DATA              = 0x10001,
+	/* Error resuming TPM during a S3 resume */
+	VBERROR_TPM_S3_RESUME                 = 0x10002,
+	/* VbSelectFirmware() failed to find a valid firmware */
+	VBERROR_LOAD_FIRMWARE                 = 0x10003,
+	/* Unable to write firmware versions to TPM */
+	VBERROR_TPM_WRITE_FIRMWARE            = 0x10004,
+	/* Unable to lock firmware versions in TPM */
+	VBERROR_TPM_LOCK_FIRMWARE             = 0x10005,
+	/* Unable to set boot mode state in TPM */
+	VBERROR_TPM_SET_BOOT_MODE_STATE       = 0x10006,
+	/* TPM requires reboot */
+	VBERROR_TPM_REBOOT_REQUIRED           = 0x10007,
+	/* Unable to set up TPM */
+	VBERROR_TPM_FIRMWARE_SETUP            = 0x10008,
+	/* Unable to read kernel versions from TPM */
+	VBERROR_TPM_READ_KERNEL               = 0x10009,
+	/* Attempt to load developer-only firmware with developer switch off */
+	VBERROR_DEV_FIRMWARE_SWITCH_MISMATCH  = 0x1000A,
+	/* Unable to write kernel versions to TPM */
+	VBERROR_TPM_WRITE_KERNEL              = 0x1000B,
+	/* Unable to lock kernel versions in TPM */
+	VBERROR_TPM_LOCK_KERNEL               = 0x1000C,
+	/* Calling firmware requested shutdown via VbExIsShutdownRequested() */
+	VBERROR_SHUTDOWN_REQUESTED            = 0x1000D,
+	/* Unable to find a boot device on which to look for a kernel */
+	VBERROR_NO_DISK_FOUND                 = 0x1000E,
+	/* No OS kernel found on any boot device */
+	VBERROR_NO_KERNEL_FOUND               = 0x1000F,
+	/* All OS kernels found were invalid (corrupt, improperly signed...) */
+	VBERROR_INVALID_KERNEL_FOUND          = 0x10010,
+	/* VbSelectAndLoadKernel() requested recovery mode */
+	VBERROR_LOAD_KERNEL_RECOVERY          = 0x10011,
+	/* Other error inside VbSelectAndLoadKernel() */
+	VBERROR_LOAD_KERNEL                   = 0x10012,
+	/* Invalid Google binary block */
+	VBERROR_INVALID_GBB                   = 0x10013,
+	/* Invalid bitmap volume */
+	VBERROR_INVALID_BMPFV                 = 0x10014,
+	/* Invalid screen index */
+	VBERROR_INVALID_SCREEN_INDEX          = 0x10015,
+	/* Simulated (test) error */
+	VBERROR_SIMULATED                     = 0x10016,
+	/* Invalid parameter */
+	VBERROR_INVALID_PARAMETER             = 0x10017,
+	/* VbExBeep() can't make sounds at all */
+	VBERROR_NO_SOUND                      = 0x10018,
+	/* VbExBeep() can't make sound in the background */
+	VBERROR_NO_BACKGROUND_SOUND           = 0x10019,
+	/* Developer has requested a BIOS shell */
+	VBERROR_BIOS_SHELL_REQUESTED          = 0x10020,
+	/* Need VGA and don't have it, or vice-versa */
+	VBERROR_VGA_OPROM_MISMATCH            = 0x10021,
+	/* Need EC to reboot to read-only code */
+	VBERROR_EC_REBOOT_TO_RO_REQUIRED      = 0x10022,
+	/* Invalid region read parameters */
+	VBERROR_REGION_READ_INVALID           = 0x10023,
+	/* Cannot read from region */
+	VBERROR_REGION_READ_FAILED            = 0x10024,
+	/* Unsupported region type */
+	VBERROR_UNSUPPORTED_REGION            = 0x10025,
+	/* No image present (returned from VbGbbReadImage() for missing image) */
+	VBERROR_NO_IMAGE_PRESENT              = 0x10026,
+
+	/* VbExEcGetExpectedRWHash() may return the following codes */
+	/* Compute expected RW hash from the EC image; BIOS doesn't have it */
+	VBERROR_EC_GET_EXPECTED_HASH_FROM_IMAGE = 0x20000,
+};
+
+
+/*****************************************************************************/
+/* Main entry points from firmware into vboot_reference */
+
+/*
+ * Minimum and recommended size of shared_data_blob in bytes.  Shared data blob
+ * is used to communicate data between calls to VbInit(), VbSelectFirmware(),
+ * the OS.  Minimum size is enough to hold all required data for verified boot
+ * but may not be able to hold debug output.
+ */
+#define VB_SHARED_DATA_MIN_SIZE 3072
+#define VB_SHARED_DATA_REC_SIZE 16384
+
+/*
+ * Data passed by firmware to VbInit(), VbSelectFirmware() and
+ * VbSelectAndLoadKernel().
+ *
+ * Note that in UEFI, these are called by different phases in different
+ * processor modes (VbInit() and VbSelectFirmware() = 32-bit PEI,
+ * VbSelectAndLoadKernel() = 64-bit BDS), so the data may be at a different
+ * location between calls.
+ */
+typedef struct VbCommonParams {
+	/* Pointer to GBB data */
+	void *gbb_data;
+	/* Size of GBB data in bytes */
+	uint32_t gbb_size;
+
+	/*
+	 * Shared data blob for data shared between verified boot entry points.
+	 * This should be at least VB_SHARED_DATA_MIN_SIZE bytes long, and
+	 * ideally is VB_SHARED_DATA_REC_SIZE bytes long.
+	 */
+	/* Pointer to shared data blob buffer */
+	void *shared_data_blob;
+	/*
+	 * On input, set to size of shared data blob buffer, in bytes.  On
+	 * output, this will contain the actual data size placed into the
+	 * buffer.
+	 */
+	uint32_t shared_data_size;
+
+	/*
+	 * Internal context/data for verified boot, to maintain state during
+	 * calls to other API functions such as VbExHashFirmwareBody().
+	 * Allocated and freed inside the entry point; firmware should not look
+	 * at this.
+	 */
+	void *vboot_context;
+
+	/*
+	 * Internal context/data for firmware / VbExHashFirmwareBody().  Needed
+	 * because the PEI phase of UEFI boot runs out of ROM and thus can't
+	 * modify global variables; everything needs to get passed around on
+	 * the stack.
+	 */
+	void *caller_context;
+
+	/* For internal use of Vboot - do not examine or modify! */
+	struct GoogleBinaryBlockHeader *gbb;
+	struct BmpBlockHeader *bmp;
+} VbCommonParams;
+
+/* Flags for VbInitParams.flags */
+/* Developer switch was on at boot time. */
+#define VB_INIT_FLAG_DEV_SWITCH_ON       0x00000001
+/* Recovery button was pressed at boot time. */
+#define VB_INIT_FLAG_REC_BUTTON_PRESSED  0x00000002
+/* Hardware write protect was enabled at boot time. */
+#define VB_INIT_FLAG_WP_ENABLED          0x00000004
+/* This is a S3 resume, not a normal boot. */
+#define VB_INIT_FLAG_S3_RESUME           0x00000008
+/*
+ * Previous boot attempt failed for reasons external to verified boot (RAM
+ * init failure, SSD missing, etc.).
+ *
+ * TODO: add a field to VbInitParams which holds a reason code, and report
+ * that via VbSharedData.
+ */
+#define VB_INIT_FLAG_PREVIOUS_BOOT_FAIL  0x00000010
+/*
+ * Calling firmware supports read only firmware for normal/developer boot path.
+ */
+#define VB_INIT_FLAG_RO_NORMAL_SUPPORT   0x00000020
+/*
+ * This platform does not have a physical dev-switch, so we must rely on a
+ * virtual switch (kept in the TPM) instead. When this flag is set,
+ * VB_INIT_FLAG_DEV_SWITCH_ON is ignored.
+ */
+#define VB_INIT_FLAG_VIRTUAL_DEV_SWITCH  0x00000040
+/* Set when the VGA Option ROM has been loaded already. */
+#define VB_INIT_FLAG_OPROM_LOADED        0x00000080
+/* Set if we care about the VGA Option ROM - some platforms don't. */
+#define VB_INIT_FLAG_OPROM_MATTERS       0x00000100
+/* EC on this platform supports EC software sync. */
+#define VB_INIT_FLAG_EC_SOFTWARE_SYNC    0x00000200
+/* EC on this platform is slow to update. */
+#define VB_INIT_FLAG_EC_SLOW_UPDATE      0x00000400
+/*
+ * Software write protect was enabled at boot time. This is separate from the
+ * HW write protect. Both must be set for flash write protection to work.
+ */
+#define VB_INIT_FLAG_SW_WP_ENABLED       0x00000800
+/*
+ * This platform does not have a physical recovery switch which, when present,
+ * can (and should) be used for additional physical presence checks.
+ */
+#define VB_INIT_FLAG_VIRTUAL_REC_SWITCH  0x00001000
+
+/*
+ * Output flags for VbInitParams.out_flags.  Used to indicate potential boot
+ * paths and configuration to the calling firmware early in the boot process,
+ * so that it can properly configure itself for the capabilities subsequently
+ * required by VbSelectFirmware() and VbSelectAndLoadKernel().
+ */
+/*
+ * Enable recovery path.  Do not rely on any rewritable data (cached RAM
+ * timings, etc.).  Reliable operation is more important than boot speed.
+ */
+#define VB_INIT_OUT_ENABLE_RECOVERY      0x00000001
+/* RAM must be cleared before calling VbSelectFirmware(). */
+#define VB_INIT_OUT_CLEAR_RAM            0x00000002
+/*
+ * Load display drivers; VbExDisplay*() functions may be called.  If this flag
+ * is not present, VbExDisplay*() functions will not be called this boot.
+ */
+#define VB_INIT_OUT_ENABLE_DISPLAY       0x00000004
+/*
+ * Load USB storage drivers; VbExDisk*() functions may be called with the
+ * VB_DISK_FLAG_REMOVABLE flag.  If this flag is not present, VbExDisk*()
+ * functions will only be called for fixed disks.
+ */
+#define VB_INIT_OUT_ENABLE_USB_STORAGE   0x00000008
+/* If this is a S3 resume, do a debug reset boot instead */
+#define VB_INIT_OUT_S3_DEBUG_BOOT        0x00000010
+/* BIOS should load any PCI option ROMs it finds, not just internal video */
+#define VB_INIT_OUT_ENABLE_OPROM         0x00000020
+/* BIOS may be asked to boot something other than ChromeOS */
+#define VB_INIT_OUT_ENABLE_ALTERNATE_OS  0x00000040
+/* Enable developer path. */
+#define VB_INIT_OUT_ENABLE_DEVELOPER     0x00000080
+
+/* Data only used by VbInit() */
+typedef struct VbInitParams {
+	/* Inputs to VbInit() */
+	/* Flags (see VB_INIT_FLAG_*) */
+	uint32_t flags;
+
+	/* Outputs from VbInit(); valid only if it returns success. */
+	/* Output flags for firmware; see VB_INIT_OUT_*) */
+	uint32_t out_flags;
+} VbInitParams;
+
+/*
+ * Firmware types for VbHashFirmwareBody() and
+ * VbSelectFirmwareParams.selected_firmware.  Note that we store these in a
+ * uint32_t because enum maps to int, which isn't fixed-size.
+ */
+enum VbSelectFirmware_t {
+	/* Recovery mode */
+	VB_SELECT_FIRMWARE_RECOVERY = 0,
+	/* Rewritable firmware A/B for normal or developer path */
+	VB_SELECT_FIRMWARE_A = 1,
+	VB_SELECT_FIRMWARE_B = 2,
+	/* Read only firmware for normal or developer path. */
+	VB_SELECT_FIRMWARE_READONLY = 3,
+        VB_SELECT_FIRMWARE_COUNT,
+};
+
+/* Data only used by VbSelectFirmware() */
+typedef struct VbSelectFirmwareParams {
+	/* Inputs to VbSelectFirmware() */
+	/* Key block + preamble for firmware A */
+	void *verification_block_A;
+	/* Key block + preamble for firmware B */
+	void *verification_block_B;
+	/* Verification block A size in bytes */
+	uint32_t verification_size_A;
+	/* Verification block B size in bytes */
+	uint32_t verification_size_B;
+
+	/* Outputs from VbSelectFirmware(); valid only if it returns success. */
+	/* Main firmware to run; see VB_SELECT_FIRMWARE_*. */
+	uint32_t selected_firmware;
+} VbSelectFirmwareParams;
+
+/*
+ * We use disk handles rather than indices.  Using indices causes problems if
+ * a disk is removed/inserted in the middle of processing.
+ */
+typedef void *VbExDiskHandle_t;
+
+/* Data used only by VbSelectAndLoadKernel() */
+typedef struct VbSelectAndLoadKernelParams {
+	/* Inputs to VbSelectAndLoadKernel() */
+	/* Destination buffer for kernel (normally at 0x100000 on x86) */
+	void *kernel_buffer;
+	/* Size of kernel buffer in bytes */
+	uint32_t kernel_buffer_size;
+
+	/*
+	 * Outputs from VbSelectAndLoadKernel(); valid only if it returns
+	 * success.
+	 */
+	/* Handle of disk containing loaded kernel */
+	VbExDiskHandle_t disk_handle;
+	/* Partition number on disk to boot (1...M) */
+	uint32_t partition_number;
+	/* Address of bootloader image in RAM */
+	uint64_t bootloader_address;
+	/* Size of bootloader image in bytes */
+	uint32_t bootloader_size;
+	/* UniquePartitionGuid for boot partition */
+	uint8_t partition_guid[16];
+	/*
+	 * TODO: in H2C, all that pretty much just gets passed to the
+	 * bootloader as KernelBootloaderOptions, though the disk handle is
+	 * passed as an index instead of a handle.  Is that used anymore now
+	 * that we're passing partition_guid?
+	 */
+} VbSelectAndLoadKernelParams;
+
+/**
+ * Initialize the verified boot library.
+ *
+ * Returns VBERROR_SUCCESS if success, non-zero if error; on error,
+ * caller should reboot.
+ */
+VbError_t VbInit(VbCommonParams *cparams, VbInitParams *iparams);
+
+/**
+ * Select the main firmware.
+ *
+ * Returns VBERROR_SUCCESS if success, non-zero if error; on error,
+ * caller should reboot.
+ *
+ * NOTE: This is now called in all modes, including recovery.  Previously,
+ * LoadFirmware() was not called in recovery mode, which meant that
+ * LoadKernel() needed to duplicate the TPM and VbSharedData initialization
+ * code.
+ */
+VbError_t VbSelectFirmware(VbCommonParams *cparams,
+                           VbSelectFirmwareParams *fparams);
+
+/**
+ * Update the data hash for the current firmware image, extending it by [size]
+ * bytes stored in [*data].  This function must only be called inside
+ * VbExHashFirmwareBody(), which is in turn called by VbSelectFirmware().
+ */
+void VbUpdateFirmwareBodyHash(VbCommonParams *cparams,
+                              uint8_t *data, uint32_t size);
+
+/**
+ * Select and loads the kernel.
+ *
+ * Returns VBERROR_SUCCESS if success, non-zero if error; on error, caller
+ * should reboot. */
+VbError_t VbSelectAndLoadKernel(VbCommonParams *cparams,
+                                VbSelectAndLoadKernelParams *kparams);
+
+/*****************************************************************************/
+/* Debug output (from utility.h) */
+
+/**
+ * Output an error message and quit.  Does not return.  Supports
+ * printf()-style formatting.
+ */
+void VbExError(const char *format, ...);
+
+/**
+ * Output a debug message.  Supports printf()-style formatting.
+ */
+void VbExDebug(const char *format, ...)
+	__attribute__ ((format (__printf__, 1, 2)));
+
+/*****************************************************************************/
+/* Memory (from utility.h) */
+
+/**
+ * Allocate [size] bytes and return a pointer to the allocated memory. Abort
+ * on error; this always either returns a good pointer or never returns.
+ *
+ * If any of the firmware API implementations require aligned data (for
+ * example, disk access on ARM), all pointers returned by VbExMalloc() must
+ * also be aligned.
+ */
+void *VbExMalloc(size_t size);
+
+/**
+ * Free memory pointed to by [ptr] previously allocated by VbExMalloc().
+ */
+void VbExFree(void *ptr);
+
+/*****************************************************************************/
+/* Timer and delay (first two from utility.h) */
+
+/**
+ * Read a high-resolution timer.  Returns the current timer value in arbitrary
+ * units.
+ *
+ * This is intended for benchmarking, so this call MUST be fast.  The timer
+ * frequency must be >1 KHz (preferably >1 MHz), and the timer must not wrap
+ * around for at least 10 minutes.  It is preferable (but not required) that
+ * the timer be initialized to 0 at boot.
+ *
+ * It is assumed that the firmware has some other way of communicating the
+ * timer frequency to the OS.  For example, on x86 we use TSC, and the OS
+ * kernel reports the initial TSC value at kernel-start and calculates the
+ * frequency. */
+uint64_t VbExGetTimer(void);
+
+/**
+ * Delay for at least the specified number of milliseconds.  Should be accurate
+ * to within 10% (a requested delay of 1000 ms should result in an actual delay
+ * of between 1000 - 1100 ms).
+ */
+void VbExSleepMs(uint32_t msec);
+
+/**
+ * Play a beep tone of the specified frequency in Hz and duration in msec.
+ * This is effectively a VbSleep() variant that makes noise.
+ *
+ * If the audio codec can run in the background, then:
+ *   zero frequency means OFF, non-zero frequency means ON
+ *   zero msec means return immediately, non-zero msec means delay (and
+ *     then OFF if needed)
+ * otherwise,
+ *   non-zero msec and non-zero frequency means ON, delay, OFF, return
+ *   zero msec or zero frequency means do nothing and return immediately
+ *
+ * The return value is used by the caller to determine the capabilities. The
+ * implementation should always do the best it can if it cannot fully support
+ * all features - for example, beeping at a fixed frequency if frequency
+ * support is not available.  At a minimum, it must delay for the specified
+ * non-zero duration.
+ */
+VbError_t VbExBeep(uint32_t msec, uint32_t frequency);
+
+/*****************************************************************************/
+/* TPM (from tlcl_stub.h) */
+
+/**
+ * Initialize the stub library. */
+VbError_t VbExTpmInit(void);
+
+/**
+ * Close and open the device.  This is needed for running more complex commands
+ * at user level, such as TPM_TakeOwnership, since the TPM device can be opened
+ * only by one process at a time.
+ */
+VbError_t VbExTpmClose(void);
+VbError_t VbExTpmOpen(void);
+
+/**
+ * Send a request_length-byte request to the TPM and receive a response.  On
+ * input, response_length is the size of the response buffer in bytes.  On
+ * exit, response_length is set to the actual received response length in
+ * bytes. */
+VbError_t VbExTpmSendReceive(const uint8_t *request, uint32_t request_length,
+                             uint8_t *response, uint32_t *response_length);
+
+/*****************************************************************************/
+/* Non-volatile storage */
+
+#define VBNV_BLOCK_SIZE 16  /* Size of NV storage block in bytes */
+
+/**
+ * Read the VBNV_BLOCK_SIZE-byte non-volatile storage into buf.
+ */
+VbError_t VbExNvStorageRead(uint8_t *buf);
+
+/**
+ * Write the VBNV_BLOCK_SIZE-byte non-volatile storage from buf.
+ */
+VbError_t VbExNvStorageWrite(const uint8_t *buf);
+
+/*****************************************************************************/
+/* Firmware / EEPROM access (previously in load_firmware_fw.h) */
+
+/**
+ * Calculate the hash of the firmware body data for [firmware_index], which is
+ * either VB_SELECT_FIRMWARE_A or VB_SELECT_FIRMWARE B.
+ *
+ * This function must call VbUpdateFirmwareBodyHash() before returning, to
+ * update the secure hash for the firmware image.  For best performance, the
+ * implementation should call VbUpdateFirmwareBodyHash() periodically during
+ * the read, so that updating the hash can be pipelined with the read.  If the
+ * reader cannot update the hash during the read process, it should call
+ * VbUpdateFirmwareBodyHash() on the entire firmware data after the read,
+ * before returning.
+ *
+ * It is recommended that the firmware use this call to copy the requested
+ * firmware body from EEPROM into RAM, so that it doesn't need to do a second
+ * slow copy from EEPROM to RAM if this firmware body is selected.
+ *
+ * Note this function doesn't actually pass the firmware body data to verified
+ * boot, because verified boot doesn't actually need the firmware body, just
+ * its hash.  This is important on x86, where the firmware is stored
+ * compressed.  We hash the compressed data, but the BIOS decompresses it
+ * during read.  Simply updating a hash is compatible with the x86
+ * read-and-decompress pipeline.
+ */
+VbError_t VbExHashFirmwareBody(VbCommonParams *cparams,
+                               uint32_t firmware_index);
+
+/*****************************************************************************/
+/* Disk access (previously in boot_device.h) */
+
+/* Flags for VbDisk APIs */
+/* Disk is removable.  Example removable disks: SD cards, USB keys.  */
+#define VB_DISK_FLAG_REMOVABLE 0x00000001
+/*
+ * Disk is fixed.  If this flag is present, disk is internal to the system and
+ * not removable.  Example fixed disks: internal SATA SSD, eMMC.
+ */
+#define VB_DISK_FLAG_FIXED     0x00000002
+/*
+ * Note that VB_DISK_FLAG_REMOVABLE and VB_DISK_FLAG_FIXED are
+ * mutually-exclusive for a single disk.  VbExDiskGetInfo() may specify both
+ * flags to request disks of both types in a single call.
+ *
+ * At some point we could specify additional flags, but we don't currently
+ * have a way to make use of these:
+ *
+ * USB              Device is known to be attached to USB.  Note that the SD
+ *                  card reader inside x86 systems is attached to USB so this
+ *                  isn't super useful.
+ * SD               Device is known to be a SD card.  Note that external card
+ *                  readers might not return this information, so also of
+ *                  questionable use.
+ * READ_ONLY        Device is known to be read-only.  Could be used by recovery
+ *                  when processing read-only recovery image.
+ */
+
+/* Information on a single disk */
+typedef struct VbDiskInfo {
+	/* Disk handle */
+	VbExDiskHandle_t handle;
+	/* Size of a LBA sector in bytes */
+	uint64_t bytes_per_lba;
+	/* Number of LBA sectors on the device */
+	uint64_t lba_count;
+	/* Flags (see VB_DISK_FLAG_* constants) */
+	uint32_t flags;
+	/*
+	 * Optional name string, for use in debugging.  May be empty or null if
+	 * not available.
+	 */
+	const char *name;
+} VbDiskInfo;
+
+/**
+ * Store information into [info] for all disks (storage devices) attached to
+ * the system which match all of the disk_flags.
+ *
+ * On output, count indicates how many disks are present, and [infos_ptr]
+ * points to a [count]-sized array of VbDiskInfo structs with the information
+ * on those disks; this pointer must be freed by calling VbExDiskFreeInfo().
+ * If count=0, infos_ptr may point to NULL.  If [infos_ptr] points to NULL
+ * because count=0 or error, it is not necessary to call VbExDiskFreeInfo().
+ *
+ * A multi-function device (such as a 4-in-1 card reader) should provide
+ * multiple disk handles.
+ *
+ * The firmware must not alter or free the list pointed to by [infos_ptr] until
+ * VbExDiskFreeInfo() is called.
+ */
+VbError_t VbExDiskGetInfo(VbDiskInfo **infos_ptr, uint32_t *count,
+                          uint32_t disk_flags);
+
+/**
+ * Free a disk information list [infos] previously returned by
+ * VbExDiskGetInfo().  If [preserve_handle] != NULL, the firmware must ensure
+ * that handle remains valid after this call; all other handles from the info
+ * list need not remain valid after this call.
+ */
+VbError_t VbExDiskFreeInfo(VbDiskInfo *infos,
+                           VbExDiskHandle_t preserve_handle);
+
+/**
+ * Read lba_count LBA sectors, starting at sector lba_start, from the disk,
+ * into the buffer.
+ *
+ * If the disk handle is invalid (for example, the handle refers to a disk
+ * which as been removed), the function must return error but must not
+ * crash.
+ */
+VbError_t VbExDiskRead(VbExDiskHandle_t handle, uint64_t lba_start,
+                       uint64_t lba_count, void *buffer);
+
+/**
+ * Write lba_count LBA sectors, starting at sector lba_start, to the disk, from
+ * the buffer.
+ *
+ * If the disk handle is invalid (for example, the handle refers to a disk
+ * which as been removed), the function must return error but must not
+ * crash.
+ */
+VbError_t VbExDiskWrite(VbExDiskHandle_t handle, uint64_t lba_start,
+                        uint64_t lba_count, const void *buffer);
+
+/*****************************************************************************/
+/* Display */
+
+/* Predefined (default) screens for VbExDisplayScreen(). */
+enum VbScreenType_t {
+	/* Blank (clear) screen */
+	VB_SCREEN_BLANK = 0,
+	/* Developer - warning */
+	VB_SCREEN_DEVELOPER_WARNING = 0x101,
+	/* Developer - easter egg */
+	VB_SCREEN_DEVELOPER_EGG     = 0x102,
+	/* Recovery - remove inserted devices */
+	VB_SCREEN_RECOVERY_REMOVE   = 0x201,
+	/* Recovery - insert recovery image */
+	VB_SCREEN_RECOVERY_INSERT   = 0x202,
+	/* Recovery - inserted image invalid */
+	VB_SCREEN_RECOVERY_NO_GOOD  = 0x203,
+	/* Recovery - confirm dev mode */
+	VB_SCREEN_RECOVERY_TO_DEV   = 0x204,
+	/* Developer - confirm normal mode */
+	VB_SCREEN_DEVELOPER_TO_NORM = 0x205,
+	/* Please wait - programming EC */
+	VB_SCREEN_WAIT              = 0x206,
+	/* Confirm after DEVELOPER_TO_NORM */
+	VB_SCREEN_TO_NORM_CONFIRMED = 0x207,
+};
+
+/**
+ * Initialize and clear the display.  Set width and height to the screen
+ * dimensions in pixels.
+ */
+VbError_t VbExDisplayInit(uint32_t *width, uint32_t *height);
+
+/**
+ * Enable (enable!=0) or disable (enable=0) the display backlight.
+ */
+VbError_t VbExDisplayBacklight(uint8_t enable);
+
+/**
+ * Display a predefined screen; see VB_SCREEN_* for valid screens.
+ *
+ * This is a backup method of screen display, intended for use if the GBB does
+ * not contain a full set of bitmaps.  It is acceptable for the backup screen
+ * to be simple ASCII text such as "NO GOOD" or "INSERT"; these screens should
+ * only be seen during development.
+ */
+VbError_t VbExDisplayScreen(uint32_t screen_type);
+
+/**
+ * Write an image to the display, with the upper left corner at the specified
+ * pixel coordinates.  The bitmap buffer is a pointer to the platform-dependent
+ * uncompressed binary blob with dimensions and format specified internally
+ * (for example, a raw BMP, GIF, PNG, whatever). We pass the size just for
+ * convenience.
+ */
+VbError_t VbExDisplayImage(uint32_t x, uint32_t y,
+                           void *buffer, uint32_t buffersize);
+
+/**
+ * Display a string containing debug information on the screen, rendered in a
+ * platform-dependent font.  Should be able to handle newlines '\n' in the
+ * string.  Firmware must support displaying at least 20 lines of text, where
+ * each line may be at least 80 characters long.  If the firmware has its own
+ * debug state, it may display it to the screen below this information.
+ *
+ * NOTE: This is what we currently display when TAB is pressed.  Some
+ * information (HWID, recovery reason) is ours; some (CMOS breadcrumbs) is
+ * platform-specific.  If we decide to soft-render the HWID string
+ * (chrome-os-partner:3693), we'll need to maintain our own fonts, so we'll
+ * likely display it via VbExDisplayImage() above.
+ */
+VbError_t VbExDisplayDebugInfo(const char *info_str);
+
+/*****************************************************************************/
+/* Keyboard and switches */
+
+/* Key codes for required non-printable-ASCII characters. */
+enum VbKeyCode_t {
+	VB_KEY_UP = 0x100,
+	VB_KEY_DOWN = 0x101,
+	VB_KEY_LEFT = 0x102,
+	VB_KEY_RIGHT = 0x103,
+	VB_KEY_CTRL_ENTER = 0x104,
+};
+
+/* Flags for additional information.
+ * TODO(semenzato): consider adding flags for modifiers instead of
+ * making up some of the key codes above.
+ */
+enum VbKeyFlags_t {
+	VB_KEY_FLAG_TRUSTED_KEYBOARD = 1 << 0,
+};
+
+/**
+ * Read the next keypress from the keyboard buffer.
+ *
+ * Returns the keypress, or zero if no keypress is pending or error.
+ *
+ * The following keys must be returned as ASCII character codes:
+ *    0x08          Backspace
+ *    0x09          Tab
+ *    0x0D          Enter (carriage return)
+ *    0x01 - 0x1A   Ctrl+A - Ctrl+Z (yes, those alias with backspace/tab/enter)
+ *    0x1B          Esc
+ *    0x20          Space
+ *    0x30 - 0x39   '0' - '9'
+ *    0x60 - 0x7A   'a' - 'z'
+ *
+ * Some extended keys must also be supported; see the VB_KEY_* defines above.
+ *
+ * Keys ('/') or key-chords (Fn+Q) not defined above may be handled in any of
+ * the following ways:
+ *    1. Filter (don't report anything if one of these keys is pressed).
+ *    2. Report as ASCII (if a well-defined ASCII value exists for the key).
+ *    3. Report as any other value in the range 0x200 - 0x2FF.
+ * It is not permitted to report a key as a multi-byte code (for example,
+ * sending an arrow key as the sequence of keys '\x1b', '[', '1', 'A'). */
+uint32_t VbExKeyboardRead(void);
+
+/**
+ * Same as VbExKeyboardRead(), but return extra information.
+ */
+uint32_t VbExKeyboardReadWithFlags(uint32_t *flags_ptr);
+
+/**
+ * Return the current state of the switches specified in request_mask
+ */
+uint32_t VbExGetSwitches(uint32_t request_mask);
+
+/*****************************************************************************/
+/* Embedded controller (EC) */
+
+/**
+ * This is called only if the system implements a keyboard-based (virtual)
+ * developer switch. It must return true only if the system has an embedded
+ * controller which is provably running in its RO firmware at the time the
+ * function is called.
+ */
+int VbExTrustEC(void);
+
+/**
+ * Check if the EC is currently running rewritable code.
+ *
+ * If the EC is in RO code, sets *in_rw=0.
+ * If the EC is in RW code, sets *in_rw non-zero.
+ * If the current EC image is unknown, returns error. */
+VbError_t VbExEcRunningRW(int *in_rw);
+
+/**
+ * Request the EC jump to its rewritable code.  If successful, returns when the
+ * EC has booting its RW code far enough to respond to subsequent commands.
+ * Does nothing if the EC is already in its rewritable code.
+ */
+VbError_t VbExEcJumpToRW(void);
+
+/**
+ * Tell the EC to refuse another jump until it reboots. Subsequent calls to
+ * VbExEcJumpToRW() in this boot will fail.
+ */
+VbError_t VbExEcDisableJump(void);
+
+/**
+ * Read the SHA-256 hash of the rewriteable EC image.
+ */
+VbError_t VbExEcHashRW(const uint8_t **hash, int *hash_size);
+
+/**
+ * Get the expected contents of the EC image associated with the main firmware
+ * specified by the "select" argument.
+ */
+VbError_t VbExEcGetExpectedRW(enum VbSelectFirmware_t select,
+                              const uint8_t **image, int *image_size);
+
+/**
+ * Read the SHA-256 hash of the expected contents of the EC image associated
+ * with the main firmware specified by the "select" argument.
+ */
+VbError_t VbExEcGetExpectedRWHash(enum VbSelectFirmware_t select,
+		       const uint8_t **hash, int *hash_size);
+
+/**
+ * Update the EC rewritable image.
+ */
+VbError_t VbExEcUpdateRW(const uint8_t *image, int image_size);
+
+/**
+ * Lock the EC code to prevent updates until the EC is rebooted.
+ * Subsequent calls to VbExEcUpdateRW() this boot will fail.
+ */
+VbError_t VbExEcProtectRW(void);
+
+/* Args to VbExProtectFlash() */
+enum VbProtectFlash_t { VBPROTECT_RW_A, VBPROTECT_RW_B, VBPROTECT_RW_DEVKEY };
+
+/**
+ * Lock a section of the BIOS flash address space to prevent updates until the
+ * host is rebooted. Subsequent attempts to erase or modify the specified BIOS
+ * image will fail. If this function is called more than once each call should
+ * be cumulative.
+ */
+VbError_t VbExProtectFlash(enum VbProtectFlash_t region);
+
+/*****************************************************************************/
+/* Misc */
+
+/**
+ * Check if the firmware needs to shut down the system.
+ *
+ * Returns 1 if a shutdown is being requested (for example, the user has
+ * pressed the power button or closed the lid), or 0 if a shutdown is not being
+ * requested.
+ *
+ * NOTE: When we're displaying a screen, pressing the power button should shut
+ * down the computer.  We need a way to break out of our control loop so this
+ * can occur cleanly.
+ */
+uint32_t VbExIsShutdownRequested(void);
+
+/**
+ * Expose the BIOS' built-in decompression routine to the vboot wrapper. The
+ * caller must know how large the uncompressed data will be and must manage
+ * that memory. The decompression routine just puts the uncompressed data into
+ * the specified buffer. We pass in the size of the outbuf, and get back the
+ * actual size used.
+ */
+VbError_t VbExDecompress(void *inbuf, uint32_t in_size,
+                         uint32_t compression_type,
+                         void *outbuf, uint32_t *out_size);
+
+/* Constants for compression_type */
+enum {
+	COMPRESS_NONE = 0,
+	COMPRESS_EFIv1,           /* The x86 BIOS only supports this */
+	COMPRESS_LZMA1,           /* The ARM BIOS supports LZMA1 */
+	MAX_COMPRESS,
+};
+
+/**
+ * Execute legacy boot option.
+ */
+int VbExLegacy(void);
+
+/* Regions for VbExRegionRead() */
+enum vb_firmware_region {
+	VB_REGION_GBB,	/* Google Binary Block - see gbbheader.h */
+
+	VB_REGION_COUNT,
+};
+
+/**
+ * Read data from a region of the firmware image
+ *
+ * Vboot wants access to a region, to read data from it. This function
+ * reads it (typically from the firmware image such as SPI flash) and
+ * returns the data.
+ *
+ * cparams is passed so that the boot loader has some context for the
+ * operation.
+ *
+ * @param cparams	Common parameters, e.g. use member caller_context
+ *			to point to useful context data
+ * @param region	Firmware region to read
+ * @param offset	Start offset within region
+ * @param size		Number of bytes to read
+ * @param buf		Place to put data
+ * @return VBERROR_... error, VBERROR_SUCCESS on success,
+ */
+VbError_t VbExRegionRead(VbCommonParams *cparams,
+			 enum vb_firmware_region region, uint32_t offset,
+			 uint32_t size, void *buf);
+
+#endif  /* VBOOT_REFERENCE_VBOOT_API_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/include/vboot_struct.h tools/vboot_utils/src/firmware/include/vboot_struct.h
--- tools-org/vboot_utils/src/firmware/include/vboot_struct.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/include/vboot_struct.h	2014-04-27 13:03:45.732115579 +0000
@@ -0,0 +1,507 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Data structure definitions for verified boot, for on-disk / in-eeprom
+ * data.
+ */
+
+#ifndef VBOOT_REFERENCE_VBOOT_STRUCT_H_
+#define VBOOT_REFERENCE_VBOOT_STRUCT_H_
+#include <stdint.h>
+
+/* Public key data */
+typedef struct VbPublicKey {
+	/* Offset of key data from start of this struct */
+	uint64_t key_offset;
+	/* Size of key data in bytes (NOT strength of key in bits) */
+	uint64_t key_size;
+	/* Signature algorithm used by the key */
+	uint64_t algorithm;
+	/* Key version */
+	uint64_t key_version;
+} __attribute__((packed)) VbPublicKey;
+
+#define EXPECTED_VBPUBLICKEY_SIZE 32
+
+/* Signature data (a secure hash, possibly signed) */
+typedef struct VbSignature {
+	/* Offset of signature data from start of this struct */
+	uint64_t sig_offset;
+	/* Size of signature data in bytes */
+	uint64_t sig_size;
+	/* Size of the data block which was signed in bytes */
+	uint64_t data_size;
+} __attribute__((packed)) VbSignature;
+
+#define EXPECTED_VBSIGNATURE_SIZE 24
+
+#define KEY_BLOCK_MAGIC "KING-KONG"
+#define KEY_BLOCK_MAGIC_SIZE 8
+
+#define KEY_BLOCK_HEADER_VERSION_MAJOR 2
+#define KEY_BLOCK_HEADER_VERSION_MINOR 1
+
+/* Flags for key_block_flags */
+/* The following flags set where the key is valid */
+#define KEY_BLOCK_FLAG_DEVELOPER_0  (0x01ULL) /* Developer switch off */
+#define KEY_BLOCK_FLAG_DEVELOPER_1  (0x02ULL) /* Developer switch on */
+#define KEY_BLOCK_FLAG_RECOVERY_0   (0x04ULL) /* Not recovery mode */
+#define KEY_BLOCK_FLAG_RECOVERY_1   (0x08ULL) /* Recovery mode */
+
+/*
+ * Key block, containing the public key used to sign some other chunk of data.
+ *
+ * This should be followed by:
+ *   1) The data_key key data, pointed to by data_key.key_offset.
+ *   2) The checksum data for (VBKeyBlockHeader + data_key data), pointed to
+ *      by key_block_checksum.sig_offset.
+ *   3) The signature data for (VBKeyBlockHeader + data_key data), pointed to
+ *      by key_block_signature.sig_offset.
+ */
+typedef struct VbKeyBlockHeader {
+	/* Magic number */
+	uint8_t magic[KEY_BLOCK_MAGIC_SIZE];
+	/* Version of this header format */
+	uint32_t header_version_major;
+	/* Version of this header format */
+	uint32_t header_version_minor;
+	/*
+	 * Length of this entire key block, including keys, signatures, and
+	 * padding, in bytes
+	 */
+	uint64_t key_block_size;
+	/*
+	 * Signature for this key block (header + data pointed to by data_key)
+	 * For use with signed data keys
+	 */
+	VbSignature key_block_signature;
+	/*
+	 * SHA-512 checksum for this key block (header + data pointed to by
+	 * data_key) For use with unsigned data keys
+	 */
+	VbSignature key_block_checksum;
+	/* Flags for key (KEY_BLOCK_FLAG_*) */
+	uint64_t key_block_flags;
+	/* Key to verify the chunk of data */
+	VbPublicKey data_key;
+} __attribute__((packed)) VbKeyBlockHeader;
+
+#define EXPECTED_VBKEYBLOCKHEADER_SIZE 112
+
+/****************************************************************************/
+
+#define FIRMWARE_PREAMBLE_HEADER_VERSION_MAJOR 2
+#define FIRMWARE_PREAMBLE_HEADER_VERSION_MINOR 1
+
+/*
+ * Preamble block for rewritable firmware, version 2.0.  All 2.x versions of
+ * this struct must start with the same data, to be compatible with version 2.0
+ * readers.
+ */
+typedef struct VbFirmwarePreambleHeader2_0 {
+	/*
+	 * Size of this preamble, including keys, signatures, and padding, in
+	 * bytes
+	 */
+	uint64_t preamble_size;
+	/*
+	 * Signature for this preamble (header + kernel subkey + body
+	 * signature)
+	 */
+	VbSignature preamble_signature;
+	/* Version of this header format (= 2) */
+	uint32_t header_version_major;
+	/* Version of this header format (= 0) */
+	uint32_t header_version_minor;
+
+	/* Firmware version */
+	uint64_t firmware_version;
+	/* Key to verify kernel key block */
+	VbPublicKey kernel_subkey;
+	/* Signature for the firmware body */
+	VbSignature body_signature;
+} __attribute__((packed)) VbFirmwarePreambleHeader2_0;
+
+#define EXPECTED_VBFIRMWAREPREAMBLEHEADER2_0_SIZE 104
+
+/* Flags for VbFirmwarePreambleHeader.flags */
+/*
+ * Use the normal/dev boot path from the read-only firmware, instead of
+ * verifying the body signature.
+ */
+#define VB_FIRMWARE_PREAMBLE_USE_RO_NORMAL 0x00000001
+
+/* Premable block for rewritable firmware, version 2.1.
+ *
+ * The firmware preamble header should be followed by:
+ *   1) The kernel_subkey key data, pointed to by kernel_subkey.key_offset.
+ *   2) The signature data for the firmware body, pointed to by
+ *      body_signature.sig_offset.
+ *   3) The signature data for (header + kernel_subkey data + body signature
+ *      data), pointed to by preamble_signature.sig_offset.
+ */
+typedef struct VbFirmwarePreambleHeader {
+	/*
+	 * Size of this preamble, including keys, signatures, and padding, in
+	 * bytes
+	 */
+	uint64_t preamble_size;
+	/*
+	 * Signature for this preamble (header + kernel subkey + body
+	 * signature)
+	 */
+	VbSignature preamble_signature;
+	/* Version of this header format */
+	uint32_t header_version_major;
+	/* Version of this header format */
+	uint32_t header_version_minor;
+
+	/* Firmware version */
+	uint64_t firmware_version;
+	/* Key to verify kernel key block */
+	VbPublicKey kernel_subkey;
+	/* Signature for the firmware body */
+	VbSignature body_signature;
+
+	/*
+	 * Fields added in header version 2.1.  You must verify the header
+	 * version before reading these fields!
+	 */
+	/*
+	 * Flags; see VB_FIRMWARE_PREAMBLE_*.  Readers should return 0 for
+	 * header version < 2.1.
+	 */
+	uint32_t flags;
+} __attribute__((packed)) VbFirmwarePreambleHeader;
+
+#define EXPECTED_VBFIRMWAREPREAMBLEHEADER2_1_SIZE 108
+
+/****************************************************************************/
+
+#define KERNEL_PREAMBLE_HEADER_VERSION_MAJOR 2
+#define KERNEL_PREAMBLE_HEADER_VERSION_MINOR 0
+
+/* Preamble block for kernel
+ *
+ * This should be followed by:
+ *   1) The signature data for the kernel body, pointed to by
+ *      body_signature.sig_offset.
+ *   2) The signature data for (VBFirmwarePreambleHeader + body signature
+ *      data), pointed to by preamble_signature.sig_offset.
+ */
+typedef struct VbKernelPreambleHeader {
+	/*
+	 * Size of this preamble, including keys, signatures, and padding, in
+	 * bytes
+	 */
+	uint64_t preamble_size;
+	/* Signature for this preamble (header + body signature) */
+	VbSignature preamble_signature;
+	/* Version of this header format */
+	uint32_t header_version_major;
+	/* Version of this header format */
+	uint32_t header_version_minor;
+
+	/* Kernel version */
+	uint64_t kernel_version;
+	/* Load address for kernel body */
+	uint64_t body_load_address;
+	/* Address of bootloader, after body is loaded at body_load_address */
+	uint64_t bootloader_address;
+	/* Size of bootloader in bytes */
+	uint64_t bootloader_size;
+	/* Signature for the kernel body */
+	VbSignature body_signature;
+} __attribute__((packed)) VbKernelPreambleHeader;
+
+#define EXPECTED_VBKERNELPREAMBLEHEADER_SIZE 96
+
+/****************************************************************************/
+
+/* Constants and sub-structures for VbSharedDataHeader */
+
+/* Magic number for recognizing VbSharedDataHeader ("VbSD") */
+#define VB_SHARED_DATA_MAGIC 0x44536256
+
+/* Minimum and recommended size of shared_data_blob in bytes. */
+#define VB_SHARED_DATA_MIN_SIZE 3072
+#define VB_SHARED_DATA_REC_SIZE 16384
+
+/* Flags for VbSharedDataHeader */
+/* LoadFirmware() tried firmware B because of VbNvStorage firmware B tries */
+#define VBSD_FWB_TRIED                  0x00000001
+/*
+ * LoadKernel() verified the good kernel keyblock using the kernel subkey from
+ * the firmware.  If this flag is not present, it just used the hash of the
+ * kernel keyblock.
+ */
+#define VBSD_KERNEL_KEY_VERIFIED        0x00000002
+/* LoadFirmware() was told the developer switch was on */
+#define VBSD_LF_DEV_SWITCH_ON           0x00000004
+/* LoadFirmware() is requesting the read only normal/dev code path */
+#define VBSD_LF_USE_RO_NORMAL           0x00000008
+/* Developer switch was enabled at boot time */
+#define VBSD_BOOT_DEV_SWITCH_ON         0x00000010
+/* Recovery switch was enabled at boot time */
+#define VBSD_BOOT_REC_SWITCH_ON         0x00000020
+/* Firmware write protect was enabled at boot time */
+#define VBSD_BOOT_FIRMWARE_WP_ENABLED   0x00000040
+/* Boot is a S3->S0 resume, not a S5->S0 normal boot */
+#define VBSD_BOOT_S3_RESUME             0x00000100
+/* Read-only firmware supports the normal/developer code path */
+#define VBSD_BOOT_RO_NORMAL_SUPPORT     0x00000200
+/* VbInit() was told that the system has a virtual dev-switch */
+#define VBSD_HONOR_VIRT_DEV_SWITCH      0x00000400
+/* VbInit() was told the system supports EC software sync */
+#define VBSD_EC_SOFTWARE_SYNC           0x00000800
+/* VbInit() was told that the EC firmware is slow to update */
+#define VBSD_EC_SLOW_UPDATE             0x00001000
+/* Firmware software write protect was enabled at boot time */
+#define VBSD_BOOT_FIRMWARE_SW_WP_ENABLED 0x00002000
+/* VbInit() was told that the recovery button is a virtual one */
+#define VBSD_BOOT_REC_SWITCH_VIRTUAL     0x00004000
+
+/*
+ * Supported flags by header version.  It's ok to add new flags while keeping
+ * struct version 2 as long as flag-NOT-present is the correct value for
+ * existing hardware (Stumpy/Lumpy).
+ */
+#define VBSD_FLAGS_VERSION_1            0x00000007  /* Alex, ZGB */
+#define VBSD_FLAGS_VERSION_2            0x00000F7F
+
+/* Result codes for VbSharedDataHeader.check_fw_a_result (and b_result) */
+#define VBSD_LF_CHECK_NOT_DONE          0
+#define VBSD_LF_CHECK_DEV_MISMATCH      1
+#define VBSD_LF_CHECK_REC_MISMATCH      2
+#define VBSD_LF_CHECK_VERIFY_KEYBLOCK   3
+#define VBSD_LF_CHECK_KEY_ROLLBACK      4
+#define VBSD_LF_CHECK_DATA_KEY_PARSE    5
+#define VBSD_LF_CHECK_VERIFY_PREAMBLE   6
+#define VBSD_LF_CHECK_FW_ROLLBACK       7
+#define VBSD_LF_CHECK_HEADER_VALID      8
+#define VBSD_LF_CHECK_GET_FW_BODY       9
+#define VBSD_LF_CHECK_HASH_WRONG_SIZE   10
+#define VBSD_LF_CHECK_VERIFY_BODY       11
+#define VBSD_LF_CHECK_VALID             12
+/*
+ * Read-only normal path requested by firmware preamble, but unsupported by
+ * firmware.
+ */
+#define VBSD_LF_CHECK_NO_RO_NORMAL      13
+
+/* Boot mode for VbSharedDataHeader.lk_boot_mode */
+#define VBSD_LK_BOOT_MODE_RECOVERY      0
+#define VBSD_LK_BOOT_MODE_NORMAL        1
+#define VBSD_LK_BOOT_MODE_DEVELOPER     2
+
+/* Flags for VbSharedDataKernelPart.flags */
+#define VBSD_LKP_FLAG_KEY_BLOCK_VALID   0x01
+
+/* Result codes for VbSharedDataKernelPart.check_result */
+#define VBSD_LKP_CHECK_NOT_DONE           0
+#define VBSD_LKP_CHECK_TOO_SMALL          1
+#define VBSD_LKP_CHECK_READ_START         2
+#define VBSD_LKP_CHECK_KEY_BLOCK_SIG      3
+#define VBSD_LKP_CHECK_KEY_BLOCK_HASH     4
+#define VBSD_LKP_CHECK_DEV_MISMATCH       5
+#define VBSD_LKP_CHECK_REC_MISMATCH       6
+#define VBSD_LKP_CHECK_KEY_ROLLBACK       7
+#define VBSD_LKP_CHECK_DATA_KEY_PARSE     8
+#define VBSD_LKP_CHECK_VERIFY_PREAMBLE    9
+#define VBSD_LKP_CHECK_KERNEL_ROLLBACK    10
+#define VBSD_LKP_CHECK_PREAMBLE_VALID     11
+/*
+ * Body load address check is omitted; this result code is deprecated and not
+ * used anywhere in the codebase.
+ */
+#define VBSD_LKP_CHECK_BODY_ADDRESS       12
+#define VBSD_LKP_CHECK_BODY_OFFSET        13
+#define VBSD_LKP_CHECK_SELF_SIGNED        14
+#define VBSD_LKP_CHECK_BODY_EXCEEDS_MEM   15
+#define VBSD_LKP_CHECK_BODY_EXCEEDS_PART  16
+#define VBSD_LKP_CHECK_READ_DATA          17
+#define VBSD_LKP_CHECK_VERIFY_DATA        18
+#define VBSD_LKP_CHECK_KERNEL_GOOD        19
+
+/* Information about a single kernel partition check in LoadKernel() */
+typedef struct VbSharedDataKernelPart {
+	uint64_t sector_start;     /* Start sector of partition */
+	uint64_t sector_count;     /* Sector count of partition */
+	uint32_t combined_version; /* Combined key+kernel version */
+	uint8_t gpt_index;         /* Index of partition in GPT */
+	uint8_t check_result;      /* Check result; see VBSD_LKP_CHECK_* */
+	uint8_t flags;             /* Flags (see VBSD_LKP_FLAG_* */
+	uint8_t reserved0;         /* Reserved for padding */
+} VbSharedDataKernelPart;
+
+/* Number of kernel partitions to track per call.  Must be power of 2. */
+#define VBSD_MAX_KERNEL_PARTS 8
+
+/* Flags for VbSharedDataKernelCall.flags */
+/* Error initializing TPM in recovery mode */
+#define VBSD_LK_FLAG_REC_TPM_INIT_ERROR 0x00000001
+
+/* Result codes for VbSharedDataKernelCall.check_result */
+#define VBSD_LKC_CHECK_NOT_DONE            0
+#define VBSD_LKC_CHECK_DEV_SWITCH_MISMATCH 1
+#define VBSD_LKC_CHECK_GPT_READ_ERROR      2
+#define VBSD_LKC_CHECK_GPT_PARSE_ERROR     3
+#define VBSD_LKC_CHECK_GOOD_PARTITION      4
+#define VBSD_LKC_CHECK_INVALID_PARTITIONS  5
+#define VBSD_LKC_CHECK_NO_PARTITIONS       6
+
+/* Information about a single call to LoadKernel() */
+typedef struct VbSharedDataKernelCall {
+	/* Bottom 32 bits of flags passed in LoadKernelParams.boot_flags */
+	uint32_t boot_flags;
+	/* Debug flags; see VBSD_LK_FLAG_* */
+	uint32_t flags;
+	/* Number of sectors on drive */
+	uint64_t sector_count;
+	/* Sector size in bytes */
+	uint32_t sector_size;
+	/* Check result; see VBSD_LKC_CHECK_* */
+	uint8_t check_result;
+	/* Boot mode for LoadKernel(); see VBSD_LK_BOOT_MODE_* constants */
+	uint8_t boot_mode;
+	/* Test error number, if non-zero */
+	uint8_t test_error_num;
+	/* Return code from LoadKernel() */
+	uint8_t return_code;
+	/* Number of kernel partitions found */
+	uint8_t kernel_parts_found;
+	/* Reserved for padding */
+	uint8_t reserved0[7];
+	/* Data on kernels */
+	VbSharedDataKernelPart parts[VBSD_MAX_KERNEL_PARTS];
+} VbSharedDataKernelCall;
+
+/* Number of kernel calls to track.  Must be power of 2. */
+#define VBSD_MAX_KERNEL_CALLS 4
+
+/*
+ * Data shared between LoadFirmware(), LoadKernel(), and OS.
+ *
+ * The boot process is:
+ *   1) Caller allocates buffer, at least VB_SHARED_DATA_MIN bytes, ideally
+ *      VB_SHARED_DATA_REC_SIZE bytes.
+ *   2) If non-recovery boot, this is passed to LoadFirmware(), which
+ *      initializes the buffer, adding this header and some data.
+ *   3) Buffer is passed to LoadKernel().  If this is a recovery boot,
+ *      LoadKernel() initializes the buffer, adding this header.  Regardless
+ *      of boot type, LoadKernel() adds some data to the buffer.
+ *   4) Caller makes data available to the OS in a platform-dependent manner.
+ *      For example, via ACPI or ATAGs.
+ */
+typedef struct VbSharedDataHeader {
+	/* Fields present in version 1 */
+	/* Magic number for struct (VB_SHARED_DATA_MAGIC) */
+	uint32_t magic;
+	/* Version of this structure */
+	uint32_t struct_version;
+	/* Size of this structure in bytes */
+	uint64_t struct_size;
+	/* Size of shared data buffer in bytes */
+	uint64_t data_size;
+	/* Amount of shared data used so far */
+	uint64_t data_used;
+	/* Flags */
+	uint32_t flags;
+	/* Reserved for padding */
+	uint32_t reserved0;
+	/* Kernel subkey, from firmware */
+	VbPublicKey kernel_subkey;
+	/* Offset of kernel subkey data from start of this struct */
+	uint64_t kernel_subkey_data_offset;
+	/* Size of kernel subkey data */
+	uint64_t kernel_subkey_data_size;
+
+	/*
+	 * Timer values from VbExGetTimer().  Unused values are set to 0.  Note
+	 * that these are now the enter/exit times for the wrapper API entry
+	 * points; see crosbug.com/17018. */
+	/* VbInit() enter/exit */
+	uint64_t timer_vb_init_enter;
+	uint64_t timer_vb_init_exit;
+	/* VbSelectFirmware() enter/exit */
+	uint64_t timer_vb_select_firmware_enter;
+	uint64_t timer_vb_select_firmware_exit;
+	/* VbSelectAndLoadKernel() enter/exit */
+	uint64_t timer_vb_select_and_load_kernel_enter;
+	uint64_t timer_vb_select_and_load_kernel_exit;
+
+	/* Information stored in TPM, as retrieved by firmware */
+	/* Current firmware version in TPM */
+	uint32_t fw_version_tpm;
+	/* Current kernel version in TPM */
+	uint32_t kernel_version_tpm;
+
+	/* Debugging information from LoadFirmware() */
+	/* Result of checking RW firmware A and B */
+	uint8_t check_fw_a_result;
+	uint8_t check_fw_b_result;
+	/* Firmware index returned by LoadFirmware() or 0xFF if failure */
+	uint8_t firmware_index;
+	/* Reserved for padding */
+	uint8_t reserved1;
+	/* Firmware TPM version at start of VbSelectFirmware() */
+	uint32_t fw_version_tpm_start;
+	/* Firmware lowest version found */
+	uint32_t fw_version_lowest;
+
+	/* Debugging information from LoadKernel() */
+	/* Number of times LoadKernel() called */
+	uint32_t lk_call_count;
+	/* Info on calls */
+	VbSharedDataKernelCall lk_calls[VBSD_MAX_KERNEL_CALLS];
+
+	/*
+	 * Offset and size of supplemental kernel data.  Reserve space for
+	 * these fields now, so that future LoadKernel() versions can store
+	 * information there without needing to shift down whatever data the
+	 * original LoadFirmware() might have put immediately following its
+	 * VbSharedDataHeader.
+	 */
+	uint64_t kernel_supplemental_offset;
+	uint64_t kernel_supplemental_size;
+
+	/*
+	 * Fields added in version 2.  Before accessing, make sure that
+	 * struct_version >= 2
+	 */
+	/* Recovery reason for current boot */
+	uint8_t recovery_reason;
+	/* Reserved for padding */
+	uint8_t reserved2[7];
+	/* Flags from firmware keyblock */
+	uint64_t fw_keyblock_flags;
+	/* Kernel TPM version at start of VbSelectAndLoadKernel() */
+	uint32_t kernel_version_tpm_start;
+	/* Kernel lowest version found */
+	uint32_t kernel_version_lowest;
+
+	/*
+	 * After read-only firmware which uses version 2 is released, any
+	 * additional fields must be added below, and the struct version must
+	 * be increased.  Before reading/writing those fields, make sure that
+	 * the struct being accessed is at least version 3.
+	 *
+	 * It's always ok for an older firmware to access a newer struct, since
+	 * all the fields it knows about are present.  Newer firmware needs to
+	 * use reasonable defaults when accessing older structs.
+	 */
+} __attribute__((packed)) VbSharedDataHeader;
+
+/*
+ * Size of VbSharedDataheader for each version
+ *
+ * TODO: crossystem needs not to fail if called on a v1 system where
+ * sizeof(VbSharedDataHeader) was smaller
+ */
+#define VB_SHARED_DATA_HEADER_SIZE_V1 1072
+#define VB_SHARED_DATA_HEADER_SIZE_V2 1096
+
+#define VB_SHARED_DATA_VERSION 2      /* Version for struct_version */
+
+#endif  /* VBOOT_REFERENCE_VBOOT_STRUCT_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/crc8.c tools/vboot_utils/src/firmware/lib/crc8.c
--- tools-org/vboot_utils/src/firmware/lib/crc8.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/crc8.c	2014-04-27 13:03:45.732115579 +0000
@@ -0,0 +1,30 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "sysincludes.h"
+
+#include "crc8.h"
+
+/**
+ * Return CRC-8 of the data, using x^8 + x^2 + x + 1 polynomial.  A table-based
+ * algorithm would be faster, but for only a few bytes it isn't worth the code
+ * size. */
+uint8_t Crc8(const void *vptr, int len)
+{
+	const uint8_t *data = vptr;
+	unsigned crc = 0;
+	int i, j;
+
+	for (j = len; j; j--, data++) {
+		crc ^= (*data << 8);
+		for(i = 8; i; i--) {
+			if (crc & 0x8000)
+				crc ^= (0x1070 << 3);
+			crc <<= 1;
+		}
+	}
+
+	return (uint8_t)(crc >> 8);
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/include/cryptolib.h tools/vboot_utils/src/firmware/lib/cryptolib/include/cryptolib.h
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/include/cryptolib.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/include/cryptolib.h	2014-04-27 13:03:45.736115854 +0000
@@ -0,0 +1,15 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Firmware Cryptolib includes.
+ */
+
+#ifndef VBOOT_REFERENCE_CRYPTOLIB_H_
+#define VBOOT_REFERENCE_CRYPTOLIB_H_
+
+#include "padding.h"
+#include "rsa.h"
+#include "sha.h"
+
+#endif  /* VBOOT_REFERENCE_CRYPTOLIB_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/include/padding.h tools/vboot_utils/src/firmware/lib/cryptolib/include/padding.h
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/include/padding.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/include/padding.h	2014-04-27 13:03:45.736115854 +0000
@@ -0,0 +1,40 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef VBOOT_REFERENCE_PADDING_H_
+#define VBOOT_REFERENCE_PADDING_H_
+
+#ifndef VBOOT_REFERENCE_CRYPTOLIB_H_
+#error "Do not include this file directly. Use cryptolib.h instead."
+#endif
+
+#include "sysincludes.h"
+
+extern const uint8_t paddingRSA1024_SHA1[];
+extern const uint8_t paddingRSA1024_SHA256[];
+extern const uint8_t paddingRSA1024_SHA512[];
+extern const uint8_t paddingRSA2048_SHA1[];
+extern const uint8_t paddingRSA2048_SHA256[];
+extern const uint8_t paddingRSA2048_SHA512[];
+extern const uint8_t paddingRSA4096_SHA1[];
+extern const uint8_t paddingRSA4096_SHA256[];
+extern const uint8_t paddingRSA4096_SHA512[];
+extern const uint8_t paddingRSA8192_SHA1[];
+extern const uint8_t paddingRSA8192_SHA256[];
+extern const uint8_t paddingRSA8192_SHA512[];
+
+extern const int kNumAlgorithms;
+
+extern const int digestinfo_size_map[];
+extern const int siglen_map[];
+extern const uint8_t* const padding_map[];
+extern const int padding_size_map[];
+extern const int hash_type_map[];
+extern const int hash_size_map[];
+extern const int hash_blocksize_map[];
+extern const uint8_t* const hash_digestinfo_map[];
+extern const char* const algo_strings[];
+
+#endif  /* VBOOT_REFERENCE_PADDING_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/include/rsa.h tools/vboot_utils/src/firmware/lib/cryptolib/include/rsa.h
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/include/rsa.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/include/rsa.h	2014-04-27 13:03:45.736115854 +0000
@@ -0,0 +1,95 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef VBOOT_REFERENCE_RSA_H_
+#define VBOOT_REFERENCE_RSA_H_
+
+#ifndef VBOOT_REFERENCE_CRYPTOLIB_H_
+#error "Do not include this file directly. Use cryptolib.h instead."
+#endif
+
+#include "sysincludes.h"
+
+#define RSA1024NUMBYTES 128  /* 1024 bit key length */
+#define RSA2048NUMBYTES 256  /* 2048 bit key length */
+#define RSA4096NUMBYTES 512  /* 4096 bit key length */
+#define RSA8192NUMBYTES 1024  /* 8192 bit key length */
+
+#define RSA1024NUMWORDS (RSA1024NUMBYTES / sizeof(uint32_t))
+#define RSA2048NUMWORDS (RSA2048NUMBYTES / sizeof(uint32_t))
+#define RSA4096NUMWORDS (RSA4096NUMBYTES / sizeof(uint32_t))
+#define RSA8192NUMWORDS (RSA8192NUMBYTES / sizeof(uint32_t))
+
+typedef struct RSAPublicKey {
+  uint32_t len;  /* Length of n[] in number of uint32_t */
+  uint32_t n0inv;  /* -1 / n[0] mod 2^32 */
+  uint32_t* n;  /* modulus as little endian array */
+  uint32_t* rr; /* R^2 as little endian array */
+  unsigned int algorithm; /* Algorithm to use when verifying with the key */
+} RSAPublicKey;
+
+/* Verify a RSA PKCS1.5 signature [sig] of [sig_type] and length [sig_len]
+ * against an expected [hash] using [key]. Returns 0 on failure, 1 on success.
+ */
+int RSAVerify(const RSAPublicKey *key,
+              const uint8_t* sig,
+              const uint32_t sig_len,
+              const uint8_t sig_type,
+              const uint8_t* hash);
+
+/* Perform RSA signature verification on [buf] of length [len] against expected
+ * signature [sig] using signature algorithm [algorithm]. The public key used
+ * for verification can either be in the form of a pre-process key blob
+ * [key_blob] or RSAPublicKey structure [key]. One of [key_blob] or [key] must
+ * be non-NULL, and the other NULL or the function will fail.
+ *
+ * Returns 1 on verification success, 0 on verification failure or invalid
+ * arguments.
+ *
+ * Note: This function is for use in the firmware and assumes all pointers point
+ * to areas in the memory of the right size.
+ *
+ */
+int RSAVerifyBinary_f(const uint8_t* key_blob,
+                      const RSAPublicKey* key,
+                      const uint8_t* buf,
+                      uint64_t len,
+                      const uint8_t* sig,
+                      unsigned int algorithm);
+
+/* Version of RSAVerifyBinary_f() where instead of the raw binary blob
+ * of data, its digest is passed as the argument. */
+int RSAVerifyBinaryWithDigest_f(const uint8_t* key_blob,
+                                const RSAPublicKey* key,
+                                const uint8_t* digest,
+                                const uint8_t* sig,
+                                unsigned int algorithm);
+
+
+/* ----Some additional utility functions for RSA.---- */
+
+/* Returns the size of a pre-processed RSA public key in
+ * [out_size] with the algorithm [algorithm].
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+uint64_t RSAProcessedKeySize(uint64_t algorithm, uint64_t* out_size);
+
+/* Allocate a new RSAPublicKey structure and initialize its pointer fields to
+ * NULL */
+RSAPublicKey* RSAPublicKeyNew(void);
+
+/* Deep free the contents of [key]. */
+void RSAPublicKeyFree(RSAPublicKey* key);
+
+/* Create a RSAPublic key structure from binary blob [buf] of length
+ * [len].
+ *
+ * Caller owns the returned key and must free it.
+ */
+RSAPublicKey* RSAPublicKeyFromBuf(const uint8_t* buf, uint64_t len);
+
+
+#endif  /* VBOOT_REFERENCE_RSA_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/include/sha.h tools/vboot_utils/src/firmware/lib/cryptolib/include/sha.h
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/include/sha.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/include/sha.h	2014-04-27 13:03:45.740116128 +0000
@@ -0,0 +1,128 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/* SHA-1, 256 and 512 functions. */
+
+#ifndef VBOOT_REFERENCE_SHA_H_
+#define VBOOT_REFERENCE_SHA_H_
+
+#ifndef VBOOT_REFERENCE_CRYPTOLIB_H_
+#error "Do not include this file directly. Use cryptolib.h instead."
+#endif
+
+#include "sysincludes.h"
+
+#define SHA1_DIGEST_SIZE 20
+#define SHA1_BLOCK_SIZE 64
+
+#define SHA256_DIGEST_SIZE 32
+#define SHA256_BLOCK_SIZE 64
+
+#define SHA512_DIGEST_SIZE 64
+#define SHA512_BLOCK_SIZE 128
+
+typedef struct SHA1_CTX {
+  uint64_t count;
+  uint32_t state[5];
+#if defined(HAVE_ENDIAN_H) && defined(HAVE_LITTLE_ENDIAN)
+  union {
+    uint8_t b[64];
+    uint32_t w[16];
+  } buf;
+#else
+  uint8_t buf[64];
+#endif
+} SHA1_CTX;
+
+typedef struct {
+  uint32_t h[8];
+  uint32_t tot_len;
+  uint32_t len;
+  uint8_t block[2 * SHA256_BLOCK_SIZE];
+  uint8_t buf[SHA256_DIGEST_SIZE];  /* Used for storing the final digest. */
+} SHA256_CTX;
+
+typedef struct {
+  uint64_t h[8];
+  uint32_t tot_len;
+  uint32_t len;
+  uint8_t block[2 * SHA512_BLOCK_SIZE];
+  uint8_t buf[SHA512_DIGEST_SIZE];  /* Used for storing the final digest. */
+} SHA512_CTX;
+
+
+void SHA1_init(SHA1_CTX* ctx);
+void SHA1_update(SHA1_CTX* ctx, const uint8_t* data, uint64_t len);
+uint8_t* SHA1_final(SHA1_CTX* ctx);
+
+void SHA256_init(SHA256_CTX* ctx);
+void SHA256_update(SHA256_CTX* ctx, const uint8_t* data, uint32_t len);
+uint8_t* SHA256_final(SHA256_CTX* ctx);
+
+void SHA512_init(SHA512_CTX* ctx);
+void SHA512_update(SHA512_CTX* ctx, const uint8_t* data, uint32_t len);
+uint8_t* SHA512_final(SHA512_CTX* ctx);
+
+/* Convenience function for SHA-1.  Computes hash on [data] of length [len].
+ * and stores it into [digest]. [digest] should be pre-allocated to
+ * SHA1_DIGEST_SIZE bytes.
+ */
+uint8_t* internal_SHA1(const uint8_t* data, uint64_t len, uint8_t* digest);
+
+/* Convenience function for SHA-256.  Computes hash on [data] of length [len].
+ * and stores it into [digest]. [digest] should be pre-allocated to
+ * SHA256_DIGEST_SIZE bytes.
+ */
+uint8_t* internal_SHA256(const uint8_t* data, uint64_t len, uint8_t* digest);
+
+/* Convenience function for SHA-512.  Computes hash on [data] of length [len].
+ * and stores it into [digest]. [digest] should be pre-allocated to
+ * SHA512_DIGEST_SIZE bytes.
+ */
+uint8_t* internal_SHA512(const uint8_t* data, uint64_t len, uint8_t* digest);
+
+
+/*---- Utility functions/wrappers for message digests. */
+
+#define SHA1_DIGEST_ALGORITHM 0
+#define SHA256_DIGEST_ALGORITHM 1
+#define SHA512_DIGEST_ALGORITHM 2
+
+/* A generic digest context structure which can be used to represent
+ * the SHA*_CTX for multiple digest algorithms.
+ */
+typedef struct DigestContext {
+  SHA1_CTX* sha1_ctx;
+  SHA256_CTX* sha256_ctx;
+  SHA512_CTX* sha512_ctx;
+  int algorithm;  /* Hashing algorithm to use. */
+} DigestContext;
+
+/* Wrappers for message digest algorithms. These are useful when the hashing
+ * operation is being done in parallel with something else. DigestContext tracks
+ * and stores the state of any digest algorithm (one at any given time).
+ */
+
+/* Initialize a digest context for use with signature algorithm [algorithm]. */
+void DigestInit(DigestContext* ctx, int sig_algorithm);
+void DigestUpdate(DigestContext* ctx, const uint8_t* data, uint32_t len);
+
+/* Caller owns the returned digest and must free it. */
+uint8_t* DigestFinal(DigestContext* ctx);
+
+/* Returns the appropriate digest for the data in [input_file]
+ * based on the signature [algorithm].
+ * Caller owns the returned digest and must free it.
+ */
+uint8_t* DigestFile(char* input_file, int sig_algorithm);
+
+/* Returns the appropriate digest of [buf] of length
+ * [len] based on the signature [algorithm].
+ * Caller owns the returned digest and must free it.
+ */
+uint8_t* DigestBuf(const uint8_t* buf, uint64_t len, int sig_algorithm);
+
+
+#endif  /* VBOOT_REFERENCE_SHA_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/padding.c tools/vboot_utils/src/firmware/lib/cryptolib/padding.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/padding.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/padding.c	2014-04-27 13:03:45.740116128 +0000
@@ -0,0 +1,256 @@
+/*
+ * DO NOT MODIFY THIS FILE DIRECTLY.
+ *
+ * This file is automatically generated by genpadding.sh and contains padding
+ * arrays corresponding to various combinations of algorithms for RSA signatures.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+
+
+/*
+ * PKCS 1.5 padding (from the RSA PKCS#1 v2.1 standard)
+ *
+ * Depending on the RSA key size and hash function, the padding is calculated
+ * as follows:
+ *
+ * 0x00 || 0x01 || PS || 0x00 || T
+ *
+ * T: DER Encoded DigestInfo value which depends on the hash function used.
+ *
+ * SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H.
+ * SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H.
+ * SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H.
+ *
+ * Length(T) = 35 octets for SHA-1
+ * Length(T) = 51 octets for SHA-256
+ * Length(T) = 83 octets for SHA-512
+ *
+ * PS: octet string consisting of {Length(RSA Key) - Length(T) - 3} 0xFF
+ *
+ */
+
+
+#ifndef CHROMEOS_EC
+/* Algorithm Type 0 */
+const uint8_t paddingRSA1024_SHA1[RSA1024NUMBYTES - SHA1_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14
+};
+
+/* Algorithm Type 1 */
+const uint8_t paddingRSA1024_SHA256[RSA1024NUMBYTES - SHA256_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
+};
+
+/* Algorithm Type 2 */
+const uint8_t paddingRSA1024_SHA512[RSA1024NUMBYTES - SHA512_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
+};
+
+/* Algorithm Type 3 */
+const uint8_t paddingRSA2048_SHA1[RSA2048NUMBYTES - SHA1_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14
+};
+
+/* Algorithm Type 4 */
+const uint8_t paddingRSA2048_SHA256[RSA2048NUMBYTES - SHA256_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
+};
+
+/* Algorithm Type 5 */
+const uint8_t paddingRSA2048_SHA512[RSA2048NUMBYTES - SHA512_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
+};
+
+/* Algorithm Type 6 */
+const uint8_t paddingRSA4096_SHA1[RSA4096NUMBYTES - SHA1_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14
+};
+
+/* Algorithm Type 7 */
+const uint8_t paddingRSA4096_SHA256[RSA4096NUMBYTES - SHA256_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
+};
+
+/* Algorithm Type 8 */
+const uint8_t paddingRSA4096_SHA512[RSA4096NUMBYTES - SHA512_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
+};
+
+/* Algorithm Type 9 */
+const uint8_t paddingRSA8192_SHA1[RSA8192NUMBYTES - SHA1_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14
+};
+
+/* Algorithm Type 10 */
+const uint8_t paddingRSA8192_SHA256[RSA8192NUMBYTES - SHA256_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
+};
+
+/* Algorithm Type 11 */
+const uint8_t paddingRSA8192_SHA512[RSA8192NUMBYTES - SHA512_DIGEST_SIZE] = {
+0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
+};
+
+const int kNumAlgorithms = 12;
+#define NUMALGORITHMS 12
+
+#define SHA1_DIGESTINFO_LEN 15
+const uint8_t SHA1_digestinfo[] = {
+0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14
+};
+
+#endif /* !CHROMEOS_EC */
+
+/* CHROMEOS_EC needs just this itty-bitty part... */
+
+#define SHA256_DIGESTINFO_LEN 19
+const uint8_t SHA256_digestinfo[] = {
+0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
+};
+
+#ifndef CHROMEOS_EC
+
+#define SHA512_DIGESTINFO_LEN 19
+const uint8_t SHA512_digestinfo[] = {
+0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
+};
+
+const int digestinfo_size_map[] = {
+SHA1_DIGESTINFO_LEN,
+SHA256_DIGESTINFO_LEN,
+SHA512_DIGESTINFO_LEN,
+SHA1_DIGESTINFO_LEN,
+SHA256_DIGESTINFO_LEN,
+SHA512_DIGESTINFO_LEN,
+SHA1_DIGESTINFO_LEN,
+SHA256_DIGESTINFO_LEN,
+SHA512_DIGESTINFO_LEN,
+SHA1_DIGESTINFO_LEN,
+SHA256_DIGESTINFO_LEN,
+SHA512_DIGESTINFO_LEN,
+};
+
+const int siglen_map[NUMALGORITHMS] = {
+RSA1024NUMBYTES,
+RSA1024NUMBYTES,
+RSA1024NUMBYTES,
+RSA2048NUMBYTES,
+RSA2048NUMBYTES,
+RSA2048NUMBYTES,
+RSA4096NUMBYTES,
+RSA4096NUMBYTES,
+RSA4096NUMBYTES,
+RSA8192NUMBYTES,
+RSA8192NUMBYTES,
+RSA8192NUMBYTES,
+};
+
+const uint8_t* const padding_map[NUMALGORITHMS] = {
+paddingRSA1024_SHA1,
+paddingRSA1024_SHA256,
+paddingRSA1024_SHA512,
+paddingRSA2048_SHA1,
+paddingRSA2048_SHA256,
+paddingRSA2048_SHA512,
+paddingRSA4096_SHA1,
+paddingRSA4096_SHA256,
+paddingRSA4096_SHA512,
+paddingRSA8192_SHA1,
+paddingRSA8192_SHA256,
+paddingRSA8192_SHA512,
+};
+
+const int padding_size_map[NUMALGORITHMS] = {
+RSA1024NUMBYTES - SHA1_DIGEST_SIZE,
+RSA1024NUMBYTES - SHA256_DIGEST_SIZE,
+RSA1024NUMBYTES - SHA512_DIGEST_SIZE,
+RSA2048NUMBYTES - SHA1_DIGEST_SIZE,
+RSA2048NUMBYTES - SHA256_DIGEST_SIZE,
+RSA2048NUMBYTES - SHA512_DIGEST_SIZE,
+RSA4096NUMBYTES - SHA1_DIGEST_SIZE,
+RSA4096NUMBYTES - SHA256_DIGEST_SIZE,
+RSA4096NUMBYTES - SHA512_DIGEST_SIZE,
+RSA8192NUMBYTES - SHA1_DIGEST_SIZE,
+RSA8192NUMBYTES - SHA256_DIGEST_SIZE,
+RSA8192NUMBYTES - SHA512_DIGEST_SIZE,
+};
+
+const int hash_type_map[] = {
+SHA1_DIGEST_ALGORITHM,
+SHA256_DIGEST_ALGORITHM,
+SHA512_DIGEST_ALGORITHM,
+SHA1_DIGEST_ALGORITHM,
+SHA256_DIGEST_ALGORITHM,
+SHA512_DIGEST_ALGORITHM,
+SHA1_DIGEST_ALGORITHM,
+SHA256_DIGEST_ALGORITHM,
+SHA512_DIGEST_ALGORITHM,
+SHA1_DIGEST_ALGORITHM,
+SHA256_DIGEST_ALGORITHM,
+SHA512_DIGEST_ALGORITHM,
+};
+
+const int hash_size_map[NUMALGORITHMS] = {
+SHA1_DIGEST_SIZE,
+SHA256_DIGEST_SIZE,
+SHA512_DIGEST_SIZE,
+SHA1_DIGEST_SIZE,
+SHA256_DIGEST_SIZE,
+SHA512_DIGEST_SIZE,
+SHA1_DIGEST_SIZE,
+SHA256_DIGEST_SIZE,
+SHA512_DIGEST_SIZE,
+SHA1_DIGEST_SIZE,
+SHA256_DIGEST_SIZE,
+SHA512_DIGEST_SIZE,
+};
+
+const int hash_blocksize_map[NUMALGORITHMS] = {
+SHA1_BLOCK_SIZE,
+SHA256_BLOCK_SIZE,
+SHA512_BLOCK_SIZE,
+SHA1_BLOCK_SIZE,
+SHA256_BLOCK_SIZE,
+SHA512_BLOCK_SIZE,
+SHA1_BLOCK_SIZE,
+SHA256_BLOCK_SIZE,
+SHA512_BLOCK_SIZE,
+SHA1_BLOCK_SIZE,
+SHA256_BLOCK_SIZE,
+SHA512_BLOCK_SIZE,
+};
+
+const uint8_t* const hash_digestinfo_map[NUMALGORITHMS] = {
+SHA1_digestinfo,
+SHA256_digestinfo,
+SHA512_digestinfo,
+SHA1_digestinfo,
+SHA256_digestinfo,
+SHA512_digestinfo,
+SHA1_digestinfo,
+SHA256_digestinfo,
+SHA512_digestinfo,
+SHA1_digestinfo,
+SHA256_digestinfo,
+SHA512_digestinfo,
+};
+
+const char* const algo_strings[NUMALGORITHMS] = {
+"RSA1024 SHA1",
+"RSA1024 SHA256",
+"RSA1024 SHA512",
+"RSA2048 SHA1",
+"RSA2048 SHA256",
+"RSA2048 SHA512",
+"RSA4096 SHA1",
+"RSA4096 SHA256",
+"RSA4096 SHA512",
+"RSA8192 SHA1",
+"RSA8192 SHA256",
+"RSA8192 SHA512",
+};
+
+#endif /* !CHROMEOS_EC */
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/README tools/vboot_utils/src/firmware/lib/cryptolib/README
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/README	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/README	2014-04-27 13:03:45.736115854 +0000
@@ -0,0 +1,3 @@
+This contains the implementation for the crypto library. This includes
+implementations for SHA1, SHA256, SHA512, and RSA signature verification
+(for PKCS #1 v1.5 signatures).
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/rsa.c tools/vboot_utils/src/firmware/lib/cryptolib/rsa.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/rsa.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/rsa.c	2014-04-27 13:03:45.740116128 +0000
@@ -0,0 +1,186 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/* Implementation of RSA signature verification which uses a pre-processed
+ * key for computation. The code extends Android's RSA verification code to
+ * support multiple RSA key lengths and hash digest algorithms.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "vboot_api.h"
+#include "utility.h"
+
+/* a[] -= mod */
+static void subM(const RSAPublicKey *key, uint32_t *a) {
+  int64_t A = 0;
+  uint32_t i;
+  for (i = 0; i < key->len; ++i) {
+    A += (uint64_t)a[i] - key->n[i];
+    a[i] = (uint32_t)A;
+    A >>= 32;
+  }
+}
+
+/* return a[] >= mod */
+static int geM(const RSAPublicKey *key, uint32_t *a) {
+  uint32_t i;
+  for (i = key->len; i;) {
+    --i;
+    if (a[i] < key->n[i]) return 0;
+    if (a[i] > key->n[i]) return 1;
+  }
+  return 1;  /* equal */
+ }
+
+/* montgomery c[] += a * b[] / R % mod */
+static void montMulAdd(const RSAPublicKey *key,
+                       uint32_t* c,
+                       const uint32_t a,
+                       const uint32_t* b) {
+  uint64_t A = (uint64_t)a * b[0] + c[0];
+  uint32_t d0 = (uint32_t)A * key->n0inv;
+  uint64_t B = (uint64_t)d0 * key->n[0] + (uint32_t)A;
+  uint32_t i;
+
+  for (i = 1; i < key->len; ++i) {
+    A = (A >> 32) + (uint64_t)a * b[i] + c[i];
+    B = (B >> 32) + (uint64_t)d0 * key->n[i] + (uint32_t)A;
+    c[i - 1] = (uint32_t)B;
+  }
+
+  A = (A >> 32) + (B >> 32);
+
+  c[i - 1] = (uint32_t)A;
+
+  if (A >> 32) {
+    subM(key, c);
+  }
+}
+
+/* montgomery c[] = a[] * b[] / R % mod */
+static void montMul(const RSAPublicKey *key,
+                    uint32_t* c,
+                    uint32_t* a,
+                    uint32_t* b) {
+  uint32_t i;
+  for (i = 0; i < key->len; ++i) {
+    c[i] = 0;
+  }
+  for (i = 0; i < key->len; ++i) {
+    montMulAdd(key, c, a[i], b);
+  }
+}
+
+/* In-place public exponentiation. (65537}
+ * Input and output big-endian byte array in inout.
+ */
+static void modpowF4(const RSAPublicKey *key,
+                    uint8_t* inout) {
+  uint32_t* a = (uint32_t*) VbExMalloc(key->len * sizeof(uint32_t));
+  uint32_t* aR = (uint32_t*) VbExMalloc(key->len * sizeof(uint32_t));
+  uint32_t* aaR = (uint32_t*) VbExMalloc(key->len * sizeof(uint32_t));
+
+  uint32_t* aaa = aaR;  /* Re-use location. */
+  int i;
+
+  /* Convert from big endian byte array to little endian word array. */
+  for (i = 0; i < (int)key->len; ++i) {
+    uint32_t tmp =
+        (inout[((key->len - 1 - i) * 4) + 0] << 24) |
+        (inout[((key->len - 1 - i) * 4) + 1] << 16) |
+        (inout[((key->len - 1 - i) * 4) + 2] << 8) |
+        (inout[((key->len - 1 - i) * 4) + 3] << 0);
+    a[i] = tmp;
+  }
+
+  montMul(key, aR, a, key->rr);  /* aR = a * RR / R mod M   */
+  for (i = 0; i < 16; i+=2) {
+    montMul(key, aaR, aR, aR);  /* aaR = aR * aR / R mod M */
+    montMul(key, aR, aaR, aaR);  /* aR = aaR * aaR / R mod M */
+  }
+  montMul(key, aaa, aR, a);  /* aaa = aR * a / R mod M */
+
+
+  /* Make sure aaa < mod; aaa is at most 1x mod too large. */
+  if (geM(key, aaa)) {
+    subM(key, aaa);
+  }
+
+  /* Convert to bigendian byte array */
+  for (i = (int)key->len - 1; i >= 0; --i) {
+    uint32_t tmp = aaa[i];
+    *inout++ = (uint8_t)(tmp >> 24);
+    *inout++ = (uint8_t)(tmp >> 16);
+    *inout++ = (uint8_t)(tmp >>  8);
+    *inout++ = (uint8_t)(tmp >>  0);
+  }
+
+  VbExFree(a);
+  VbExFree(aR);
+  VbExFree(aaR);
+}
+
+/* Verify a RSA PKCS1.5 signature against an expected hash.
+ * Returns 0 on failure, 1 on success.
+ */
+int RSAVerify(const RSAPublicKey *key,
+              const uint8_t *sig,
+              const uint32_t sig_len,
+              const uint8_t sig_type,
+              const uint8_t *hash) {
+  uint8_t* buf;
+  const uint8_t* padding;
+  int padding_len;
+  int success = 1;
+
+  if (!key || !sig || !hash)
+    return 0;
+
+  if (sig_len != (key->len * sizeof(uint32_t))) {
+    VBDEBUG(("Signature is of incorrect length!\n"));
+    return 0;
+  }
+
+  if (sig_type >= kNumAlgorithms) {
+    VBDEBUG(("Invalid signature type!\n"));
+    return 0;
+  }
+
+  if (key->len != siglen_map[sig_type] / sizeof(uint32_t)) {
+    VBDEBUG(("Wrong key passed in!\n"));
+    return 0;
+  }
+
+  buf = (uint8_t*) VbExMalloc(sig_len);
+  if (!buf)
+    return 0;
+  Memcpy(buf, sig, sig_len);
+
+  modpowF4(key, buf);
+
+  /* Determine padding to use depending on the signature type. */
+  padding = padding_map[sig_type];
+  padding_len = padding_size_map[sig_type];
+
+  /* Even though there are probably no timing issues here, we use
+   * SafeMemcmp() just to be on the safe side. */
+
+  /* Check pkcs1.5 padding bytes. */
+  if (SafeMemcmp(buf, padding, padding_len)) {
+    VBDEBUG(("In RSAVerify(): Padding check failed!\n"));
+    success = 0;
+  }
+
+  /* Check hash. */
+  if (SafeMemcmp(buf + padding_len, hash, sig_len - padding_len)) {
+    VBDEBUG(("In RSAVerify(): Hash check failed!\n"));
+    success  = 0;
+  }
+  VbExFree(buf);
+
+  return success;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/rsa_utility.c tools/vboot_utils/src/firmware/lib/cryptolib/rsa_utility.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/rsa_utility.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/rsa_utility.c	2014-04-27 13:03:45.744116403 +0000
@@ -0,0 +1,157 @@
+/* Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Implementation of RSA utility functions.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "stateful_util.h"
+#include "utility.h"
+#include "vboot_api.h"
+
+uint64_t RSAProcessedKeySize(uint64_t algorithm, uint64_t* out_size) {
+  int key_len; /* Key length in bytes.  (int type matches siglen_map) */
+  if (algorithm < kNumAlgorithms) {
+    key_len = siglen_map[algorithm];
+    /* Total size needed by a RSAPublicKey buffer is =
+     *  2 * key_len bytes for the  n and rr arrays
+     *  + sizeof len + sizeof n0inv.
+     */
+    *out_size = (2 * key_len + sizeof(uint32_t) + sizeof(uint32_t));
+    return 1;
+  }
+  return 0;
+}
+
+RSAPublicKey* RSAPublicKeyNew(void) {
+  RSAPublicKey* key = (RSAPublicKey*) VbExMalloc(sizeof(RSAPublicKey));
+  key->n = NULL;
+  key->rr = NULL;
+  key->len = 0;
+  key->algorithm = kNumAlgorithms;
+  return key;
+}
+
+void RSAPublicKeyFree(RSAPublicKey* key) {
+  if (key) {
+    if (key->n)
+      VbExFree(key->n);
+    if (key->rr)
+      VbExFree(key->rr);
+    VbExFree(key);
+  }
+}
+
+RSAPublicKey* RSAPublicKeyFromBuf(const uint8_t* buf, uint64_t len) {
+  RSAPublicKey* key = RSAPublicKeyNew();
+  MemcpyState st;
+  uint64_t key_len;
+
+  StatefulInit(&st, (void*)buf, len);
+
+  StatefulMemcpy(&st, &key->len, sizeof(key->len));
+  /* key length in bytes (avoiding possible 32-bit rollover) */
+  key_len = key->len;
+  key_len *= sizeof(uint32_t);
+
+  /* Sanity Check the key length. */
+  if (RSA1024NUMBYTES != key_len &&
+      RSA2048NUMBYTES != key_len &&
+      RSA4096NUMBYTES != key_len &&
+      RSA8192NUMBYTES != key_len) {
+    RSAPublicKeyFree(key);
+    return NULL;
+  }
+
+  key->n = (uint32_t*) VbExMalloc(key_len);
+  key->rr = (uint32_t*) VbExMalloc(key_len);
+
+  StatefulMemcpy(&st, &key->n0inv, sizeof(key->n0inv));
+  StatefulMemcpy(&st, key->n, key_len);
+  StatefulMemcpy(&st, key->rr, key_len);
+  if (st.overrun || st.remaining_len != 0) {  /* Underrun or overrun. */
+    RSAPublicKeyFree(key);
+    return NULL;
+  }
+
+  return key;
+}
+
+int RSAVerifyBinary_f(const uint8_t* key_blob,
+                      const RSAPublicKey* key,
+                      const uint8_t* buf,
+                      uint64_t len,
+                      const uint8_t* sig,
+                      unsigned int algorithm) {
+  RSAPublicKey* verification_key = NULL;
+  uint8_t* digest = NULL;
+  uint64_t key_size;
+  int sig_size;
+  int success;
+
+  if (algorithm >= (unsigned int)kNumAlgorithms)
+    return 0;  /* Invalid algorithm. */
+  if (!RSAProcessedKeySize(algorithm, &key_size))
+    return 0;
+  sig_size = siglen_map[algorithm];
+
+  if (key_blob && !key)
+    verification_key = RSAPublicKeyFromBuf(key_blob, key_size);
+  else if (!key_blob && key)
+    verification_key = (RSAPublicKey*) key;  /* Supress const warning. */
+  else
+    return 0; /* Both can't be NULL or non-NULL. */
+
+  /* Ensure we have a valid key. */
+  if (!verification_key)
+    return 0;
+
+  digest = DigestBuf(buf, len, algorithm);
+  success = RSAVerify(verification_key, sig, (uint32_t)sig_size,
+                      (uint8_t)algorithm, digest);
+
+  VbExFree(digest);
+  if (!key)
+    RSAPublicKeyFree(verification_key);  /* Only free if we allocated it. */
+  return success;
+}
+
+/* Version of RSAVerifyBinary_f() where instead of the raw binary blob
+ * of data, its digest is passed as the argument. */
+int RSAVerifyBinaryWithDigest_f(const uint8_t* key_blob,
+                                const RSAPublicKey* key,
+                                const uint8_t* digest,
+                                const uint8_t* sig,
+                                unsigned int algorithm) {
+  RSAPublicKey* verification_key = NULL;
+  uint64_t key_size;
+  int sig_size;
+  int success;
+
+  if (algorithm >= (unsigned int)kNumAlgorithms)
+    return 0;  /* Invalid algorithm. */
+  if (!RSAProcessedKeySize(algorithm, &key_size))
+    return 0;
+  sig_size = siglen_map[algorithm];
+
+  if (key_blob && !key)
+    verification_key = RSAPublicKeyFromBuf(key_blob, key_size);
+  else if (!key_blob && key)
+    verification_key = (RSAPublicKey*) key;  /* Supress const warning. */
+  else
+    return 0; /* Both can't be NULL or non-NULL. */
+
+  /* Ensure we have a valid key. */
+  if (!verification_key)
+    return 0;
+
+  success = RSAVerify(verification_key, sig, (uint32_t)sig_size,
+                      (uint8_t)algorithm, digest);
+
+  if (!key)
+    RSAPublicKeyFree(verification_key);  /* Only free if we allocated it. */
+  return success;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/sha1.c tools/vboot_utils/src/firmware/lib/cryptolib/sha1.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/sha1.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/sha1.c	2014-04-27 13:03:45.744116403 +0000
@@ -0,0 +1,289 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * SHA-1 implementation largely based on libmincrypt in the the Android
+ * Open Source Project (platorm/system/core.git/libmincrypt/sha.c
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "utility.h"
+
+
+/* Some machines lack byteswap.h and endian.h. These have to use the
+ * slower code, even if they're little-endian.
+ */
+
+#if defined(HAVE_ENDIAN_H) && defined(HAVE_LITTLE_ENDIAN)
+
+/* This version is about 28% faster than the generic version below,
+ * but assumes little-endianness.
+ */
+static uint32_t ror27(uint32_t val) {
+  return (val >> 27) | (val << 5);
+}
+static uint32_t ror2(uint32_t val) {
+  return (val >> 2) | (val << 30);
+}
+static uint32_t ror31(uint32_t val) {
+  return (val >> 31) | (val << 1);
+}
+
+static void SHA1_Transform(SHA1_CTX* ctx) {
+  uint32_t W[80];
+  register uint32_t A, B, C, D, E;
+  int t;
+
+  A = ctx->state[0];
+  B = ctx->state[1];
+  C = ctx->state[2];
+  D = ctx->state[3];
+  E = ctx->state[4];
+
+#define SHA_F1(A,B,C,D,E,t)                     \
+  E += ror27(A) +                               \
+      (W[t] = bswap_32(ctx->buf.w[t])) +        \
+      (D^(B&(C^D))) + 0x5A827999;               \
+  B = ror2(B);
+
+  for (t = 0; t < 15; t += 5) {
+    SHA_F1(A,B,C,D,E,t + 0);
+    SHA_F1(E,A,B,C,D,t + 1);
+    SHA_F1(D,E,A,B,C,t + 2);
+    SHA_F1(C,D,E,A,B,t + 3);
+    SHA_F1(B,C,D,E,A,t + 4);
+  }
+  SHA_F1(A,B,C,D,E,t + 0);  /* 16th one, t == 15 */
+
+#undef SHA_F1
+
+#define SHA_F1(A,B,C,D,E,t)                                     \
+  E += ror27(A) +                                               \
+      (W[t] = ror31(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16])) +     \
+      (D^(B&(C^D))) + 0x5A827999;                               \
+  B = ror2(B);
+
+  SHA_F1(E,A,B,C,D,t + 1);
+  SHA_F1(D,E,A,B,C,t + 2);
+  SHA_F1(C,D,E,A,B,t + 3);
+  SHA_F1(B,C,D,E,A,t + 4);
+
+#undef SHA_F1
+
+#define SHA_F2(A,B,C,D,E,t)                                     \
+  E += ror27(A) +                                               \
+      (W[t] = ror31(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16])) +     \
+      (B^C^D) + 0x6ED9EBA1;                                     \
+  B = ror2(B);
+
+  for (t = 20; t < 40; t += 5) {
+    SHA_F2(A,B,C,D,E,t + 0);
+    SHA_F2(E,A,B,C,D,t + 1);
+    SHA_F2(D,E,A,B,C,t + 2);
+    SHA_F2(C,D,E,A,B,t + 3);
+    SHA_F2(B,C,D,E,A,t + 4);
+  }
+
+#undef SHA_F2
+
+#define SHA_F3(A,B,C,D,E,t)                                     \
+  E += ror27(A) +                                               \
+      (W[t] = ror31(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16])) +     \
+      ((B&C)|(D&(B|C))) + 0x8F1BBCDC;                           \
+  B = ror2(B);
+
+  for (; t < 60; t += 5) {
+    SHA_F3(A,B,C,D,E,t + 0);
+    SHA_F3(E,A,B,C,D,t + 1);
+    SHA_F3(D,E,A,B,C,t + 2);
+    SHA_F3(C,D,E,A,B,t + 3);
+    SHA_F3(B,C,D,E,A,t + 4);
+  }
+
+#undef SHA_F3
+
+#define SHA_F4(A,B,C,D,E,t)                                     \
+  E += ror27(A) +                                               \
+      (W[t] = ror31(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16])) +     \
+      (B^C^D) + 0xCA62C1D6;                                     \
+  B = ror2(B);
+
+  for (; t < 80; t += 5) {
+    SHA_F4(A,B,C,D,E,t + 0);
+    SHA_F4(E,A,B,C,D,t + 1);
+    SHA_F4(D,E,A,B,C,t + 2);
+    SHA_F4(C,D,E,A,B,t + 3);
+    SHA_F4(B,C,D,E,A,t + 4);
+  }
+
+#undef SHA_F4
+
+  ctx->state[0] += A;
+  ctx->state[1] += B;
+  ctx->state[2] += C;
+  ctx->state[3] += D;
+  ctx->state[4] += E;
+}
+
+void SHA1_update(SHA1_CTX* ctx, const uint8_t* data, uint64_t len) {
+  int i = ctx->count % sizeof(ctx->buf);
+  const uint8_t* p = (const uint8_t*)data;
+
+  ctx->count += len;
+
+  while (len > sizeof(ctx->buf) - i) {
+    Memcpy(&ctx->buf.b[i], p, sizeof(ctx->buf) - i);
+    len -= sizeof(ctx->buf) - i;
+    p += sizeof(ctx->buf) - i;
+    SHA1_Transform(ctx);
+    i = 0;
+  }
+
+  while (len--) {
+    ctx->buf.b[i++] = *p++;
+    if (i == sizeof(ctx->buf)) {
+      SHA1_Transform(ctx);
+      i = 0;
+    }
+  }
+}
+
+
+uint8_t* SHA1_final(SHA1_CTX* ctx) {
+  uint64_t cnt = ctx->count * 8;
+  int i;
+
+  SHA1_update(ctx, (uint8_t*)"\x80", 1);
+  while ((ctx->count % sizeof(ctx->buf)) != (sizeof(ctx->buf) - 8)) {
+    SHA1_update(ctx, (uint8_t*)"\0", 1);
+  }
+  for (i = 0; i < 8; ++i) {
+    uint8_t tmp = cnt >> ((7 - i) * 8);
+    SHA1_update(ctx, &tmp, 1);
+  }
+
+  for (i = 0; i < 5; i++) {
+    ctx->buf.w[i] = bswap_32(ctx->state[i]);
+  }
+
+  return ctx->buf.b;
+}
+
+#else   /* #if defined(HAVE_ENDIAN_H) && defined(HAVE_LITTLE_ENDIAN) */
+
+#define rol(bits, value) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+static void SHA1_transform(SHA1_CTX *ctx) {
+  uint32_t W[80];
+  uint32_t A, B, C, D, E;
+  uint8_t *p = ctx->buf;
+  int t;
+
+  for(t = 0; t < 16; ++t) {
+    uint32_t tmp =  *p++ << 24;
+    tmp |= *p++ << 16;
+    tmp |= *p++ << 8;
+    tmp |= *p++;
+    W[t] = tmp;
+  }
+
+  for(; t < 80; t++) {
+    W[t] = rol(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
+  }
+
+  A = ctx->state[0];
+  B = ctx->state[1];
+  C = ctx->state[2];
+  D = ctx->state[3];
+  E = ctx->state[4];
+
+  for(t = 0; t < 80; t++) {
+    uint32_t tmp = rol(5,A) + E + W[t];
+
+    if (t < 20)
+      tmp += (D^(B&(C^D))) + 0x5A827999;
+    else if ( t < 40)
+      tmp += (B^C^D) + 0x6ED9EBA1;
+    else if ( t < 60)
+      tmp += ((B&C)|(D&(B|C))) + 0x8F1BBCDC;
+    else
+      tmp += (B^C^D) + 0xCA62C1D6;
+
+    E = D;
+    D = C;
+    C = rol(30,B);
+    B = A;
+    A = tmp;
+  }
+
+  ctx->state[0] += A;
+  ctx->state[1] += B;
+  ctx->state[2] += C;
+  ctx->state[3] += D;
+  ctx->state[4] += E;
+}
+
+void SHA1_update(SHA1_CTX *ctx, const uint8_t *data, uint64_t len) {
+  int i = (int)(ctx->count % sizeof(ctx->buf));
+  const uint8_t* p = (const uint8_t*) data;
+
+  ctx->count += len;
+
+  while (len--) {
+    ctx->buf[i++] = *p++;
+    if (i == sizeof(ctx->buf)) {
+      SHA1_transform(ctx);
+      i = 0;
+    }
+  }
+}
+uint8_t* SHA1_final(SHA1_CTX *ctx) {
+  uint8_t *p = ctx->buf;
+  uint64_t cnt = ctx->count << 3;
+  int i;
+
+  SHA1_update(ctx, (uint8_t*)"\x80", 1);
+  while ((ctx->count % sizeof(ctx->buf)) != (sizeof(ctx->buf) - 8)) {
+    SHA1_update(ctx, (uint8_t*)"\0", 1);
+  }
+  for (i = 0; i < 8; ++i) {
+    uint8_t tmp = (uint8_t)((uint64_t)cnt >> ((7 - i) * 8));
+    SHA1_update(ctx, &tmp, 1);
+  }
+
+  for (i = 0; i < 5; i++) {
+    uint32_t tmp = ctx->state[i];
+    *p++ = (uint8_t)(tmp >> 24);
+    *p++ = (uint8_t)(tmp >> 16);
+    *p++ = (uint8_t)(tmp >> 8);
+    *p++ = (uint8_t)(tmp >> 0);
+  }
+
+  return ctx->buf;
+}
+
+#endif /* endianness */
+
+void SHA1_init(SHA1_CTX* ctx) {
+  ctx->state[0] = 0x67452301;
+  ctx->state[1] = 0xEFCDAB89;
+  ctx->state[2] = 0x98BADCFE;
+  ctx->state[3] = 0x10325476;
+  ctx->state[4] = 0xC3D2E1F0;
+  ctx->count = 0;
+}
+
+uint8_t* internal_SHA1(const uint8_t *data, uint64_t len, uint8_t *digest) {
+  const uint8_t *p;
+  int i;
+  SHA1_CTX ctx;
+  SHA1_init(&ctx);
+  SHA1_update(&ctx, data, len);
+  p = SHA1_final(&ctx);
+  for (i = 0; i < SHA1_DIGEST_SIZE; ++i) {
+    digest[i] = *p++;
+  }
+  return digest;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/sha256.c tools/vboot_utils/src/firmware/lib/cryptolib/sha256.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/sha256.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/sha256.c	2014-04-27 13:03:45.748116679 +0000
@@ -0,0 +1,342 @@
+/* SHA-256 and SHA-512 implementation based on code by Oliver Gay
+ * <olivier.gay@a3.epfl.ch> under a BSD-style license. See below.
+ */
+
+/*
+ * FIPS 180-2 SHA-224/256/384/512 implementation
+ * Last update: 02/02/2007
+ * Issue date:  04/30/2005
+ *
+ * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "utility.h"
+
+#define SHFR(x, n)    (x >> n)
+#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
+#define ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
+#define CH(x, y, z)  ((x & y) ^ (~x & z))
+#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
+
+#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))
+#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))
+
+#define UNPACK32(x, str)                        \
+  {                                             \
+    *((str) + 3) = (uint8_t) ((x)      );       \
+    *((str) + 2) = (uint8_t) ((x) >>  8);       \
+    *((str) + 1) = (uint8_t) ((x) >> 16);       \
+    *((str) + 0) = (uint8_t) ((x) >> 24);       \
+  }
+
+#define PACK32(str, x)                          \
+  {                                             \
+    *(x) =   ((uint32_t) *((str) + 3)      )    \
+        | ((uint32_t) *((str) + 2) <<  8)       \
+        | ((uint32_t) *((str) + 1) << 16)       \
+        | ((uint32_t) *((str) + 0) << 24);      \
+  }
+
+/* Macros used for loops unrolling */
+
+#define SHA256_SCR(i)                         \
+  {                                           \
+    w[i] =  SHA256_F4(w[i -  2]) + w[i -  7]  \
+        + SHA256_F3(w[i - 15]) + w[i - 16];   \
+  }
+
+#define SHA256_EXP(a, b, c, d, e, f, g, h, j)               \
+  {                                                         \
+    t1 = wv[h] + SHA256_F2(wv[e]) + CH(wv[e], wv[f], wv[g]) \
+        + sha256_k[j] + w[j];                               \
+    t2 = SHA256_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);       \
+    wv[d] += t1;                                            \
+    wv[h] = t1 + t2;                                        \
+  }
+
+static const uint32_t sha256_h0[8] = {
+  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
+  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
+
+static const uint32_t sha256_k[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
+
+
+/* SHA-256 implementation */
+void SHA256_init(SHA256_CTX *ctx) {
+#ifndef UNROLL_LOOPS
+    int i;
+    for (i = 0; i < 8; i++) {
+        ctx->h[i] = sha256_h0[i];
+    }
+#else
+    ctx->h[0] = sha256_h0[0]; ctx->h[1] = sha256_h0[1];
+    ctx->h[2] = sha256_h0[2]; ctx->h[3] = sha256_h0[3];
+    ctx->h[4] = sha256_h0[4]; ctx->h[5] = sha256_h0[5];
+    ctx->h[6] = sha256_h0[6]; ctx->h[7] = sha256_h0[7];
+#endif /* !UNROLL_LOOPS */
+
+    ctx->len = 0;
+    ctx->tot_len = 0;
+}
+
+
+static void SHA256_transform(SHA256_CTX* ctx, const uint8_t* message,
+                             unsigned int block_nb) {
+  uint32_t w[64];
+  uint32_t wv[8];
+  uint32_t t1, t2;
+  const unsigned char *sub_block;
+  int i;
+
+#ifndef UNROLL_LOOPS
+  int j;
+#endif
+
+  for (i = 0; i < (int) block_nb; i++) {
+    sub_block = message + (i << 6);
+
+#ifndef UNROLL_LOOPS
+    for (j = 0; j < 16; j++) {
+      PACK32(&sub_block[j << 2], &w[j]);
+    }
+
+    for (j = 16; j < 64; j++) {
+      SHA256_SCR(j);
+    }
+
+    for (j = 0; j < 8; j++) {
+      wv[j] = ctx->h[j];
+    }
+
+    for (j = 0; j < 64; j++) {
+      t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
+          + sha256_k[j] + w[j];
+      t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
+      wv[7] = wv[6];
+      wv[6] = wv[5];
+      wv[5] = wv[4];
+      wv[4] = wv[3] + t1;
+      wv[3] = wv[2];
+      wv[2] = wv[1];
+      wv[1] = wv[0];
+      wv[0] = t1 + t2;
+    }
+
+    for (j = 0; j < 8; j++) {
+      ctx->h[j] += wv[j];
+    }
+#else
+    PACK32(&sub_block[ 0], &w[ 0]); PACK32(&sub_block[ 4], &w[ 1]);
+    PACK32(&sub_block[ 8], &w[ 2]); PACK32(&sub_block[12], &w[ 3]);
+    PACK32(&sub_block[16], &w[ 4]); PACK32(&sub_block[20], &w[ 5]);
+    PACK32(&sub_block[24], &w[ 6]); PACK32(&sub_block[28], &w[ 7]);
+    PACK32(&sub_block[32], &w[ 8]); PACK32(&sub_block[36], &w[ 9]);
+    PACK32(&sub_block[40], &w[10]); PACK32(&sub_block[44], &w[11]);
+    PACK32(&sub_block[48], &w[12]); PACK32(&sub_block[52], &w[13]);
+    PACK32(&sub_block[56], &w[14]); PACK32(&sub_block[60], &w[15]);
+
+    SHA256_SCR(16); SHA256_SCR(17); SHA256_SCR(18); SHA256_SCR(19);
+    SHA256_SCR(20); SHA256_SCR(21); SHA256_SCR(22); SHA256_SCR(23);
+    SHA256_SCR(24); SHA256_SCR(25); SHA256_SCR(26); SHA256_SCR(27);
+    SHA256_SCR(28); SHA256_SCR(29); SHA256_SCR(30); SHA256_SCR(31);
+    SHA256_SCR(32); SHA256_SCR(33); SHA256_SCR(34); SHA256_SCR(35);
+    SHA256_SCR(36); SHA256_SCR(37); SHA256_SCR(38); SHA256_SCR(39);
+    SHA256_SCR(40); SHA256_SCR(41); SHA256_SCR(42); SHA256_SCR(43);
+    SHA256_SCR(44); SHA256_SCR(45); SHA256_SCR(46); SHA256_SCR(47);
+    SHA256_SCR(48); SHA256_SCR(49); SHA256_SCR(50); SHA256_SCR(51);
+    SHA256_SCR(52); SHA256_SCR(53); SHA256_SCR(54); SHA256_SCR(55);
+    SHA256_SCR(56); SHA256_SCR(57); SHA256_SCR(58); SHA256_SCR(59);
+    SHA256_SCR(60); SHA256_SCR(61); SHA256_SCR(62); SHA256_SCR(63);
+
+    wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
+    wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
+    wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
+    wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
+
+    SHA256_EXP(0,1,2,3,4,5,6,7, 0); SHA256_EXP(7,0,1,2,3,4,5,6, 1);
+    SHA256_EXP(6,7,0,1,2,3,4,5, 2); SHA256_EXP(5,6,7,0,1,2,3,4, 3);
+    SHA256_EXP(4,5,6,7,0,1,2,3, 4); SHA256_EXP(3,4,5,6,7,0,1,2, 5);
+    SHA256_EXP(2,3,4,5,6,7,0,1, 6); SHA256_EXP(1,2,3,4,5,6,7,0, 7);
+    SHA256_EXP(0,1,2,3,4,5,6,7, 8); SHA256_EXP(7,0,1,2,3,4,5,6, 9);
+    SHA256_EXP(6,7,0,1,2,3,4,5,10); SHA256_EXP(5,6,7,0,1,2,3,4,11);
+    SHA256_EXP(4,5,6,7,0,1,2,3,12); SHA256_EXP(3,4,5,6,7,0,1,2,13);
+    SHA256_EXP(2,3,4,5,6,7,0,1,14); SHA256_EXP(1,2,3,4,5,6,7,0,15);
+    SHA256_EXP(0,1,2,3,4,5,6,7,16); SHA256_EXP(7,0,1,2,3,4,5,6,17);
+    SHA256_EXP(6,7,0,1,2,3,4,5,18); SHA256_EXP(5,6,7,0,1,2,3,4,19);
+    SHA256_EXP(4,5,6,7,0,1,2,3,20); SHA256_EXP(3,4,5,6,7,0,1,2,21);
+    SHA256_EXP(2,3,4,5,6,7,0,1,22); SHA256_EXP(1,2,3,4,5,6,7,0,23);
+    SHA256_EXP(0,1,2,3,4,5,6,7,24); SHA256_EXP(7,0,1,2,3,4,5,6,25);
+    SHA256_EXP(6,7,0,1,2,3,4,5,26); SHA256_EXP(5,6,7,0,1,2,3,4,27);
+    SHA256_EXP(4,5,6,7,0,1,2,3,28); SHA256_EXP(3,4,5,6,7,0,1,2,29);
+    SHA256_EXP(2,3,4,5,6,7,0,1,30); SHA256_EXP(1,2,3,4,5,6,7,0,31);
+    SHA256_EXP(0,1,2,3,4,5,6,7,32); SHA256_EXP(7,0,1,2,3,4,5,6,33);
+    SHA256_EXP(6,7,0,1,2,3,4,5,34); SHA256_EXP(5,6,7,0,1,2,3,4,35);
+    SHA256_EXP(4,5,6,7,0,1,2,3,36); SHA256_EXP(3,4,5,6,7,0,1,2,37);
+    SHA256_EXP(2,3,4,5,6,7,0,1,38); SHA256_EXP(1,2,3,4,5,6,7,0,39);
+    SHA256_EXP(0,1,2,3,4,5,6,7,40); SHA256_EXP(7,0,1,2,3,4,5,6,41);
+    SHA256_EXP(6,7,0,1,2,3,4,5,42); SHA256_EXP(5,6,7,0,1,2,3,4,43);
+    SHA256_EXP(4,5,6,7,0,1,2,3,44); SHA256_EXP(3,4,5,6,7,0,1,2,45);
+    SHA256_EXP(2,3,4,5,6,7,0,1,46); SHA256_EXP(1,2,3,4,5,6,7,0,47);
+    SHA256_EXP(0,1,2,3,4,5,6,7,48); SHA256_EXP(7,0,1,2,3,4,5,6,49);
+    SHA256_EXP(6,7,0,1,2,3,4,5,50); SHA256_EXP(5,6,7,0,1,2,3,4,51);
+    SHA256_EXP(4,5,6,7,0,1,2,3,52); SHA256_EXP(3,4,5,6,7,0,1,2,53);
+    SHA256_EXP(2,3,4,5,6,7,0,1,54); SHA256_EXP(1,2,3,4,5,6,7,0,55);
+    SHA256_EXP(0,1,2,3,4,5,6,7,56); SHA256_EXP(7,0,1,2,3,4,5,6,57);
+    SHA256_EXP(6,7,0,1,2,3,4,5,58); SHA256_EXP(5,6,7,0,1,2,3,4,59);
+    SHA256_EXP(4,5,6,7,0,1,2,3,60); SHA256_EXP(3,4,5,6,7,0,1,2,61);
+    SHA256_EXP(2,3,4,5,6,7,0,1,62); SHA256_EXP(1,2,3,4,5,6,7,0,63);
+
+    ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
+    ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
+    ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
+    ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
+#endif /* !UNROLL_LOOPS */
+  }
+}
+
+
+
+void SHA256_update(SHA256_CTX* ctx, const uint8_t* data, uint32_t len) {
+    unsigned int block_nb;
+    unsigned int new_len, rem_len, tmp_len;
+    const uint8_t *shifted_data;
+
+    tmp_len = SHA256_BLOCK_SIZE - ctx->len;
+    rem_len = len < tmp_len ? len : tmp_len;
+
+    Memcpy(&ctx->block[ctx->len], data, rem_len);
+
+    if (ctx->len + len < SHA256_BLOCK_SIZE) {
+        ctx->len += len;
+        return;
+    }
+
+    new_len = len - rem_len;
+    block_nb = new_len / SHA256_BLOCK_SIZE;
+
+    shifted_data = data + rem_len;
+
+    SHA256_transform(ctx, ctx->block, 1);
+    SHA256_transform(ctx, shifted_data, block_nb);
+
+    rem_len = new_len % SHA256_BLOCK_SIZE;
+
+    Memcpy(ctx->block, &shifted_data[block_nb << 6],
+           rem_len);
+
+    ctx->len = rem_len;
+    ctx->tot_len += (block_nb + 1) << 6;
+}
+
+uint8_t* SHA256_final(SHA256_CTX* ctx) {
+    unsigned int block_nb;
+    unsigned int pm_len;
+    unsigned int len_b;
+#ifndef UNROLL_LOOPS
+    int i;
+#endif
+
+    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)
+                     < (ctx->len % SHA256_BLOCK_SIZE)));
+
+    len_b = (ctx->tot_len + ctx->len) << 3;
+    pm_len = block_nb << 6;
+
+    Memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
+    ctx->block[ctx->len] = 0x80;
+    UNPACK32(len_b, ctx->block + pm_len - 4);
+
+    SHA256_transform(ctx, ctx->block, block_nb);
+
+#ifndef UNROLL_LOOPS
+    for (i = 0 ; i < 8; i++) {
+        UNPACK32(ctx->h[i], &ctx->buf[i << 2]);
+    }
+#else
+   UNPACK32(ctx->h[0], &ctx->buf[ 0]);
+   UNPACK32(ctx->h[1], &ctx->buf[ 4]);
+   UNPACK32(ctx->h[2], &ctx->buf[ 8]);
+   UNPACK32(ctx->h[3], &ctx->buf[12]);
+   UNPACK32(ctx->h[4], &ctx->buf[16]);
+   UNPACK32(ctx->h[5], &ctx->buf[20]);
+   UNPACK32(ctx->h[6], &ctx->buf[24]);
+   UNPACK32(ctx->h[7], &ctx->buf[28]);
+#endif /* !UNROLL_LOOPS */
+
+   return ctx->buf;
+}
+
+uint8_t* internal_SHA256(const uint8_t* data, uint64_t len, uint8_t* digest) {
+  const uint8_t* input_ptr;
+  const uint8_t* result;
+  uint64_t remaining_len;
+  int i;
+  SHA256_CTX ctx;
+
+  SHA256_init(&ctx);
+
+  input_ptr = data;
+  remaining_len = len;
+
+  /* Process data in at most UINT32_MAX byte chunks at a time. */
+  while (remaining_len) {
+    uint32_t block_size;
+    block_size = (uint32_t) ((remaining_len >= UINT32_MAX) ?
+                             UINT32_MAX : remaining_len);
+    SHA256_update(&ctx, input_ptr, block_size);
+    remaining_len -= block_size;
+    input_ptr += block_size;
+  }
+
+  result = SHA256_final(&ctx);
+  for (i = 0; i < SHA256_DIGEST_SIZE; ++i) {
+    digest[i] = *result++;
+  }
+  return digest;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/sha512.c tools/vboot_utils/src/firmware/lib/cryptolib/sha512.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/sha512.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/sha512.c	2014-04-27 13:03:45.748116679 +0000
@@ -0,0 +1,365 @@
+/* SHA-256 and SHA-512 implementation based on code by Oliver Gay
+ * <olivier.gay@a3.epfl.ch> under a BSD-style license. See below.
+ */
+
+/*
+ * FIPS 180-2 SHA-224/256/384/512 implementation
+ * Last update: 02/02/2007
+ * Issue date:  04/30/2005
+ *
+ * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "utility.h"
+
+#define SHFR(x, n)    (x >> n)
+#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
+#define ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
+#define CH(x, y, z)  ((x & y) ^ (~x & z))
+#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
+
+#define SHA512_F1(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
+#define SHA512_F2(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))
+#define SHA512_F3(x) (ROTR(x,  1) ^ ROTR(x,  8) ^ SHFR(x,  7))
+#define SHA512_F4(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHFR(x,  6))
+
+#define UNPACK32(x, str)                        \
+  {                                             \
+    *((str) + 3) = (uint8_t) ((x)      );       \
+    *((str) + 2) = (uint8_t) ((x) >>  8);       \
+    *((str) + 1) = (uint8_t) ((x) >> 16);       \
+    *((str) + 0) = (uint8_t) ((x) >> 24);       \
+  }
+
+#define UNPACK64(x, str)                          \
+  {                                               \
+    *((str) + 7) = (uint8_t) x;                   \
+    *((str) + 6) = (uint8_t) ((uint64_t)x >> 8);  \
+    *((str) + 5) = (uint8_t) ((uint64_t)x >> 16); \
+    *((str) + 4) = (uint8_t) ((uint64_t)x >> 24); \
+    *((str) + 3) = (uint8_t) ((uint64_t)x >> 32); \
+    *((str) + 2) = (uint8_t) ((uint64_t)x >> 40); \
+    *((str) + 1) = (uint8_t) ((uint64_t)x >> 48); \
+    *((str) + 0) = (uint8_t) ((uint64_t)x >> 56); \
+  }
+
+#define PACK64(str, x)                          \
+  {                                             \
+    *(x) =   ((uint64_t) *((str) + 7)      )    \
+        | ((uint64_t) *((str) + 6) <<  8)       \
+        | ((uint64_t) *((str) + 5) << 16)       \
+        | ((uint64_t) *((str) + 4) << 24)       \
+        | ((uint64_t) *((str) + 3) << 32)       \
+        | ((uint64_t) *((str) + 2) << 40)       \
+        | ((uint64_t) *((str) + 1) << 48)       \
+        | ((uint64_t) *((str) + 0) << 56);      \
+  }
+
+/* Macros used for loops unrolling */
+
+#define SHA512_SCR(i)                         \
+  {                                           \
+    w[i] =  SHA512_F4(w[i -  2]) + w[i -  7]  \
+        + SHA512_F3(w[i - 15]) + w[i - 16];   \
+  }
+
+#define SHA512_EXP(a, b, c, d, e, f, g ,h, j)               \
+  {                                                         \
+    t1 = wv[h] + SHA512_F2(wv[e]) + CH(wv[e], wv[f], wv[g]) \
+        + sha512_k[j] + w[j];                               \
+    t2 = SHA512_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);       \
+    wv[d] += t1;                                            \
+    wv[h] = t1 + t2;                                        \
+  }
+
+static const uint64_t sha512_h0[8] = {
+  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
+  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
+  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
+  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL};
+
+static const uint64_t sha512_k[80] = {
+  0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
+  0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
+  0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
+  0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
+  0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
+  0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
+  0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
+  0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
+  0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
+  0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
+  0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
+  0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
+  0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
+  0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
+  0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
+  0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
+  0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
+  0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
+  0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
+  0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
+  0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
+  0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
+  0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
+  0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
+  0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
+  0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
+  0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
+  0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
+  0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
+  0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
+  0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
+  0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
+  0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
+  0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
+  0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
+  0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
+  0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
+  0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
+  0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
+  0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL};
+
+
+/* SHA-512 implementation */
+
+void SHA512_init(SHA512_CTX *ctx) {
+#ifdef UNROLL_LOOPS_SHA512
+    ctx->h[0] = sha512_h0[0]; ctx->h[1] = sha512_h0[1];
+    ctx->h[2] = sha512_h0[2]; ctx->h[3] = sha512_h0[3];
+    ctx->h[4] = sha512_h0[4]; ctx->h[5] = sha512_h0[5];
+    ctx->h[6] = sha512_h0[6]; ctx->h[7] = sha512_h0[7];
+#else
+    int i;
+
+    for (i = 0; i < 8; i++)
+        ctx->h[i] = sha512_h0[i];
+#endif /* UNROLL_LOOPS_SHA512 */
+
+    ctx->len = 0;
+    ctx->tot_len = 0;
+}
+
+
+static void SHA512_transform(SHA512_CTX* ctx, const uint8_t* message,
+                             unsigned int block_nb) {
+  uint64_t w[80];
+  uint64_t wv[8];
+  uint64_t t1, t2;
+  const uint8_t *sub_block;
+  int i, j;
+
+  for (i = 0; i < (int) block_nb; i++) {
+    sub_block = message + (i << 7);
+
+#ifdef UNROLL_LOOPS_SHA512
+    PACK64(&sub_block[  0], &w[ 0]); PACK64(&sub_block[  8], &w[ 1]);
+    PACK64(&sub_block[ 16], &w[ 2]); PACK64(&sub_block[ 24], &w[ 3]);
+    PACK64(&sub_block[ 32], &w[ 4]); PACK64(&sub_block[ 40], &w[ 5]);
+    PACK64(&sub_block[ 48], &w[ 6]); PACK64(&sub_block[ 56], &w[ 7]);
+    PACK64(&sub_block[ 64], &w[ 8]); PACK64(&sub_block[ 72], &w[ 9]);
+    PACK64(&sub_block[ 80], &w[10]); PACK64(&sub_block[ 88], &w[11]);
+    PACK64(&sub_block[ 96], &w[12]); PACK64(&sub_block[104], &w[13]);
+    PACK64(&sub_block[112], &w[14]); PACK64(&sub_block[120], &w[15]);
+
+    SHA512_SCR(16); SHA512_SCR(17); SHA512_SCR(18); SHA512_SCR(19);
+    SHA512_SCR(20); SHA512_SCR(21); SHA512_SCR(22); SHA512_SCR(23);
+    SHA512_SCR(24); SHA512_SCR(25); SHA512_SCR(26); SHA512_SCR(27);
+    SHA512_SCR(28); SHA512_SCR(29); SHA512_SCR(30); SHA512_SCR(31);
+    SHA512_SCR(32); SHA512_SCR(33); SHA512_SCR(34); SHA512_SCR(35);
+    SHA512_SCR(36); SHA512_SCR(37); SHA512_SCR(38); SHA512_SCR(39);
+    SHA512_SCR(40); SHA512_SCR(41); SHA512_SCR(42); SHA512_SCR(43);
+    SHA512_SCR(44); SHA512_SCR(45); SHA512_SCR(46); SHA512_SCR(47);
+    SHA512_SCR(48); SHA512_SCR(49); SHA512_SCR(50); SHA512_SCR(51);
+    SHA512_SCR(52); SHA512_SCR(53); SHA512_SCR(54); SHA512_SCR(55);
+    SHA512_SCR(56); SHA512_SCR(57); SHA512_SCR(58); SHA512_SCR(59);
+    SHA512_SCR(60); SHA512_SCR(61); SHA512_SCR(62); SHA512_SCR(63);
+    SHA512_SCR(64); SHA512_SCR(65); SHA512_SCR(66); SHA512_SCR(67);
+    SHA512_SCR(68); SHA512_SCR(69); SHA512_SCR(70); SHA512_SCR(71);
+    SHA512_SCR(72); SHA512_SCR(73); SHA512_SCR(74); SHA512_SCR(75);
+    SHA512_SCR(76); SHA512_SCR(77); SHA512_SCR(78); SHA512_SCR(79);
+
+    wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
+    wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
+    wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
+    wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
+
+    j = 0;
+
+    do {
+      SHA512_EXP(0,1,2,3,4,5,6,7,j); j++;
+      SHA512_EXP(7,0,1,2,3,4,5,6,j); j++;
+      SHA512_EXP(6,7,0,1,2,3,4,5,j); j++;
+      SHA512_EXP(5,6,7,0,1,2,3,4,j); j++;
+      SHA512_EXP(4,5,6,7,0,1,2,3,j); j++;
+      SHA512_EXP(3,4,5,6,7,0,1,2,j); j++;
+      SHA512_EXP(2,3,4,5,6,7,0,1,j); j++;
+      SHA512_EXP(1,2,3,4,5,6,7,0,j); j++;
+    } while (j < 80);
+
+    ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
+    ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
+    ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
+    ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
+#else
+    for (j = 0; j < 16; j++) {
+      PACK64(&sub_block[j << 3], &w[j]);
+    }
+
+    for (j = 16; j < 80; j++) {
+      SHA512_SCR(j);
+    }
+
+    for (j = 0; j < 8; j++) {
+      wv[j] = ctx->h[j];
+    }
+
+    for (j = 0; j < 80; j++) {
+      t1 = wv[7] + SHA512_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
+          + sha512_k[j] + w[j];
+      t2 = SHA512_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
+      wv[7] = wv[6];
+      wv[6] = wv[5];
+      wv[5] = wv[4];
+      wv[4] = wv[3] + t1;
+      wv[3] = wv[2];
+      wv[2] = wv[1];
+      wv[1] = wv[0];
+      wv[0] = t1 + t2;
+    }
+
+    for (j = 0; j < 8; j++)
+      ctx->h[j] += wv[j];
+#endif /* UNROLL_LOOPS_SHA512 */
+  }
+}
+
+
+void SHA512_update(SHA512_CTX* ctx, const uint8_t* data,
+                   uint32_t len) {
+    unsigned int block_nb;
+    unsigned int new_len, rem_len, tmp_len;
+    const uint8_t* shifted_data;
+
+    tmp_len = SHA512_BLOCK_SIZE - ctx->len;
+    rem_len = len < tmp_len ? len : tmp_len;
+
+    Memcpy(&ctx->block[ctx->len], data, rem_len);
+
+    if (ctx->len + len < SHA512_BLOCK_SIZE) {
+        ctx->len += len;
+        return;
+    }
+
+    new_len = len - rem_len;
+    block_nb = new_len / SHA512_BLOCK_SIZE;
+
+    shifted_data = data + rem_len;
+
+    SHA512_transform(ctx, ctx->block, 1);
+    SHA512_transform(ctx, shifted_data, block_nb);
+
+    rem_len = new_len % SHA512_BLOCK_SIZE;
+
+    Memcpy(ctx->block, &shifted_data[block_nb << 7],
+           rem_len);
+
+    ctx->len = rem_len;
+    ctx->tot_len += (block_nb + 1) << 7;
+}
+
+uint8_t* SHA512_final(SHA512_CTX* ctx)
+{
+    unsigned int block_nb;
+    unsigned int pm_len;
+    unsigned int len_b;
+
+#ifndef UNROLL_LOOPS_SHA512
+    int i;
+#endif
+
+    block_nb = 1 + ((SHA512_BLOCK_SIZE - 17)
+                     < (ctx->len % SHA512_BLOCK_SIZE));
+
+    len_b = (ctx->tot_len + ctx->len) << 3;
+    pm_len = block_nb << 7;
+
+    Memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
+    ctx->block[ctx->len] = 0x80;
+    UNPACK32(len_b, ctx->block + pm_len - 4);
+
+    SHA512_transform(ctx, ctx->block, block_nb);
+
+#ifdef UNROLL_LOOPS_SHA512
+    UNPACK64(ctx->h[0], &ctx->buf[ 0]);
+    UNPACK64(ctx->h[1], &ctx->buf[ 8]);
+    UNPACK64(ctx->h[2], &ctx->buf[16]);
+    UNPACK64(ctx->h[3], &ctx->buf[24]);
+    UNPACK64(ctx->h[4], &ctx->buf[32]);
+    UNPACK64(ctx->h[5], &ctx->buf[40]);
+    UNPACK64(ctx->h[6], &ctx->buf[48]);
+    UNPACK64(ctx->h[7], &ctx->buf[56]);
+#else
+    for (i = 0 ; i < 8; i++)
+        UNPACK64(ctx->h[i], &ctx->buf[i << 3]);
+#endif /* UNROLL_LOOPS_SHA512 */
+
+    return ctx->buf;
+}
+
+
+uint8_t* internal_SHA512(const uint8_t* data, uint64_t len, uint8_t* digest) {
+  const uint8_t* input_ptr;
+  const uint8_t* result;
+  uint64_t remaining_len;
+  int i;
+  SHA512_CTX ctx;
+  SHA512_init(&ctx);
+
+  input_ptr = data;
+  remaining_len = len;
+
+  /* Process data in at most UINT32_MAX byte chunks at a time. */
+  while (remaining_len) {
+    uint32_t block_size;
+    block_size = (uint32_t) ((remaining_len >= UINT32_MAX) ?
+                             UINT32_MAX : remaining_len);
+       SHA512_update(&ctx, input_ptr, block_size);
+    remaining_len -= block_size;
+    input_ptr += block_size;
+  }
+
+  result = SHA512_final(&ctx);
+  for (i = 0; i < SHA512_DIGEST_SIZE; ++i) {
+    digest[i] = *result++;
+  }
+  return digest;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/cryptolib/sha_utility.c tools/vboot_utils/src/firmware/lib/cryptolib/sha_utility.c
--- tools-org/vboot_utils/src/firmware/lib/cryptolib/sha_utility.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/cryptolib/sha_utility.c	2014-04-27 13:03:45.752116954 +0000
@@ -0,0 +1,118 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Utility functions for message digest functions.
+ */
+
+#include "sysincludes.h"
+
+#include "cryptolib.h"
+#include "utility.h"
+#include "vboot_api.h"
+
+void DigestInit(DigestContext* ctx, int sig_algorithm) {
+  ctx->algorithm = hash_type_map[sig_algorithm];
+  switch(ctx->algorithm) {
+#ifndef CHROMEOS_EC
+    case SHA1_DIGEST_ALGORITHM:
+      ctx->sha1_ctx = (SHA1_CTX*) VbExMalloc(sizeof(SHA1_CTX));
+      SHA1_init(ctx->sha1_ctx);
+      break;
+#endif
+    case SHA256_DIGEST_ALGORITHM:
+      ctx->sha256_ctx = (SHA256_CTX*) VbExMalloc(sizeof(SHA256_CTX));
+      SHA256_init(ctx->sha256_ctx);
+      break;
+#ifndef CHROMEOS_EC
+    case SHA512_DIGEST_ALGORITHM:
+      ctx->sha512_ctx = (SHA512_CTX*) VbExMalloc(sizeof(SHA512_CTX));
+      SHA512_init(ctx->sha512_ctx);
+      break;
+#endif
+  };
+}
+
+void DigestUpdate(DigestContext* ctx, const uint8_t* data, uint32_t len) {
+  switch(ctx->algorithm) {
+#ifndef CHROMEOS_EC
+    case SHA1_DIGEST_ALGORITHM:
+      SHA1_update(ctx->sha1_ctx, data, len);
+      break;
+#endif
+    case SHA256_DIGEST_ALGORITHM:
+      SHA256_update(ctx->sha256_ctx, data, len);
+      break;
+#ifndef CHROMEOS_EC
+    case SHA512_DIGEST_ALGORITHM:
+      SHA512_update(ctx->sha512_ctx, data, len);
+      break;
+#endif
+  };
+}
+
+uint8_t* DigestFinal(DigestContext* ctx) {
+  uint8_t* digest = NULL;
+  switch(ctx->algorithm) {
+#ifndef CHROMEOS_EC
+    case SHA1_DIGEST_ALGORITHM:
+      digest = (uint8_t*) VbExMalloc(SHA1_DIGEST_SIZE);
+      Memcpy(digest, SHA1_final(ctx->sha1_ctx), SHA1_DIGEST_SIZE);
+      VbExFree(ctx->sha1_ctx);
+      break;
+#endif
+    case SHA256_DIGEST_ALGORITHM:
+      digest = (uint8_t*) VbExMalloc(SHA256_DIGEST_SIZE);
+      Memcpy(digest, SHA256_final(ctx->sha256_ctx), SHA256_DIGEST_SIZE);
+      VbExFree(ctx->sha256_ctx);
+      break;
+#ifndef CHROMEOS_EC
+    case SHA512_DIGEST_ALGORITHM:
+      digest = (uint8_t*) VbExMalloc(SHA512_DIGEST_SIZE);
+      Memcpy(digest, SHA512_final(ctx->sha512_ctx), SHA512_DIGEST_SIZE);
+      VbExFree(ctx->sha512_ctx);
+      break;
+#endif
+  };
+  return digest;
+}
+
+uint8_t* DigestBuf(const uint8_t* buf, uint64_t len, int sig_algorithm) {
+  /* Allocate enough space for the largest digest */
+  uint8_t* digest = (uint8_t*) VbExMalloc(SHA512_DIGEST_SIZE);
+  /* Define an array mapping [sig_algorithm] to function pointers to the
+   * SHA{1|256|512} functions.
+   */
+  typedef uint8_t* (*Hash_ptr) (const uint8_t*, uint64_t, uint8_t*);
+  Hash_ptr hash[] = {
+#ifdef CHROMEOS_EC
+    0,  /* RSA 1024 */
+    0,
+    0,
+    0,  /* RSA 2048 */
+    0,
+    0,
+    0,  /* RSA 4096 */
+    internal_SHA256,
+    0,
+    0,  /* RSA 8192 */
+    0,
+    0,
+#else
+    internal_SHA1,  /* RSA 1024 */
+    internal_SHA256,
+    internal_SHA512,
+    internal_SHA1,  /* RSA 2048 */
+    internal_SHA256,
+    internal_SHA512,
+    internal_SHA1,  /* RSA 4096 */
+    internal_SHA256,
+    internal_SHA512,
+    internal_SHA1,  /* RSA 8192 */
+    internal_SHA256,
+    internal_SHA512,
+#endif
+  };
+  /* Call the appropriate hash function. */
+  return hash[sig_algorithm](buf, len, digest);
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/crc8.h tools/vboot_utils/src/firmware/lib/include/crc8.h
--- tools-org/vboot_utils/src/firmware/lib/include/crc8.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/crc8.h	2014-04-27 13:03:45.752116954 +0000
@@ -0,0 +1,13 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Very simple 8-bit CRC function.
+ */
+#ifndef VBOOT_REFERENCE_CRC8_H_
+#define VBOOT_REFERENCE_CRC8_H_
+#include "sysincludes.h"
+
+uint8_t Crc8(const void *data, int len);
+
+#endif /* VBOOT_REFERENCE_CRC8_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/rollback_index.h tools/vboot_utils/src/firmware/lib/include/rollback_index.h
--- tools-org/vboot_utils/src/firmware/lib/include/rollback_index.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/rollback_index.h	2014-04-27 13:03:45.752116954 +0000
@@ -0,0 +1,172 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Functions for querying, manipulating and locking rollback indices
+ * stored in the TPM NVRAM.
+ */
+
+#ifndef VBOOT_REFERENCE_ROLLBACK_INDEX_H_
+#define VBOOT_REFERENCE_ROLLBACK_INDEX_H_
+
+#include "sysincludes.h"
+#include "tss_constants.h"
+
+/* TPM NVRAM location indices. */
+#define FIRMWARE_NV_INDEX               0x1007
+#define KERNEL_NV_INDEX                 0x1008
+
+/* Structure definitions for TPM spaces */
+
+/* Kernel space - KERNEL_NV_INDEX, locked with physical presence. */
+#define ROLLBACK_SPACE_KERNEL_VERSION 2
+#define ROLLBACK_SPACE_KERNEL_UID 0x4752574C  /* 'GRWL' */
+
+typedef struct RollbackSpaceKernel {
+	/* Struct version, for backwards compatibility */
+	uint8_t struct_version;
+	/* Unique ID to detect space redefinition */
+	uint32_t uid;
+	/* Kernel versions */
+	uint32_t kernel_versions;
+	/* Reserved for future expansion */
+	uint8_t reserved[3];
+	/* Checksum (v2 and later only) */
+	uint8_t crc8;
+} __attribute__((packed)) RollbackSpaceKernel;
+
+/* Flags for firmware space */
+/*
+ * Last boot was developer mode.  TPM ownership is cleared when transitioning
+ * to/from developer mode.
+ */
+#define FLAG_LAST_BOOT_DEVELOPER 0x01
+/*
+ * Some systems may not have a dedicated dev-mode switch, but enter and leave
+ * dev-mode through some recovery-mode magic keypresses. For those systems, the
+ * dev-mode "switch" state is in this bit (0=normal, 1=dev). To make it work, a
+ * new flag is passed to VbInit(), indicating that the system lacks a physical
+ * dev-mode switch. If a physical switch is present, this bit is ignored.
+ */
+#define FLAG_VIRTUAL_DEV_MODE_ON 0x02
+
+/* Firmware space - FIRMWARE_NV_INDEX, locked with global lock. */
+#define ROLLBACK_SPACE_FIRMWARE_VERSION 2
+
+typedef struct RollbackSpaceFirmware {
+	/* Struct version, for backwards compatibility */
+	uint8_t struct_version;
+	/* Flags (see FLAG_* above) */
+	uint8_t flags;
+	/* Firmware versions */
+	uint32_t fw_versions;
+	/* Reserved for future expansion */
+	uint8_t reserved[3];
+	/* Checksum (v2 and later only) */
+	uint8_t crc8;
+} __attribute__((packed)) RollbackSpaceFirmware;
+
+/* All functions return TPM_SUCCESS (zero) if successful, non-zero if error */
+
+/*
+ * These functions are called from VbInit().  They cannot use global
+ * variables.
+ */
+
+uint32_t RollbackS3Resume(void);
+
+/*
+ * These functions are callable from VbSelectFirmware().  They cannot use
+ * global variables.
+ */
+
+/**
+ * This must be called.
+ */
+uint32_t RollbackFirmwareSetup(int is_hw_dev,
+                               int disable_dev_request,
+                               int clear_tpm_owner_request,
+                               /* two outputs on success */
+                               int *is_virt_dev, uint32_t *tpm_version);
+
+/**
+ * Write may be called if the versions change.
+ */
+uint32_t RollbackFirmwareWrite(uint32_t version);
+
+/**
+ * Lock must be called.
+ */
+uint32_t RollbackFirmwareLock(void);
+
+/*
+ * These functions are callable from VbSelectAndLoadKernel().  They may use
+ * global variables.
+ */
+
+/**
+ * Read stored kernel version.
+ */
+uint32_t RollbackKernelRead(uint32_t *version);
+
+/**
+ * Write stored kernel version.
+ */
+uint32_t RollbackKernelWrite(uint32_t version);
+
+/**
+ * Lock must be called.  Internally, it's ignored in recovery mode.
+ */
+uint32_t RollbackKernelLock(int recovery_mode);
+
+/****************************************************************************/
+
+/*
+ * The following functions are internal apis, listed here for use by unit tests
+ * only.
+ */
+
+/**
+ * Issue a TPM_Clear and reenable/reactivate the TPM.
+ */
+uint32_t TPMClearAndReenable(void);
+
+/**
+ * Like TlclWrite(), but checks for write errors due to hitting the 64-write
+ * limit and clears the TPM when that happens.  This can only happen when the
+ * TPM is unowned, so it is OK to clear it (and we really have no choice).
+ * This is not expected to happen frequently, but it could happen.
+ */
+uint32_t SafeWrite(uint32_t index, const void *data, uint32_t length);
+
+/**
+ * Similarly to SafeWrite(), this ensures we don't fail a DefineSpace because
+ * we hit the TPM write limit.  This is even less likely to happen than with
+ * writes because we only define spaces once at initialization, but we'd rather
+ * be paranoid about this.
+ */
+uint32_t SafeDefineSpace(uint32_t index, uint32_t perm, uint32_t size);
+
+/**
+ * Perform one-time initializations.
+ *
+ * Create the NVRAM spaces, and set their initial values as needed.  Sets the
+ * nvLocked bit and ensures the physical presence command is enabled and
+ * locked.
+ */
+uint32_t OneTimeInitializeTPM(RollbackSpaceFirmware *rsf,
+                              RollbackSpaceKernel *rsk);
+
+/**
+ * Start the TPM and establish the root of trust for the anti-rollback
+ * mechanism.
+ */
+uint32_t SetupTPM(int developer_mode, int disable_dev_request,
+                  int clear_tpm_owner_request, RollbackSpaceFirmware *rsf);
+
+/**
+ * Utility function to turn the virtual dev-mode flag on or off. 0=off, 1=on.
+ */
+uint32_t SetVirtualDevMode(int val);
+
+#endif  /* VBOOT_REFERENCE_ROLLBACK_INDEX_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/stateful_util.h tools/vboot_utils/src/firmware/lib/include/stateful_util.h
--- tools-org/vboot_utils/src/firmware/lib/include/stateful_util.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/stateful_util.h	2014-04-27 13:03:45.756117228 +0000
@@ -0,0 +1,76 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/*
+ * Helper functions/wrappers for memory allocations, manipulation and
+ * comparison.
+ */
+
+#ifndef VBOOT_FIRMWARE_LIB_STATEFUL_UTIL_H_
+#define VBOOT_FIRMWARE_LIB_STATEFUL_UTIL_H_
+
+#include "sysincludes.h"
+
+/* Track remaining data to be read in a buffer. */
+typedef struct MemcpyState {
+	uint8_t *remaining_buf;
+	uint64_t remaining_len;  /* Remaining length of the buffer. */
+	uint8_t overrun;  /* Flag set to 1 when an overrun occurs. */
+} MemcpyState;
+
+/**
+ * Initialize a stateful buffer struct to point to the buffer, with the
+ * specified remaining length in bytes.
+ */
+void StatefulInit(MemcpyState *state, void *buf, uint64_t len);
+
+/**
+ * Skip [len] bytes only if there's enough data to skip according to [state].
+ *
+ * On success, return a meaningless but non-NULL pointer and updates [state].
+ * On failure, return NULL, set state->overrun to 1.
+ *
+ * Useful for iterating through a binary blob to populate a struct. After the
+ * first failure (buffer overrun), successive calls will always fail.
+ */
+void *StatefulSkip(MemcpyState *state, uint64_t len);
+
+/**
+ * Copy [len] bytes into [dst] only if there's enough data to read according
+ * to [state].
+ *
+ * On success, return [dst] and update [state].
+ * On failure, return NULL, set state->overrun to 1.
+ *
+ * Useful for iterating through a binary blob to populate a struct. After the
+ * first failure (buffer overrun), successive calls will always fail.
+ */
+void *StatefulMemcpy(MemcpyState *state, void *dst, uint64_t len);
+
+/**
+ * Like StatefulMemcpy() but copies in the opposite direction, populating
+ * data from [src] into the buffer encapsulated in state [state].
+ *
+ * On success, return [src] and update [state].
+ * On failure, return NULL, set state->overrun to 1.
+ *
+ * Useful for iterating through a structure to populate a binary blob. After the
+ * first failure (buffer overrun), successive calls will always fail.
+ */
+const void *StatefulMemcpy_r(MemcpyState *state, const void *src, uint64_t len);
+
+/**
+ * Like StatefulMemcpy_r() but fills a portion of the encapsulated buffer with
+ * a constant value.
+ *
+ * On success, return a meaningless but non-NULL pointer and updates [state].
+ * On failure, return NULL, set state->overrun to 1.
+ *
+ * After the first failure (buffer overrun), successive calls will always fail.
+ */
+const void *StatefulMemset_r(MemcpyState *state, const uint8_t val,
+                             uint64_t len);
+
+#endif
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/sysincludes.h tools/vboot_utils/src/firmware/lib/include/sysincludes.h
--- tools-org/vboot_utils/src/firmware/lib/include/sysincludes.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/sysincludes.h	2014-04-27 13:03:45.756117228 +0000
@@ -0,0 +1,28 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/* System includes for vboot reference library.  This is the ONLY
+ * place in firmware/ where system headers may be included via
+ * #include <...>, so that there's only one place that needs to be
+ * fixed up for platforms which don't have all the system includes.
+ *
+ * Files in firmware/stub may still include system headers, because
+ * they're local implementations and will be ported to each system
+ * anyway. */
+
+#ifndef VBOOT_REFERENCE_SYSINCLUDES_H_
+#define VBOOT_REFERENCE_SYSINCLUDES_H_
+
+#include <inttypes.h>  /* For PRIu64 */
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#if defined(HAVE_ENDIAN_H) && defined(HAVE_LITTLE_ENDIAN)
+#include <byteswap.h>
+#include <memory.h>
+#endif
+
+#endif  /* VBOOT_REFERENCE_SYSINCLUDES_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/utility.h tools/vboot_utils/src/firmware/lib/include/utility.h
--- tools-org/vboot_utils/src/firmware/lib/include/utility.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/utility.h	2014-04-27 13:03:45.756117228 +0000
@@ -0,0 +1,115 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/*
+ * Helper functions/wrappers for memory allocations, manipulation and
+ * comparison.
+ */
+
+#ifndef VBOOT_REFERENCE_UTILITY_H_
+#define VBOOT_REFERENCE_UTILITY_H_
+
+#include "sysincludes.h"
+
+/* Debug and error output */
+#ifdef VBOOT_DEBUG
+#define VBDEBUG(params) VbExDebug params
+#else
+#define VBDEBUG(params)
+#endif
+
+#ifdef VBOOT_DEBUG
+#define VbAssert(expr) do { if (!(expr)) { \
+    printf("assert fail: %s at %s:%d\n", \
+              #expr, __FILE__, __LINE__); }} while(0)
+#else
+#define VbAssert(expr)
+#endif
+
+/* Optional, up to the BIOS */
+#ifdef VBOOT_EASTER_EGG
+#define VBEASTEREGG VbExEasterEgg()
+#else
+#define VBEASTEREGG 0
+#endif
+
+/*
+ * Combine [msw] and [lsw] uint16s to a uint32_t with its [msw] and [lsw]
+ * forming the most and least signficant 16-bit words.
+ */
+#define CombineUint16Pair(msw,lsw) (((uint32_t)(msw) << 16) |   \
+                                    (((lsw)) & 0xFFFF))
+
+/* Return the minimum of (a) or (b). */
+#define Min(a, b) (((a) < (b)) ? (a) : (b))
+
+/**
+ * Compare [n] bytes in [src1] and [src2].
+ *
+ * Returns an integer less than, equal to, or greater than zero if the first
+ * [n] bytes of [src1] is found, respectively, to be less than, to match, or be
+ * greater than the first n bytes of [src2]. */
+int Memcmp(const void *src1, const void *src2, size_t n);
+
+/**
+ * Copy [n] bytes from [src] to [dest].
+ */
+void *Memcpy(void *dest, const void *src, uint64_t n);
+
+/*
+ * Implementations of the functions below must be built as part of the firmware
+ * and defined in lib/utility.c.
+ */
+
+/**
+ * Set [n] bytes starting at [s] to [c].  Returns dest.
+ */
+void *Memset(void *dest, const uint8_t c, uint64_t n);
+
+/**
+ * Compare [n] bytes starting at [s1] with [s2] and return 0 if they
+ * match, 1 if they don't.  Returns 0 if n=0, since no bytes mismatched.
+ *
+ * Time taken to perform the comparison is only dependent on [n] and
+ * not on the relationship of the match between [s1] and [s2].
+ *
+ * Note that unlike Memcmp(), this only indicates inequality, not
+ * whether s1 is less than or greater than s2.
+ */
+int SafeMemcmp(const void *s1, const void *s2, size_t n);
+
+/*
+ * Buffer size required to hold the longest possible output of Uint64ToString()
+ * - that is, Uint64ToString(~0, 2).
+ */
+#define UINT64_TO_STRING_MAX 65
+
+/**
+ * Convert a value to a string in the specified radix (2=binary, 10=decimal,
+ * 16=hex) and store it in <buf>, which is <bufsize> chars long.  If
+ * <zero_pad_width>, left-pads the string to at least that width with '0'.
+ * Returns the length of the stored string, not counting the terminating null.
+ */
+uint32_t Uint64ToString(char *buf, uint32_t bufsize, uint64_t value,
+                        uint32_t radix, uint32_t zero_pad_width);
+
+/**
+ * Concatenate <src> onto <dest>, which has space for <destlen> characters
+ * including the terminating null.  Note that <dest> will always be
+ * null-terminated if <destlen> > 0.  Returns the number of characters used in
+ * <dest>, not counting the terminating null.
+ */
+uint32_t StrnAppend(char *dest, const char *src, uint32_t destlen);
+
+/* Ensure that only our stub implementations are used, not standard C */
+#ifndef _STUB_IMPLEMENTATION_
+#define malloc _do_not_use_standard_malloc
+#define free _do_not_use_standard_free
+#define memcmp _do_not_use_standard_memcmp
+#define memcpy _do_not_use_standard_memcpy
+#define memset _do_not_use_standard_memset
+#endif
+
+#endif  /* VBOOT_REFERENCE_UTILITY_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/include/vboot_common.h tools/vboot_utils/src/firmware/lib/include/vboot_common.h
--- tools-org/vboot_utils/src/firmware/lib/include/vboot_common.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/include/vboot_common.h	2014-04-27 13:03:45.756117228 +0000
@@ -0,0 +1,163 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Common functions between firmware and kernel verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_VBOOT_COMMON_H_
+#define VBOOT_REFERENCE_VBOOT_COMMON_H_
+
+#include "cryptolib.h"
+#include "vboot_struct.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(array) (sizeof(array)/sizeof(array[0]))
+#endif
+
+/* Error Codes for all common functions. */
+enum {
+	VBOOT_SUCCESS = 0,
+	/* Key block internal structure is invalid, or not a key block */
+	VBOOT_KEY_BLOCK_INVALID,
+	/* Key block signature check failed */
+	VBOOT_KEY_BLOCK_SIGNATURE,
+	/* Key block hash check failed */
+	VBOOT_KEY_BLOCK_HASH,
+	/* Invalid public key passed to a signature verficiation function. */
+	VBOOT_PUBLIC_KEY_INVALID,
+	/* Preamble internal structure is invalid */
+	VBOOT_PREAMBLE_INVALID,
+	/* Preamble signature check failed */
+	VBOOT_PREAMBLE_SIGNATURE,
+	/* Shared data is invalid. */
+	VBOOT_SHARED_DATA_INVALID,
+	VBOOT_ERROR_MAX,
+};
+extern const char *kVbootErrors[VBOOT_ERROR_MAX];
+
+/**
+ * Return offset of ptr from base.
+ */
+uint64_t OffsetOf(const void *base, const void *ptr);
+
+/*
+ * Helper functions to get data pointed to by a public key or signature.
+ */
+
+uint8_t *GetPublicKeyData(VbPublicKey *key);
+const uint8_t *GetPublicKeyDataC(const VbPublicKey *key);
+uint8_t *GetSignatureData(VbSignature *sig);
+const uint8_t *GetSignatureDataC(const VbSignature *sig);
+
+/*
+ * Helper functions to verify the data pointed to by a subfield is inside the
+ * parent data.  Returns 0 if inside, 1 if error.
+ */
+
+int VerifyMemberInside(const void *parent, uint64_t parent_size,
+		       const void *member, uint64_t member_size,
+		       uint64_t member_data_offset,
+		       uint64_t member_data_size);
+
+int VerifyPublicKeyInside(const void *parent, uint64_t parent_size,
+			  const VbPublicKey *key);
+
+int VerifySignatureInside(const void *parent, uint64_t parent_size,
+			  const VbSignature *sig);
+
+/**
+ * Initialize a public key to refer to [key_data].
+ */
+void PublicKeyInit(VbPublicKey *key, uint8_t *key_data, uint64_t key_size);
+
+/**
+ * Copy a public key from [src] to [dest].
+ *
+ * Returns 0 if success, non-zero if error.
+ */
+int PublicKeyCopy(VbPublicKey *dest, const VbPublicKey *src);
+
+/**
+ * Convert a public key to RsaPublicKey format.  The returned key must be freed
+ * using RSAPublicKeyFree().
+ *
+ * Returns NULL if error.
+ */
+RSAPublicKey *PublicKeyToRSA(const VbPublicKey *key);
+
+/**
+ * Verify [data] matches signature [sig] using [key].  [size] is the size of
+ * the data buffer; the amount of data to be validated is contained in
+ * sig->data_size.
+ */
+int VerifyData(const uint8_t *data, uint64_t size, const VbSignature *sig,
+	       const RSAPublicKey *key);
+
+/**
+ * Verify a secure hash digest from DigestBuf() or DigestFinal(), using
+ * [key]. Returns 0 on success.
+ */
+int VerifyDigest(const uint8_t *digest, const VbSignature *sig,
+		 const RSAPublicKey *key);
+
+/**
+ * Check the sanity of a key block of size [size] bytes, using public key
+ * [key].  If hash_only is non-zero, uses only the block checksum to verify the
+ * key block.  Header fields are also checked for sanity.  Does not verify key
+ * index or key block flags.
+ */
+int KeyBlockVerify(const VbKeyBlockHeader *block, uint64_t size,
+		   const VbPublicKey *key, int hash_only);
+
+
+/**
+ * Check the sanity of a firmware preamble of size [size] bytes, using public
+ * key [key].
+ *
+ * Returns VBOOT_SUCCESS if successful.
+ */
+int VerifyFirmwarePreamble(const VbFirmwarePreambleHeader *preamble,
+			   uint64_t size, const RSAPublicKey *key);
+
+
+/**
+ * Return the flags from a firmware preamble, or a default value for older
+ * preamble versions which didn't contain flags.  Use this function to ensure
+ * compatibility with older preamble versions (2.0).  Assumes the preamble has
+ * already been verified via VerifyFirmwarePreamble().
+ */
+uint32_t VbGetFirmwarePreambleFlags(const VbFirmwarePreambleHeader *preamble);
+
+/**
+ * Check the sanity of a kernel preamble of size [size] bytes, using public key
+ * [key].
+ *
+ * Returns VBOOT_SUCCESS if successful.
+ */
+int VerifyKernelPreamble(const VbKernelPreambleHeader *preamble,
+			 uint64_t size, const RSAPublicKey *key);
+
+
+/**
+ * Initialize a verified boot shared data structure.
+ *
+ * Returns 0 if success, non-zero if error.
+ */
+int VbSharedDataInit(VbSharedDataHeader *header, uint64_t size);
+
+/**
+ * Reserve [size] bytes of the shared data area.  Returns the offset of the
+ * reserved data from the start of the shared data buffer, or 0 if error.
+ */
+uint64_t VbSharedDataReserve(VbSharedDataHeader *header, uint64_t size);
+
+/**
+ * Copy the kernel subkey into the shared data.
+ *
+ * Returns 0 if success, non-zero if error.
+ */
+int VbSharedDataSetKernelKey(VbSharedDataHeader *header,
+                             const VbPublicKey *src);
+
+#endif  /* VBOOT_REFERENCE_VBOOT_COMMON_H_ */
diff -Nur tools-org/vboot_utils/src/firmware/lib/rollback_index.c tools/vboot_utils/src/firmware/lib/rollback_index.c
--- tools-org/vboot_utils/src/firmware/lib/rollback_index.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/rollback_index.c	2014-04-27 13:03:45.760117503 +0000
@@ -0,0 +1,636 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Functions for querying, manipulating and locking rollback indices
+ * stored in the TPM NVRAM.
+ */
+
+#include "sysincludes.h"
+
+#include "crc8.h"
+#include "rollback_index.h"
+#include "tlcl.h"
+#include "tss_constants.h"
+#include "utility.h"
+#include "vboot_api.h"
+
+#ifndef offsetof
+#define offsetof(A,B) __builtin_offsetof(A,B)
+#endif
+
+/*
+ * Provide protoypes for functions not in the header file. These prototypes
+ * fix -Wmissing-prototypes warnings.
+ */
+uint32_t ReadSpaceFirmware(RollbackSpaceFirmware *rsf);
+uint32_t WriteSpaceFirmware(RollbackSpaceFirmware *rsf);
+uint32_t ReadSpaceKernel(RollbackSpaceKernel *rsk);
+uint32_t WriteSpaceKernel(RollbackSpaceKernel *rsk);
+
+#ifdef FOR_TEST
+/*
+ * Compiling for unit test, so we need the real implementations of
+ * rollback functions.  The unit test mocks the underlying tlcl
+ * functions, so this is ok to run on the host.
+ */
+#undef CHROMEOS_ENVIRONMENT
+#undef DISABLE_ROLLBACK_TPM
+#endif
+
+#define RETURN_ON_FAILURE(tpm_command) do {				\
+		uint32_t result_;					\
+		if ((result_ = (tpm_command)) != TPM_SUCCESS) {		\
+			VBDEBUG(("Rollback: %08x returned by " #tpm_command \
+				 "\n", (int)result_));			\
+			return result_;					\
+		}							\
+	} while (0)
+
+
+uint32_t TPMClearAndReenable(void)
+{
+	VBDEBUG(("TPM: Clear and re-enable\n"));
+	RETURN_ON_FAILURE(TlclForceClear());
+	RETURN_ON_FAILURE(TlclSetEnable());
+	RETURN_ON_FAILURE(TlclSetDeactivated(0));
+
+	return TPM_SUCCESS;
+}
+
+uint32_t SafeWrite(uint32_t index, const void *data, uint32_t length)
+{
+	uint32_t result = TlclWrite(index, data, length);
+	if (result == TPM_E_MAXNVWRITES) {
+		RETURN_ON_FAILURE(TPMClearAndReenable());
+		return TlclWrite(index, data, length);
+	} else {
+		return result;
+	}
+}
+
+uint32_t SafeDefineSpace(uint32_t index, uint32_t perm, uint32_t size)
+{
+	uint32_t result = TlclDefineSpace(index, perm, size);
+	if (result == TPM_E_MAXNVWRITES) {
+		RETURN_ON_FAILURE(TPMClearAndReenable());
+		return TlclDefineSpace(index, perm, size);
+	} else {
+		return result;
+	}
+}
+
+/* Functions to read and write firmware and kernel spaces. */
+uint32_t ReadSpaceFirmware(RollbackSpaceFirmware *rsf)
+{
+	uint32_t r;
+	int attempts = 3;
+
+	while (attempts--) {
+		r = TlclRead(FIRMWARE_NV_INDEX, rsf,
+			     sizeof(RollbackSpaceFirmware));
+		if (r != TPM_SUCCESS)
+			return r;
+
+		/*
+		 * No CRC in this version, so we'll create one when we write
+		 * it. Note that we're marking this as version 2, not
+		 * ROLLBACK_SPACE_FIRMWARE_VERSION, because version 2 just
+		 * added the CRC. Later versions will need to set default
+		 * values for any extra fields explicitly (probably here).
+		 */
+		if (rsf->struct_version < 2) {
+			/* Danger Will Robinson! Danger! */
+			rsf->struct_version = 2;
+			return TPM_SUCCESS;
+		}
+
+		/*
+		 * If the CRC is good, we're done. If it's bad, try a couple
+		 * more times to see if it gets better before we give up. It
+		 * could just be noise.
+		 */
+		if (rsf->crc8 == Crc8(rsf,
+				      offsetof(RollbackSpaceFirmware, crc8)))
+			return TPM_SUCCESS;
+
+		VBDEBUG(("TPM: %s() - bad CRC\n", __func__));
+	}
+
+	VBDEBUG(("TPM: %s() - too many bad CRCs, giving up\n", __func__));
+	return TPM_E_CORRUPTED_STATE;
+}
+
+uint32_t WriteSpaceFirmware(RollbackSpaceFirmware *rsf)
+{
+	RollbackSpaceFirmware rsf2;
+	uint32_t r;
+	int attempts = 3;
+
+	/* All writes should use struct_version 2 or greater. */
+	if (rsf->struct_version < 2)
+		rsf->struct_version = 2;
+	rsf->crc8 = Crc8(rsf, offsetof(RollbackSpaceFirmware, crc8));
+
+	while (attempts--) {
+		r = SafeWrite(FIRMWARE_NV_INDEX, rsf,
+			      sizeof(RollbackSpaceFirmware));
+		/* Can't write, not gonna try again */
+		if (r != TPM_SUCCESS)
+			return r;
+
+		/* Read it back to be sure it got the right values. */
+		r = ReadSpaceFirmware(&rsf2);    /* This checks the CRC */
+		if (r == TPM_SUCCESS)
+			return r;
+
+		VBDEBUG(("TPM: %s() - bad CRC\n", __func__));
+		/* Try writing it again. Maybe it was garbled on the way out. */
+	}
+
+	VBDEBUG(("TPM: %s() - too many bad CRCs, giving up\n", __func__));
+	return TPM_E_CORRUPTED_STATE;
+}
+
+uint32_t SetVirtualDevMode(int val)
+{
+	RollbackSpaceFirmware rsf;
+
+	VBDEBUG(("TPM: Entering %s()\n", __func__));
+	if (TPM_SUCCESS != ReadSpaceFirmware(&rsf))
+		return VBERROR_TPM_FIRMWARE_SETUP;
+
+	VBDEBUG(("TPM: flags were 0x%02x\n", rsf.flags));
+	if (val)
+		rsf.flags |= FLAG_VIRTUAL_DEV_MODE_ON;
+	else
+		rsf.flags &= ~FLAG_VIRTUAL_DEV_MODE_ON;
+	/*
+	 * NOTE: This doesn't update the FLAG_LAST_BOOT_DEVELOPER bit.  That
+	 * will be done by SetupTPM() on the next boot.
+	 */
+	VBDEBUG(("TPM: flags are now 0x%02x\n", rsf.flags));
+
+	if (TPM_SUCCESS != WriteSpaceFirmware(&rsf))
+		return VBERROR_TPM_SET_BOOT_MODE_STATE;
+
+	VBDEBUG(("TPM: Leaving %s()\n", __func__));
+	return VBERROR_SUCCESS;
+}
+
+uint32_t ReadSpaceKernel(RollbackSpaceKernel *rsk)
+{
+	uint32_t r;
+	int attempts = 3;
+
+	while (attempts--) {
+		r = TlclRead(KERNEL_NV_INDEX, rsk, sizeof(RollbackSpaceKernel));
+		if (r != TPM_SUCCESS)
+			return r;
+
+		/*
+		 * No CRC in this version, so we'll create one when we write
+		 * it. Note that we're marking this as version 2, not
+		 * ROLLBACK_SPACE_KERNEL_VERSION, because version 2 just added
+		 * the CRC. Later versions will need to set default values for
+		 * any extra fields explicitly (probably here).
+		 */
+		if (rsk->struct_version < 2) {
+			/* Danger Will Robinson! Danger! */
+			rsk->struct_version = 2;
+			return TPM_SUCCESS;
+		}
+
+		/*
+		 * If the CRC is good, we're done. If it's bad, try a couple
+		 * more times to see if it gets better before we give up. It
+		 * could just be noise.
+		 */
+		if (rsk->crc8 == Crc8(rsk, offsetof(RollbackSpaceKernel, crc8)))
+			return TPM_SUCCESS;
+
+		VBDEBUG(("TPM: %s() - bad CRC\n", __func__));
+	}
+
+	VBDEBUG(("TPM: %s() - too many bad CRCs, giving up\n", __func__));
+	return TPM_E_CORRUPTED_STATE;
+}
+
+uint32_t WriteSpaceKernel(RollbackSpaceKernel *rsk)
+{
+	RollbackSpaceKernel rsk2;
+	uint32_t r;
+	int attempts = 3;
+
+	/* All writes should use struct_version 2 or greater. */
+	if (rsk->struct_version < 2)
+		rsk->struct_version = 2;
+	rsk->crc8 = Crc8(rsk, offsetof(RollbackSpaceKernel, crc8));
+
+	while (attempts--) {
+		r = SafeWrite(KERNEL_NV_INDEX, rsk,
+			      sizeof(RollbackSpaceKernel));
+		/* Can't write, not gonna try again */
+		if (r != TPM_SUCCESS)
+			return r;
+
+		/* Read it back to be sure it got the right values. */
+		r = ReadSpaceKernel(&rsk2);    /* This checks the CRC */
+		if (r == TPM_SUCCESS)
+			return r;
+
+		VBDEBUG(("TPM: %s() - bad CRC\n", __func__));
+		/* Try writing it again. Maybe it was garbled on the way out. */
+	}
+
+	VBDEBUG(("TPM: %s() - too many bad CRCs, giving up\n", __func__));
+	return TPM_E_CORRUPTED_STATE;
+}
+
+uint32_t OneTimeInitializeTPM(RollbackSpaceFirmware *rsf,
+                              RollbackSpaceKernel *rsk)
+{
+	static const RollbackSpaceFirmware rsf_init = {
+		.struct_version = ROLLBACK_SPACE_FIRMWARE_VERSION,
+	};
+	static const RollbackSpaceKernel rsk_init = {
+		.struct_version = ROLLBACK_SPACE_KERNEL_VERSION,
+		.uid = ROLLBACK_SPACE_KERNEL_UID,
+	};
+	TPM_PERMANENT_FLAGS pflags;
+	uint32_t result;
+
+	VBDEBUG(("TPM: One-time initialization\n"));
+
+	/*
+	 * Do a full test.  This only happens the first time the device is
+	 * turned on in the factory, so performance is not an issue.  This is
+	 * almost certainly not necessary, but it gives us more confidence
+	 * about some code paths below that are difficult to
+	 * test---specifically the ones that set lifetime flags, and are only
+	 * executed once per physical TPM.
+	 */
+	result = TlclSelfTestFull();
+	if (result != TPM_SUCCESS)
+		return result;
+
+	result = TlclGetPermanentFlags(&pflags);
+	if (result != TPM_SUCCESS)
+		return result;
+
+	/*
+	 * TPM may come from the factory without physical presence finalized.
+	 * Fix if necessary.
+	 */
+	VBDEBUG(("TPM: physicalPresenceLifetimeLock=%d\n",
+		 pflags.physicalPresenceLifetimeLock));
+	if (!pflags.physicalPresenceLifetimeLock) {
+		VBDEBUG(("TPM: Finalizing physical presence\n"));
+		RETURN_ON_FAILURE(TlclFinalizePhysicalPresence());
+	}
+
+	/*
+	 * The TPM will not enforce the NV authorization restrictions until the
+	 * execution of a TPM_NV_DefineSpace with the handle of
+	 * TPM_NV_INDEX_LOCK.  Here we create that space if it doesn't already
+	 * exist. */
+	VBDEBUG(("TPM: nvLocked=%d\n", pflags.nvLocked));
+	if (!pflags.nvLocked) {
+		VBDEBUG(("TPM: Enabling NV locking\n"));
+		RETURN_ON_FAILURE(TlclSetNvLocked());
+	}
+
+	/* Clear TPM owner, in case the TPM is already owned for some reason. */
+	VBDEBUG(("TPM: Clearing owner\n"));
+	RETURN_ON_FAILURE(TPMClearAndReenable());
+
+	/* Initializes the firmware and kernel spaces */
+	Memcpy(rsf, &rsf_init, sizeof(RollbackSpaceFirmware));
+	Memcpy(rsk, &rsk_init, sizeof(RollbackSpaceKernel));
+
+	/* Defines and sets firmware and kernel spaces */
+	RETURN_ON_FAILURE(SafeDefineSpace(KERNEL_NV_INDEX, TPM_NV_PER_PPWRITE,
+					  sizeof(RollbackSpaceKernel)));
+	RETURN_ON_FAILURE(WriteSpaceKernel(rsk));
+	RETURN_ON_FAILURE(SafeDefineSpace(
+			FIRMWARE_NV_INDEX,
+			TPM_NV_PER_GLOBALLOCK | TPM_NV_PER_PPWRITE,
+			sizeof(RollbackSpaceFirmware)));
+	RETURN_ON_FAILURE(WriteSpaceFirmware(rsf));
+	return TPM_SUCCESS;
+}
+
+
+/*
+ * SetupTPM starts the TPM and establishes the root of trust for the
+ * anti-rollback mechanism.  SetupTPM can fail for three reasons.  1 A bug. 2 a
+ * TPM hardware failure. 3 An unexpected TPM state due to some attack.  In
+ * general we cannot easily distinguish the kind of failure, so our strategy is
+ * to reboot in recovery mode in all cases.  The recovery mode calls SetupTPM
+ * again, which executes (almost) the same sequence of operations.  There is a
+ * good chance that, if recovery mode was entered because of a TPM failure, the
+ * failure will repeat itself.  (In general this is impossible to guarantee
+ * because we have no way of creating the exact TPM initial state at the
+ * previous boot.)  In recovery mode, we ignore the failure and continue, thus
+ * giving the recovery kernel a chance to fix things (that's why we don't set
+ * bGlobalLock).  The choice is between a knowingly insecure device and a
+ * bricked device.
+ *
+ * As a side note, observe that we go through considerable hoops to avoid using
+ * the STCLEAR permissions for the index spaces.  We do this to avoid writing
+ * to the TPM flashram at every reboot or wake-up, because of concerns about
+ * the durability of the NVRAM.
+ */
+uint32_t SetupTPM(int developer_mode, int disable_dev_request,
+                  int clear_tpm_owner_request, RollbackSpaceFirmware* rsf)
+{
+	uint8_t in_flags;
+	uint8_t disable;
+	uint8_t deactivated;
+	uint32_t result;
+	uint32_t versions;
+
+	RETURN_ON_FAILURE(TlclLibInit());
+
+#ifdef TEGRA_SOFT_REBOOT_WORKAROUND
+	result = TlclStartup();
+	if (result == TPM_E_INVALID_POSTINIT) {
+		/*
+		 * Some prototype hardware doesn't reset the TPM on a CPU
+		 * reset.  We do a hard reset to get around this.
+		 */
+		VBDEBUG(("TPM: soft reset detected\n", result));
+		return TPM_E_MUST_REBOOT;
+	} else if (result != TPM_SUCCESS) {
+		VBDEBUG(("TPM: TlclStartup returned %08x\n", result));
+		return result;
+	}
+#else
+	RETURN_ON_FAILURE(TlclStartup());
+#endif
+
+  /*
+   * Some TPMs start the self test automatically at power on.  In that case we
+   * don't need to call ContinueSelfTest.  On some (other) TPMs,
+   * ContinueSelfTest may block.  In that case, we definitely don't want to
+   * call it here.  For TPMs in the intersection of these two sets, we're
+   * screwed.  (In other words: TPMs that require manually starting the
+   * self-test AND block will have poor performance until we split
+   * TlclSendReceive() into Send() and Receive(), and have a state machine to
+   * control setup.)
+   *
+   * This comment is likely to become obsolete in the near future, so don't
+   * trust it.  It may have not been updated.
+   */
+#ifdef TPM_MANUAL_SELFTEST
+#ifdef TPM_BLOCKING_CONTINUESELFTEST
+#warning "lousy TPM!"
+#endif
+	RETURN_ON_FAILURE(TlclContinueSelfTest());
+#endif
+	result = TlclAssertPhysicalPresence();
+	if (result != TPM_SUCCESS) {
+		/*
+		 * It is possible that the TPM was delivered with the physical
+		 * presence command disabled.  This tries enabling it, then
+		 * tries asserting PP again.
+		 */
+		RETURN_ON_FAILURE(TlclPhysicalPresenceCMDEnable());
+		RETURN_ON_FAILURE(TlclAssertPhysicalPresence());
+	}
+
+	/* Check that the TPM is enabled and activated. */
+	RETURN_ON_FAILURE(TlclGetFlags(&disable, &deactivated, NULL));
+	if (disable || deactivated) {
+		VBDEBUG(("TPM: disabled (%d) or deactivated (%d).  Fixing...\n",
+			 disable, deactivated));
+		RETURN_ON_FAILURE(TlclSetEnable());
+		RETURN_ON_FAILURE(TlclSetDeactivated(0));
+		VBDEBUG(("TPM: Must reboot to re-enable\n"));
+		return TPM_E_MUST_REBOOT;
+	}
+
+	/* Read the firmware space. */
+	result = ReadSpaceFirmware(rsf);
+	if (TPM_E_BADINDEX == result) {
+		RollbackSpaceKernel rsk;
+
+		/*
+		 * This is the first time we've run, and the TPM has not been
+		 * initialized.  Initialize it.
+		 */
+		VBDEBUG(("TPM: Not initialized yet.\n"));
+		RETURN_ON_FAILURE(OneTimeInitializeTPM(rsf, &rsk));
+	} else if (TPM_SUCCESS != result) {
+		VBDEBUG(("TPM: Firmware space in a bad state; giving up.\n"));
+		return TPM_E_CORRUPTED_STATE;
+	}
+	Memcpy(&versions, &rsf->fw_versions, sizeof(versions));
+	VBDEBUG(("TPM: Firmware space sv%d f%x v%x\n",
+		 rsf->struct_version, rsf->flags, versions));
+	in_flags = rsf->flags;
+
+	/* If we've been asked to clear the virtual dev-mode flag, do so now */
+	if (disable_dev_request) {
+		rsf->flags &= ~FLAG_VIRTUAL_DEV_MODE_ON;
+		VBDEBUG(("TPM: Clearing virt dev-switch: f%x\n", rsf->flags));
+	}
+
+	/*
+	 * The developer_mode value that's passed in is only set by a hardware
+	 * dev-switch. We should OR it with the virtual switch, whether or not
+	 * the virtual switch is used. If it's not used, it shouldn't change,
+	 * so it doesn't matter.
+	 */
+	if (rsf->flags & FLAG_VIRTUAL_DEV_MODE_ON)
+		developer_mode = 1;
+
+	/*
+	 * Clear ownership if developer flag has toggled, or if an owner-clear
+	 * has been requested.
+	 */
+	if ((developer_mode ? FLAG_LAST_BOOT_DEVELOPER : 0) !=
+	    (in_flags & FLAG_LAST_BOOT_DEVELOPER)) {
+		VBDEBUG(("TPM: Developer flag changed; clearing owner.\n"));
+		RETURN_ON_FAILURE(TPMClearAndReenable());
+	} else if (clear_tpm_owner_request) {
+		VBDEBUG(("TPM: Clearing owner as specifically requested.\n"));
+		RETURN_ON_FAILURE(TPMClearAndReenable());
+	}
+
+	if (developer_mode)
+		rsf->flags |= FLAG_LAST_BOOT_DEVELOPER;
+	else
+		rsf->flags &= ~FLAG_LAST_BOOT_DEVELOPER;
+
+
+	/* If firmware space is dirty, flush it back to the TPM */
+	if (rsf->flags != in_flags) {
+		VBDEBUG(("TPM: Updating firmware space.\n"));
+		RETURN_ON_FAILURE(WriteSpaceFirmware(rsf));
+	}
+
+	VBDEBUG(("TPM: SetupTPM() succeeded\n"));
+	return TPM_SUCCESS;
+}
+
+
+#ifdef DISABLE_ROLLBACK_TPM
+/* Dummy implementations which don't support TPM rollback protection */
+
+uint32_t RollbackS3Resume(void)
+{
+#ifndef CHROMEOS_ENVIRONMENT
+	/*
+	 * Initialize the TPM, but ignore return codes.  In ChromeOS
+	 * environment, don't even talk to the TPM.
+	 */
+	TlclLibInit();
+	TlclResume();
+#endif
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackFirmwareSetup(int is_hw_dev,
+                               int disable_dev_request,
+                               int clear_tpm_owner_request,
+                               int *is_virt_dev, uint32_t *version)
+{
+#ifndef CHROMEOS_ENVIRONMENT
+	/*
+	 * Initialize the TPM, but ignores return codes.  In ChromeOS
+	 * environment, don't even talk to the TPM.
+	 */
+	TlclLibInit();
+	TlclStartup();
+	TlclContinueSelfTest();
+#endif
+	*is_virt_dev = 0;
+	*version = 0;
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackFirmwareWrite(uint32_t version)
+{
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackFirmwareLock(void)
+{
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackKernelRead(uint32_t* version)
+{
+	*version = 0;
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackKernelWrite(uint32_t version)
+{
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackKernelLock(int recovery_mode)
+{
+	return TPM_SUCCESS;
+}
+
+#else
+
+uint32_t RollbackS3Resume(void)
+{
+	uint32_t result;
+	RETURN_ON_FAILURE(TlclLibInit());
+	result = TlclResume();
+	if (result == TPM_E_INVALID_POSTINIT) {
+		/*
+		 * We're on a platform where the TPM maintains power in S3, so
+		 * it's already initialized.
+		 */
+		return TPM_SUCCESS;
+	}
+	return result;
+}
+
+uint32_t RollbackFirmwareSetup(int is_hw_dev,
+                               int disable_dev_request,
+                               int clear_tpm_owner_request,
+                               int *is_virt_dev, uint32_t *version)
+{
+	RollbackSpaceFirmware rsf;
+
+	/* Set version to 0 in case we fail */
+	*version = 0;
+
+	RETURN_ON_FAILURE(SetupTPM(is_hw_dev, disable_dev_request,
+				   clear_tpm_owner_request, &rsf));
+	Memcpy(version, &rsf.fw_versions, sizeof(*version));
+	*is_virt_dev = (rsf.flags & FLAG_VIRTUAL_DEV_MODE_ON) ? 1 : 0;
+	VBDEBUG(("TPM: RollbackFirmwareSetup %x\n", (int)*version));
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackFirmwareWrite(uint32_t version)
+{
+	RollbackSpaceFirmware rsf;
+	uint32_t old_version;
+
+	RETURN_ON_FAILURE(ReadSpaceFirmware(&rsf));
+	Memcpy(&old_version, &rsf.fw_versions, sizeof(old_version));
+	VBDEBUG(("TPM: RollbackFirmwareWrite %x --> %x\n", (int)old_version,
+		 (int)version));
+	Memcpy(&rsf.fw_versions, &version, sizeof(version));
+	return WriteSpaceFirmware(&rsf);
+}
+
+uint32_t RollbackFirmwareLock(void)
+{
+	return TlclSetGlobalLock();
+}
+
+uint32_t RollbackKernelRead(uint32_t* version)
+{
+	RollbackSpaceKernel rsk;
+	uint32_t perms, uid;
+
+	/*
+	 * Read the kernel space and verify its permissions.  If the kernel
+	 * space has the wrong permission, or it doesn't contain the right
+	 * identifier, we give up.  This will need to be fixed by the
+	 * recovery kernel.  We have to worry about this because at any time
+	 * (even with PP turned off) the TPM owner can remove and redefine a
+	 * PP-protected space (but not write to it).
+	 */
+	RETURN_ON_FAILURE(ReadSpaceKernel(&rsk));
+	RETURN_ON_FAILURE(TlclGetPermissions(KERNEL_NV_INDEX, &perms));
+	Memcpy(&uid, &rsk.uid, sizeof(uid));
+	if (TPM_NV_PER_PPWRITE != perms || ROLLBACK_SPACE_KERNEL_UID != uid)
+		return TPM_E_CORRUPTED_STATE;
+
+	Memcpy(version, &rsk.kernel_versions, sizeof(*version));
+	VBDEBUG(("TPM: RollbackKernelRead %x\n", (int)*version));
+	return TPM_SUCCESS;
+}
+
+uint32_t RollbackKernelWrite(uint32_t version)
+{
+	RollbackSpaceKernel rsk;
+	uint32_t old_version;
+	RETURN_ON_FAILURE(ReadSpaceKernel(&rsk));
+	Memcpy(&old_version, &rsk.kernel_versions, sizeof(old_version));
+	VBDEBUG(("TPM: RollbackKernelWrite %x --> %x\n",
+		 (int)old_version, (int)version));
+	Memcpy(&rsk.kernel_versions, &version, sizeof(version));
+	return WriteSpaceKernel(&rsk);
+}
+
+uint32_t RollbackKernelLock(int recovery_mode)
+{
+	if (recovery_mode)
+		return TPM_SUCCESS;
+	else
+		return TlclLockPhysicalPresence();
+}
+
+#endif /* DISABLE_ROLLBACK_TPM */
diff -Nur tools-org/vboot_utils/src/firmware/lib/stateful_util.c tools/vboot_utils/src/firmware/lib/stateful_util.c
--- tools-org/vboot_utils/src/firmware/lib/stateful_util.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/stateful_util.c	2014-04-27 13:03:45.760117503 +0000
@@ -0,0 +1,74 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Implementations of stateful memory operations.
+ */
+
+#include "sysincludes.h"
+
+#include "stateful_util.h"
+#include "utility.h"
+
+void StatefulInit(MemcpyState *state, void *buf, uint64_t len)
+{
+	state->remaining_buf = buf;
+	state->remaining_len = len;
+	state->overrun = 0;
+}
+
+void *StatefulSkip(MemcpyState *state, uint64_t len)
+{
+	if (state->overrun)
+		return NULL;
+	if (len > state->remaining_len) {
+		state->overrun = 1;
+		return NULL;
+	}
+	state->remaining_buf += len;
+	state->remaining_len -= len;
+	return state; /* Must return something non-NULL. */
+}
+
+void *StatefulMemcpy(MemcpyState *state, void *dst, uint64_t len)
+{
+	if (state->overrun)
+		return NULL;
+	if (len > state->remaining_len) {
+		state->overrun = 1;
+		return NULL;
+	}
+	Memcpy(dst, state->remaining_buf, len);
+	state->remaining_buf += len;
+	state->remaining_len -= len;
+	return dst;
+}
+
+const void *StatefulMemcpy_r(MemcpyState *state, const void *src, uint64_t len)
+{
+	if (state->overrun)
+		return NULL;
+	if (len > state->remaining_len) {
+		state->overrun = 1;
+		return NULL;
+	}
+	Memcpy(state->remaining_buf, src, len);
+	state->remaining_buf += len;
+	state->remaining_len -= len;
+	return src;
+}
+
+const void *StatefulMemset_r(MemcpyState *state, const uint8_t val,
+			     uint64_t len)
+{
+	if (state->overrun)
+		return NULL;
+	if (len > state->remaining_len) {
+		state->overrun = 1;
+		return NULL;
+	}
+	Memset(state->remaining_buf, val, len);
+	state->remaining_buf += len;
+	state->remaining_len -= len;
+	return state; /* Must return something non-NULL. */
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/utility.c tools/vboot_utils/src/firmware/lib/utility.c
--- tools-org/vboot_utils/src/firmware/lib/utility.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/utility.c	2014-04-27 13:03:45.760117503 +0000
@@ -0,0 +1,28 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Utility functions that need to be built as part of the firmware.
+ */
+
+#include "sysincludes.h"
+
+#include "utility.h"
+
+int SafeMemcmp(const void *s1, const void *s2, size_t n) {
+	const unsigned char *us1 = s1;
+	const unsigned char *us2 = s2;
+	int result = 0;
+
+	if (0 == n)
+		return 0;
+
+	/*
+	 * Code snippet without data-dependent branch due to Nate Lawson
+	 * (nate@root.org) of Root Labs.
+	 */
+	while (n--)
+		result |= *us1++ ^ *us2++;
+
+	return result != 0;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/utility_string.c tools/vboot_utils/src/firmware/lib/utility_string.c
--- tools-org/vboot_utils/src/firmware/lib/utility_string.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/utility_string.c	2014-04-27 13:03:45.764117779 +0000
@@ -0,0 +1,74 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * String utility functions that need to be built as part of the firmware.
+ */
+
+#include "sysincludes.h"
+
+#include "utility.h"
+
+
+uint32_t Uint64ToString(char *buf, uint32_t bufsize, uint64_t value,
+			uint32_t radix, uint32_t zero_pad_width)
+{
+	char ibuf[UINT64_TO_STRING_MAX];
+	char *s;
+	uint32_t usedsize = 1;
+
+	if (!buf)
+		return 0;
+
+	/* Clear output buffer in case of error */
+	*buf = '\0';
+
+	/* Sanity-check input args */
+	if (radix < 2 || radix > 36 || zero_pad_width >= UINT64_TO_STRING_MAX)
+		return 0;
+
+	/* Start at end of string and work backwards */
+	s = ibuf + UINT64_TO_STRING_MAX - 1;
+	*(s) = '\0';
+	do {
+		int v = value % radix;
+		value /= radix;
+
+		*(--s) = (char)(v < 10 ? v + '0' : v + 'a' - 10);
+		if (++usedsize > bufsize)
+			return 0;  /* Result won't fit in buffer */
+	} while (value);
+
+	/* Zero-pad if necessary */
+	while (usedsize <= zero_pad_width) {
+		*(--s) = '0';
+		if (++usedsize > bufsize)
+			return 0;  /* Result won't fit in buffer */
+	}
+
+	/* Now copy the string back to the input buffer. */
+	Memcpy(buf, s, usedsize);
+
+	/* Don't count the terminating null in the bytes used */
+	return usedsize - 1;
+}
+
+uint32_t StrnAppend(char *dest, const char *src, uint32_t destlen)
+{
+	uint32_t used = 0;
+
+	if (!dest || !src || !destlen)
+		return 0;
+
+	/* Skip past existing string in destination.*/
+	while (dest[used] && used < destlen - 1)
+		used++;
+
+	/* Now copy source */
+	while (*src && used < destlen - 1)
+		dest[used++] = *src++;
+
+	/* Terminate destination and return count of non-null characters */
+	dest[used] = 0;
+	return used;
+}
diff -Nur tools-org/vboot_utils/src/firmware/lib/vboot_common.c tools/vboot_utils/src/firmware/lib/vboot_common.c
--- tools-org/vboot_utils/src/firmware/lib/vboot_common.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/lib/vboot_common.c	2014-04-27 13:03:45.764117779 +0000
@@ -0,0 +1,481 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Common functions between firmware and kernel verified boot.
+ * (Firmware portion)
+ */
+
+#include "sysincludes.h"
+
+#include "vboot_api.h"
+#include "vboot_common.h"
+#include "utility.h"
+
+const char *kVbootErrors[VBOOT_ERROR_MAX] = {
+	"Success.",
+	"Key block invalid.",
+	"Key block signature failed.",
+	"Key block hash failed.",
+	"Public key invalid.",
+	"Preamble invalid.",
+	"Preamble signature check failed.",
+	"Shared data invalid."
+};
+
+uint64_t OffsetOf(const void *base, const void *ptr)
+{
+	return (uint64_t)(size_t)ptr - (uint64_t)(size_t)base;
+}
+
+/* Helper functions to get data pointed to by a public key or signature. */
+
+uint8_t *GetPublicKeyData(VbPublicKey *key)
+{
+	return (uint8_t *)key + key->key_offset;
+}
+
+const uint8_t *GetPublicKeyDataC(const VbPublicKey *key)
+{
+	return (const uint8_t *)key + key->key_offset;
+}
+
+uint8_t *GetSignatureData(VbSignature *sig)
+{
+	return (uint8_t *)sig + sig->sig_offset;
+}
+
+const uint8_t *GetSignatureDataC(const VbSignature *sig)
+{
+	return (const uint8_t *)sig + sig->sig_offset;
+}
+
+/*
+ * Helper functions to verify the data pointed to by a subfield is inside
+ * the parent data.  Returns 0 if inside, 1 if error.
+ */
+
+int VerifyMemberInside(const void *parent, uint64_t parent_size,
+                       const void *member, uint64_t member_size,
+                       uint64_t member_data_offset,
+                       uint64_t member_data_size)
+{
+	uint64_t end = OffsetOf(parent, member);
+
+	if (end > parent_size)
+		return 1;
+
+	if (UINT64_MAX - end < member_size)
+		return 1;  /* Detect wraparound in integer math */
+	if (end + member_size > parent_size)
+		return 1;
+
+	if (UINT64_MAX - end < member_data_offset)
+		return 1;
+	end += member_data_offset;
+	if (end > parent_size)
+		return 1;
+
+	if (UINT64_MAX - end < member_data_size)
+		return 1;
+	if (end + member_data_size > parent_size)
+		return 1;
+
+	return 0;
+}
+
+int VerifyPublicKeyInside(const void *parent, uint64_t parent_size,
+                          const VbPublicKey *key)
+{
+	return VerifyMemberInside(parent, parent_size,
+				  key, sizeof(VbPublicKey),
+				  key->key_offset, key->key_size);
+}
+
+int VerifySignatureInside(const void *parent, uint64_t parent_size,
+                          const VbSignature *sig)
+{
+	return VerifyMemberInside(parent, parent_size,
+				  sig, sizeof(VbSignature),
+				  sig->sig_offset, sig->sig_size);
+}
+
+void PublicKeyInit(VbPublicKey *key, uint8_t *key_data, uint64_t key_size)
+{
+	key->key_offset = OffsetOf(key, key_data);
+	key->key_size = key_size;
+	key->algorithm = kNumAlgorithms; /* Key not present yet */
+	key->key_version = 0;
+}
+
+int PublicKeyCopy(VbPublicKey *dest, const VbPublicKey *src)
+{
+	if (dest->key_size < src->key_size)
+		return 1;
+
+	dest->key_size = src->key_size;
+	dest->algorithm = src->algorithm;
+	dest->key_version = src->key_version;
+	Memcpy(GetPublicKeyData(dest), GetPublicKeyDataC(src), src->key_size);
+	return 0;
+}
+
+RSAPublicKey *PublicKeyToRSA(const VbPublicKey *key)
+{
+	RSAPublicKey *rsa;
+	uint64_t key_size;
+
+	if (kNumAlgorithms <= key->algorithm) {
+		VBDEBUG(("Invalid algorithm.\n"));
+		return NULL;
+	}
+	if (!RSAProcessedKeySize(key->algorithm, &key_size) ||
+	    key_size != key->key_size) {
+		VBDEBUG(("Wrong key size for algorithm\n"));
+		return NULL;
+	}
+
+	rsa = RSAPublicKeyFromBuf(GetPublicKeyDataC(key), key->key_size);
+	if (!rsa)
+		return NULL;
+
+	rsa->algorithm = (unsigned int)key->algorithm;
+	return rsa;
+}
+
+int VerifyData(const uint8_t *data, uint64_t size, const VbSignature *sig,
+               const RSAPublicKey *key)
+{
+	VBDEBUG(("   - sig_size=%d, expecting %d for algorithm %d\n",
+		 (unsigned)sig->sig_size, siglen_map[key->algorithm],
+		 key->algorithm));
+	if (sig->sig_size != siglen_map[key->algorithm]) {
+		VBDEBUG(("Wrong data signature size for algorithm, "
+			 "sig_size=%d, expected %d for algorithm %d.\n",
+			 (int)sig->sig_size, siglen_map[key->algorithm],
+			 key->algorithm));
+		return 1;
+	}
+	if (sig->data_size > size) {
+		VBDEBUG(("Data buffer smaller than length of signed data.\n"));
+		return 1;
+	}
+
+	if (!RSAVerifyBinary_f(NULL, key, data, sig->data_size,
+			       GetSignatureDataC(sig), key->algorithm))
+		return 1;
+
+	return 0;
+}
+
+int VerifyDigest(const uint8_t *digest, const VbSignature *sig,
+                 const RSAPublicKey *key)
+{
+	if (sig->sig_size != siglen_map[key->algorithm]) {
+		VBDEBUG(("Wrong digest signature size for algorithm.\n"));
+		return 1;
+	}
+
+	if (!RSAVerifyBinaryWithDigest_f(NULL, key, digest,
+					 GetSignatureDataC(sig),
+					 key->algorithm))
+		return 1;
+
+	return 0;
+}
+
+int KeyBlockVerify(const VbKeyBlockHeader *block, uint64_t size,
+                   const VbPublicKey *key, int hash_only)
+{
+	const VbSignature *sig;
+
+	/* Sanity checks before attempting signature of data */
+	if(size < sizeof(VbKeyBlockHeader)) {
+		VBDEBUG(("Not enough space for key block header.\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+	if (SafeMemcmp(block->magic, KEY_BLOCK_MAGIC, KEY_BLOCK_MAGIC_SIZE)) {
+		VBDEBUG(("Not a valid verified boot key block.\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+	if (block->header_version_major != KEY_BLOCK_HEADER_VERSION_MAJOR) {
+		VBDEBUG(("Incompatible key block header version.\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+	if (size < block->key_block_size) {
+		VBDEBUG(("Not enough data for key block.\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+	if (!hash_only && !key) {
+		VBDEBUG(("Missing required public key.\n"));
+		return VBOOT_PUBLIC_KEY_INVALID;
+	}
+
+	/*
+	 * Check signature or hash, depending on the hash_only parameter. Note
+	 * that we don't require a key even if the keyblock has a signature,
+	 * because the caller may not care if the keyblock itself is signed
+	 * (for example, booting a Google-signed kernel in developer mode).
+	 */
+	if (hash_only) {
+		/* Check hash */
+		uint8_t *header_checksum = NULL;
+		int rv;
+
+		sig = &block->key_block_checksum;
+
+		if (VerifySignatureInside(block, block->key_block_size, sig)) {
+			VBDEBUG(("Key block hash off end of block\n"));
+			return VBOOT_KEY_BLOCK_INVALID;
+		}
+		if (sig->sig_size != SHA512_DIGEST_SIZE) {
+			VBDEBUG(("Wrong hash size for key block.\n"));
+			return VBOOT_KEY_BLOCK_INVALID;
+		}
+
+		/* Make sure advertised signature data sizes are sane. */
+		if (block->key_block_size < sig->data_size) {
+			VBDEBUG(("Signature calculated past end of block\n"));
+			return VBOOT_KEY_BLOCK_INVALID;
+		}
+
+		VBDEBUG(("Checking key block hash only...\n"));
+		header_checksum = DigestBuf((const uint8_t *)block,
+					    sig->data_size,
+					    SHA512_DIGEST_ALGORITHM);
+		rv = SafeMemcmp(header_checksum, GetSignatureDataC(sig),
+				SHA512_DIGEST_SIZE);
+		VbExFree(header_checksum);
+		if (rv) {
+			VBDEBUG(("Invalid key block hash.\n"));
+			return VBOOT_KEY_BLOCK_HASH;
+		}
+	} else {
+		/* Check signature */
+		RSAPublicKey *rsa;
+		int rv;
+
+		sig = &block->key_block_signature;
+
+		if (VerifySignatureInside(block, block->key_block_size, sig)) {
+			VBDEBUG(("Key block signature off end of block\n"));
+			return VBOOT_KEY_BLOCK_INVALID;
+		}
+
+		rsa = PublicKeyToRSA(key);
+		if (!rsa) {
+			VBDEBUG(("Invalid public key\n"));
+			return VBOOT_PUBLIC_KEY_INVALID;
+		}
+
+		/* Make sure advertised signature data sizes are sane. */
+		if (block->key_block_size < sig->data_size) {
+			VBDEBUG(("Signature calculated past end of block\n"));
+			RSAPublicKeyFree(rsa);
+			return VBOOT_KEY_BLOCK_INVALID;
+		}
+
+		VBDEBUG(("Checking key block signature...\n"));
+		rv = VerifyData((const uint8_t *)block, size, sig, rsa);
+		RSAPublicKeyFree(rsa);
+		if (rv) {
+			VBDEBUG(("Invalid key block signature.\n"));
+			return VBOOT_KEY_BLOCK_SIGNATURE;
+		}
+	}
+
+	/* Verify we signed enough data */
+	if (sig->data_size < sizeof(VbKeyBlockHeader)) {
+		VBDEBUG(("Didn't sign enough data\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+
+	/* Verify data key is inside the block and inside signed data */
+	if (VerifyPublicKeyInside(block, block->key_block_size,
+				  &block->data_key)) {
+		VBDEBUG(("Data key off end of key block\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+	if (VerifyPublicKeyInside(block, sig->data_size, &block->data_key)) {
+		VBDEBUG(("Data key off end of signed data\n"));
+		return VBOOT_KEY_BLOCK_INVALID;
+	}
+
+	/* Success */
+	return VBOOT_SUCCESS;
+}
+
+int VerifyFirmwarePreamble(const VbFirmwarePreambleHeader *preamble,
+                           uint64_t size, const RSAPublicKey *key)
+{
+	const VbSignature *sig = &preamble->preamble_signature;
+
+	VBDEBUG(("Verifying preamble.\n"));
+	/* Sanity checks before attempting signature of data */
+	if(size < EXPECTED_VBFIRMWAREPREAMBLEHEADER2_0_SIZE) {
+		VBDEBUG(("Not enough data for preamble header 2.0.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+	if (preamble->header_version_major !=
+	    FIRMWARE_PREAMBLE_HEADER_VERSION_MAJOR) {
+		VBDEBUG(("Incompatible firmware preamble header version.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+	if (size < preamble->preamble_size) {
+		VBDEBUG(("Not enough data for preamble.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Check signature */
+	if (VerifySignatureInside(preamble, preamble->preamble_size, sig)) {
+		VBDEBUG(("Preamble signature off end of preamble\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Make sure advertised signature data sizes are sane. */
+	if (preamble->preamble_size < sig->data_size) {
+		VBDEBUG(("Signature calculated past end of the block\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	if (VerifyData((const uint8_t *)preamble, size, sig, key)) {
+		VBDEBUG(("Preamble signature validation failed\n"));
+		return VBOOT_PREAMBLE_SIGNATURE;
+	}
+
+	/* Verify we signed enough data */
+	if (sig->data_size < sizeof(VbFirmwarePreambleHeader)) {
+		VBDEBUG(("Didn't sign enough data\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Verify body signature is inside the signed data */
+	if (VerifySignatureInside(preamble, sig->data_size,
+				  &preamble->body_signature)) {
+		VBDEBUG(("Firmware body signature off end of preamble\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Verify kernel subkey is inside the signed data */
+	if (VerifyPublicKeyInside(preamble, sig->data_size,
+				  &preamble->kernel_subkey)) {
+		VBDEBUG(("Kernel subkey off end of preamble\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/*
+	 * If the preamble header version is at least 2.1, verify we have space
+	 * for the added fields from 2.1.
+	 */
+	if (preamble->header_version_minor >= 1) {
+		if(size < EXPECTED_VBFIRMWAREPREAMBLEHEADER2_1_SIZE) {
+			VBDEBUG(("Not enough data for preamble header 2.1.\n"));
+			return VBOOT_PREAMBLE_INVALID;
+		}
+	}
+
+	/* Success */
+	return VBOOT_SUCCESS;
+}
+
+uint32_t VbGetFirmwarePreambleFlags(const VbFirmwarePreambleHeader *preamble)
+{
+	if (preamble->header_version_minor < 1) {
+		/*
+		 * Old structure; return default flags.  (Note that we don't
+		 * need to check header_version_major; if that's not 2 then
+		 * VerifyFirmwarePreamble() would have already failed.
+		 */
+		return 0;
+	}
+
+	return preamble->flags;
+}
+
+int VerifyKernelPreamble(const VbKernelPreambleHeader *preamble,
+                         uint64_t size, const RSAPublicKey *key)
+{
+	const VbSignature *sig = &preamble->preamble_signature;
+
+	/* Sanity checks before attempting signature of data */
+	if(size < sizeof(VbKernelPreambleHeader)) {
+		VBDEBUG(("Not enough data for preamble header.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+	if (preamble->header_version_major !=
+	    KERNEL_PREAMBLE_HEADER_VERSION_MAJOR) {
+		VBDEBUG(("Incompatible kernel preamble header version.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+	if (size < preamble->preamble_size) {
+		VBDEBUG(("Not enough data for preamble.\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Check signature */
+	if (VerifySignatureInside(preamble, preamble->preamble_size, sig)) {
+		VBDEBUG(("Preamble signature off end of preamble\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+	if (VerifyData((const uint8_t *)preamble, size, sig, key)) {
+		VBDEBUG(("Preamble signature validation failed\n"));
+		return VBOOT_PREAMBLE_SIGNATURE;
+	}
+
+	/* Verify we signed enough data */
+	if (sig->data_size < sizeof(VbKernelPreambleHeader)) {
+		VBDEBUG(("Didn't sign enough data\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Verify body signature is inside the signed data */
+	if (VerifySignatureInside(preamble, sig->data_size,
+				  &preamble->body_signature)) {
+		VBDEBUG(("Kernel body signature off end of preamble\n"));
+		return VBOOT_PREAMBLE_INVALID;
+	}
+
+	/* Success */
+	return VBOOT_SUCCESS;
+}
+
+uint64_t VbSharedDataReserve(VbSharedDataHeader *header, uint64_t size)
+{
+	uint64_t offs = header->data_used;
+
+	VBDEBUG(("VbSharedDataReserve %d bytes at %d\n", (int)size, (int)offs));
+
+	if (!header || size > header->data_size - header->data_used) {
+		VBDEBUG(("VbSharedData buffer out of space.\n"));
+		return 0;  /* Not initialized, or not enough space left. */
+	}
+	header->data_used += size;
+	return offs;
+}
+
+int VbSharedDataSetKernelKey(VbSharedDataHeader *header, const VbPublicKey *src)
+{
+	VbPublicKey *kdest = &header->kernel_subkey;
+
+	VBDEBUG(("Saving kernel subkey to shared data: size %d, algo %d\n",
+		 siglen_map[src->algorithm], (int)src->algorithm));
+
+	if (!header)
+		return VBOOT_SHARED_DATA_INVALID;
+
+	/* Attempt to allocate space for key, if it hasn't been allocated yet */
+	if (!header->kernel_subkey_data_offset) {
+		header->kernel_subkey_data_offset =
+			VbSharedDataReserve(header, src->key_size);
+		if (!header->kernel_subkey_data_offset)
+			return VBOOT_SHARED_DATA_INVALID;
+		header->kernel_subkey_data_size = src->key_size;
+	}
+
+	/* Copy the kernel sign key blob into the destination buffer */
+	PublicKeyInit(kdest,
+		      (uint8_t *)header + header->kernel_subkey_data_offset,
+		      header->kernel_subkey_data_size);
+
+	return PublicKeyCopy(kdest, src);
+}
diff -Nur tools-org/vboot_utils/src/firmware/README tools/vboot_utils/src/firmware/README
--- tools-org/vboot_utils/src/firmware/README	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/README	2014-04-27 13:03:45.724115029 +0000
@@ -0,0 +1,8 @@
+arch/ is stuff that defines the architecture-dependent information (only used in
+firmware build mode).
+
+lib/ is stuff that the BIOS needs to link with.
+
+stub/ is stuff to be implemented by the BIOS.
+
+include/ describes the interfaces between the two parts.
diff -Nur tools-org/vboot_utils/src/firmware/stub/utility_stub.c tools/vboot_utils/src/firmware/stub/utility_stub.c
--- tools-org/vboot_utils/src/firmware/stub/utility_stub.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/stub/utility_stub.c	2014-04-27 13:03:45.764117779 +0000
@@ -0,0 +1,35 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Stub implementations of utility functions which call their linux-specific
+ * equivalents.
+ */
+
+#include <stdint.h>
+
+#define _STUB_IMPLEMENTATION_
+#include "utility.h"
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+
+int Memcmp(const void *src1, const void *src2, size_t n)
+{
+	return memcmp(src1, src2, n);
+}
+
+void *Memcpy(void *dest, const void *src, uint64_t n)
+{
+	return memcpy(dest, src, (size_t)n);
+}
+
+void *Memset(void *d, const uint8_t c, uint64_t n)
+{
+	return memset(d, c, n);
+}
+
+
diff -Nur tools-org/vboot_utils/src/firmware/stub/vboot_api_stub_sf.c tools/vboot_utils/src/firmware/stub/vboot_api_stub_sf.c
--- tools-org/vboot_utils/src/firmware/stub/vboot_api_stub_sf.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/firmware/stub/vboot_api_stub_sf.c	2014-04-27 13:03:45.768118055 +0000
@@ -0,0 +1,127 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Stub implementations of firmware-provided API functions.
+ */
+
+#include <execinfo.h>
+#include <stdint.h>
+
+#define _STUB_IMPLEMENTATION_
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include "vboot_api.h"
+
+#define MAX_STACK_LEVELS 10
+
+
+/* Keep track of nodes that are currently allocated */
+struct alloc_node {
+	struct alloc_node *next;
+	void *ptr;
+	size_t size;
+	void *bt_buffer[MAX_STACK_LEVELS];
+	int bt_levels;
+};
+
+static struct alloc_node *alloc_head;
+
+static void print_stacktrace(void)
+{
+	void *buffer[MAX_STACK_LEVELS];
+	int levels = backtrace(buffer, MAX_STACK_LEVELS);
+
+	// print to stderr (fd = 2), and remove this function from the trace
+	backtrace_symbols_fd(buffer + 1, levels - 1, 2);
+}
+
+void *VbExMalloc(size_t size)
+{
+	struct alloc_node *node;
+	void *p = malloc(size);
+
+	if (!p) {
+		/* Fatal Error. We must abort. */
+		abort();
+	}
+
+	node = malloc(sizeof(*node));
+	if (!node)
+		abort();
+	node->next = alloc_head;
+	node->ptr = p;
+	node->size = size;
+	node->bt_levels = backtrace(node->bt_buffer, MAX_STACK_LEVELS);
+	alloc_head = node;
+
+	return p;
+}
+
+static struct alloc_node **find_node(void *ptr)
+{
+	struct alloc_node **nodep;
+
+	for (nodep = &alloc_head; *nodep; nodep = &(*nodep)->next)
+		if ((*nodep)->ptr == ptr)
+			return nodep;
+
+	return NULL;
+}
+
+void VbExFree(void *ptr)
+{
+	struct alloc_node **nodep, *next;
+
+	nodep = find_node(ptr);
+	if (nodep) {
+		next = (*nodep)->next;
+		free(*nodep);
+		*nodep = next;
+	} else {
+		fprintf(stderr, "\n>>>>>> Invalid VbExFree() %p\n", ptr);
+		fflush(stderr);
+		print_stacktrace();
+		/*
+		 * Fall through and do the free() so we get normal error
+		 * handling.
+		 */
+	}
+
+	free(ptr);
+}
+
+VbError_t VbExHashFirmwareBody(VbCommonParams *cparams,
+                               uint32_t firmware_index)
+{
+	return VBERROR_SUCCESS;
+}
+
+int vboot_api_stub_check_memory(void)
+{
+	struct alloc_node *node, *next;
+
+	if (!alloc_head)
+		return 0;
+
+	/*
+	 * Make sure we free all our memory so that valgrind doesn't complain
+	 * about leaked memory.
+	 */
+	fprintf(stderr, "\nWarning, some allocations not freed:");
+	for (node = alloc_head; node; node = next) {
+		next = node->next;
+		fprintf(stderr, "\nptr=%p, size=%zd\n", node->ptr, node->size);
+		fflush(stderr);
+		backtrace_symbols_fd(node->bt_buffer + 1, node->bt_levels - 1,
+				     2);
+		free(node);
+	}
+
+	return -1;
+}
diff -Nur tools-org/vboot_utils/src/host/include/openssl/bn.h tools/vboot_utils/src/host/include/openssl/bn.h
--- tools-org/vboot_utils/src/host/include/openssl/bn.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/include/openssl/bn.h	2014-04-27 13:03:45.772118330 +0000
@@ -0,0 +1,902 @@
+/* crypto/bn/bn.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
+ *
+ * Portions of the attached software ("Contribution") are developed by 
+ * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
+ *
+ * The Contribution is licensed pursuant to the Eric Young open source
+ * license provided above.
+ *
+ * The binary polynomial arithmetic software is originally written by 
+ * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
+ *
+ */
+
+#ifndef HEADER_BN_H
+#define HEADER_BN_H
+
+#include <openssl/e_os2.h>
+#ifndef OPENSSL_NO_FP_API
+#include <stdio.h> /* FILE */
+#endif
+#include <openssl/ossl_typ.h>
+#include <openssl/crypto.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* These preprocessor symbols control various aspects of the bignum headers and
+ * library code. They're not defined by any "normal" configuration, as they are
+ * intended for development and testing purposes. NB: defining all three can be
+ * useful for debugging application code as well as openssl itself.
+ *
+ * BN_DEBUG - turn on various debugging alterations to the bignum code
+ * BN_DEBUG_RAND - uses random poisoning of unused words to trip up
+ * mismanagement of bignum internals. You must also define BN_DEBUG.
+ */
+/* #define BN_DEBUG */
+/* #define BN_DEBUG_RAND */
+
+#ifndef OPENSSL_SMALL_FOOTPRINT
+#define BN_MUL_COMBA
+#define BN_SQR_COMBA
+#define BN_RECURSION
+#endif
+
+/* This next option uses the C libraries (2 word)/(1 word) function.
+ * If it is not defined, I use my C version (which is slower).
+ * The reason for this flag is that when the particular C compiler
+ * library routine is used, and the library is linked with a different
+ * compiler, the library is missing.  This mostly happens when the
+ * library is built with gcc and then linked using normal cc.  This would
+ * be a common occurrence because gcc normally produces code that is
+ * 2 times faster than system compilers for the big number stuff.
+ * For machines with only one compiler (or shared libraries), this should
+ * be on.  Again this in only really a problem on machines
+ * using "long long's", are 32bit, and are not using my assembler code. */
+#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || \
+    defined(OPENSSL_SYS_WIN32) || defined(linux)
+# ifndef BN_DIV2W
+#  define BN_DIV2W
+# endif
+#endif
+
+/* assuming long is 64bit - this is the DEC Alpha
+ * unsigned long long is only 64 bits :-(, don't define
+ * BN_LLONG for the DEC Alpha */
+#ifdef SIXTY_FOUR_BIT_LONG
+#define BN_ULLONG	unsigned long long
+#define BN_ULONG	unsigned long
+#define BN_LONG		long
+#define BN_BITS		128
+#define BN_BYTES	8
+#define BN_BITS2	64
+#define BN_BITS4	32
+#define BN_MASK		(0xffffffffffffffffffffffffffffffffLL)
+#define BN_MASK2	(0xffffffffffffffffL)
+#define BN_MASK2l	(0xffffffffL)
+#define BN_MASK2h	(0xffffffff00000000L)
+#define BN_MASK2h1	(0xffffffff80000000L)
+#define BN_TBIT		(0x8000000000000000L)
+#define BN_DEC_CONV	(10000000000000000000UL)
+#define BN_DEC_FMT1	"%lu"
+#define BN_DEC_FMT2	"%019lu"
+#define BN_DEC_NUM	19
+#define BN_HEX_FMT1	"%lX"
+#define BN_HEX_FMT2	"%016lX"
+#endif
+
+/* This is where the long long data type is 64 bits, but long is 32.
+ * For machines where there are 64bit registers, this is the mode to use.
+ * IRIX, on R4000 and above should use this mode, along with the relevant
+ * assembler code :-).  Do NOT define BN_LLONG.
+ */
+#ifdef SIXTY_FOUR_BIT
+#undef BN_LLONG
+#undef BN_ULLONG
+#define BN_ULONG	unsigned long long
+#define BN_LONG		long long
+#define BN_BITS		128
+#define BN_BYTES	8
+#define BN_BITS2	64
+#define BN_BITS4	32
+#define BN_MASK2	(0xffffffffffffffffLL)
+#define BN_MASK2l	(0xffffffffL)
+#define BN_MASK2h	(0xffffffff00000000LL)
+#define BN_MASK2h1	(0xffffffff80000000LL)
+#define BN_TBIT		(0x8000000000000000LL)
+#define BN_DEC_CONV	(10000000000000000000ULL)
+#define BN_DEC_FMT1	"%llu"
+#define BN_DEC_FMT2	"%019llu"
+#define BN_DEC_NUM	19
+#define BN_HEX_FMT1	"%llX"
+#define BN_HEX_FMT2	"%016llX"
+#endif
+
+#ifdef THIRTY_TWO_BIT
+#ifdef BN_LLONG
+# if defined(_WIN32) && !defined(__GNUC__)
+#  define BN_ULLONG	unsigned __int64
+#  define BN_MASK	(0xffffffffffffffffI64)
+# else
+#  define BN_ULLONG	unsigned long long
+#  define BN_MASK	(0xffffffffffffffffLL)
+# endif
+#endif
+#define BN_ULONG	unsigned int
+#define BN_LONG		int
+#define BN_BITS		64
+#define BN_BYTES	4
+#define BN_BITS2	32
+#define BN_BITS4	16
+#define BN_MASK2	(0xffffffffL)
+#define BN_MASK2l	(0xffff)
+#define BN_MASK2h1	(0xffff8000L)
+#define BN_MASK2h	(0xffff0000L)
+#define BN_TBIT		(0x80000000L)
+#define BN_DEC_CONV	(1000000000L)
+#define BN_DEC_FMT1	"%u"
+#define BN_DEC_FMT2	"%09u"
+#define BN_DEC_NUM	9
+#define BN_HEX_FMT1	"%X"
+#define BN_HEX_FMT2	"%08X"
+#endif
+
+/* 2011-02-22 SMS.
+ * In various places, a size_t variable or a type cast to size_t was
+ * used to perform integer-only operations on pointers.  This failed on
+ * VMS with 64-bit pointers (CC /POINTER_SIZE = 64) because size_t is
+ * still only 32 bits.  What's needed in these cases is an integer type
+ * with the same size as a pointer, which size_t is not certain to be. 
+ * The only fix here is VMS-specific.
+ */
+#if defined(OPENSSL_SYS_VMS)
+# if __INITIAL_POINTER_SIZE == 64
+#  define PTR_SIZE_INT long long
+# else /* __INITIAL_POINTER_SIZE == 64 */
+#  define PTR_SIZE_INT int
+# endif /* __INITIAL_POINTER_SIZE == 64 [else] */
+#else /* defined(OPENSSL_SYS_VMS) */
+# define PTR_SIZE_INT size_t
+#endif /* defined(OPENSSL_SYS_VMS) [else] */
+
+#define BN_DEFAULT_BITS	1280
+
+#define BN_FLG_MALLOCED		0x01
+#define BN_FLG_STATIC_DATA	0x02
+#define BN_FLG_CONSTTIME	0x04 /* avoid leaking exponent information through timing,
+                                      * BN_mod_exp_mont() will call BN_mod_exp_mont_consttime,
+                                      * BN_div() will call BN_div_no_branch,
+                                      * BN_mod_inverse() will call BN_mod_inverse_no_branch.
+                                      */
+
+#ifndef OPENSSL_NO_DEPRECATED
+#define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME /* deprecated name for the flag */
+                                      /* avoid leaking exponent information through timings
+                                      * (BN_mod_exp_mont() will call BN_mod_exp_mont_consttime) */
+#endif
+
+#ifndef OPENSSL_NO_DEPRECATED
+#define BN_FLG_FREE		0x8000	/* used for debuging */
+#endif
+#define BN_set_flags(b,n)	((b)->flags|=(n))
+#define BN_get_flags(b,n)	((b)->flags&(n))
+
+/* get a clone of a BIGNUM with changed flags, for *temporary* use only
+ * (the two BIGNUMs cannot not be used in parallel!) */
+#define BN_with_flags(dest,b,n)  ((dest)->d=(b)->d, \
+                                  (dest)->top=(b)->top, \
+                                  (dest)->dmax=(b)->dmax, \
+                                  (dest)->neg=(b)->neg, \
+                                  (dest)->flags=(((dest)->flags & BN_FLG_MALLOCED) \
+                                                 |  ((b)->flags & ~BN_FLG_MALLOCED) \
+                                                 |  BN_FLG_STATIC_DATA \
+                                                 |  (n)))
+
+/* Already declared in ossl_typ.h */
+#if 0
+typedef struct bignum_st BIGNUM;
+/* Used for temp variables (declaration hidden in bn_lcl.h) */
+typedef struct bignum_ctx BN_CTX;
+typedef struct bn_blinding_st BN_BLINDING;
+typedef struct bn_mont_ctx_st BN_MONT_CTX;
+typedef struct bn_recp_ctx_st BN_RECP_CTX;
+typedef struct bn_gencb_st BN_GENCB;
+#endif
+
+struct bignum_st
+	{
+	BN_ULONG *d;	/* Pointer to an array of 'BN_BITS2' bit chunks. */
+	int top;	/* Index of last used d +1. */
+	/* The next are internal book keeping for bn_expand. */
+	int dmax;	/* Size of the d array. */
+	int neg;	/* one if the number is negative */
+	int flags;
+	};
+
+/* Used for montgomery multiplication */
+struct bn_mont_ctx_st
+	{
+	int ri;        /* number of bits in R */
+	BIGNUM RR;     /* used to convert to montgomery form */
+	BIGNUM N;      /* The modulus */
+	BIGNUM Ni;     /* R*(1/R mod N) - N*Ni = 1
+	                * (Ni is only stored for bignum algorithm) */
+	BN_ULONG n0[2];/* least significant word(s) of Ni;
+	                  (type changed with 0.9.9, was "BN_ULONG n0;" before) */
+	int flags;
+	};
+
+/* Used for reciprocal division/mod functions
+ * It cannot be shared between threads
+ */
+struct bn_recp_ctx_st
+	{
+	BIGNUM N;	/* the divisor */
+	BIGNUM Nr;	/* the reciprocal */
+	int num_bits;
+	int shift;
+	int flags;
+	};
+
+/* Used for slow "generation" functions. */
+struct bn_gencb_st
+	{
+	unsigned int ver;	/* To handle binary (in)compatibility */
+	void *arg;		/* callback-specific data */
+	union
+		{
+		/* if(ver==1) - handles old style callbacks */
+		void (*cb_1)(int, int, void *);
+		/* if(ver==2) - new callback style */
+		int (*cb_2)(int, int, BN_GENCB *);
+		} cb;
+	};
+/* Wrapper function to make using BN_GENCB easier,  */
+int BN_GENCB_call(BN_GENCB *cb, int a, int b);
+/* Macro to populate a BN_GENCB structure with an "old"-style callback */
+#define BN_GENCB_set_old(gencb, callback, cb_arg) { \
+		BN_GENCB *tmp_gencb = (gencb); \
+		tmp_gencb->ver = 1; \
+		tmp_gencb->arg = (cb_arg); \
+		tmp_gencb->cb.cb_1 = (callback); }
+/* Macro to populate a BN_GENCB structure with a "new"-style callback */
+#define BN_GENCB_set(gencb, callback, cb_arg) { \
+		BN_GENCB *tmp_gencb = (gencb); \
+		tmp_gencb->ver = 2; \
+		tmp_gencb->arg = (cb_arg); \
+		tmp_gencb->cb.cb_2 = (callback); }
+
+#define BN_prime_checks 0 /* default: select number of iterations
+			     based on the size of the number */
+
+/* number of Miller-Rabin iterations for an error rate  of less than 2^-80
+ * for random 'b'-bit input, b >= 100 (taken from table 4.4 in the Handbook
+ * of Applied Cryptography [Menezes, van Oorschot, Vanstone; CRC Press 1996];
+ * original paper: Damgaard, Landrock, Pomerance: Average case error estimates
+ * for the strong probable prime test. -- Math. Comp. 61 (1993) 177-194) */
+#define BN_prime_checks_for_size(b) ((b) >= 1300 ?  2 : \
+                                (b) >=  850 ?  3 : \
+                                (b) >=  650 ?  4 : \
+                                (b) >=  550 ?  5 : \
+                                (b) >=  450 ?  6 : \
+                                (b) >=  400 ?  7 : \
+                                (b) >=  350 ?  8 : \
+                                (b) >=  300 ?  9 : \
+                                (b) >=  250 ? 12 : \
+                                (b) >=  200 ? 15 : \
+                                (b) >=  150 ? 18 : \
+                                /* b >= 100 */ 27)
+
+#define BN_num_bytes(a)	((BN_num_bits(a)+7)/8)
+
+/* Note that BN_abs_is_word didn't work reliably for w == 0 until 0.9.8 */
+#define BN_abs_is_word(a,w) ((((a)->top == 1) && ((a)->d[0] == (BN_ULONG)(w))) || \
+				(((w) == 0) && ((a)->top == 0)))
+#define BN_is_zero(a)       ((a)->top == 0)
+#define BN_is_one(a)        (BN_abs_is_word((a),1) && !(a)->neg)
+#define BN_is_word(a,w)     (BN_abs_is_word((a),(w)) && (!(w) || !(a)->neg))
+#define BN_is_odd(a)	    (((a)->top > 0) && ((a)->d[0] & 1))
+
+#define BN_one(a)	(BN_set_word((a),1))
+#define BN_zero_ex(a) \
+	do { \
+		BIGNUM *_tmp_bn = (a); \
+		_tmp_bn->top = 0; \
+		_tmp_bn->neg = 0; \
+	} while(0)
+#ifdef OPENSSL_NO_DEPRECATED
+#define BN_zero(a)	BN_zero_ex(a)
+#else
+#define BN_zero(a)	(BN_set_word((a),0))
+#endif
+
+const BIGNUM *BN_value_one(void);
+char *	BN_options(void);
+BN_CTX *BN_CTX_new(void);
+#ifndef OPENSSL_NO_DEPRECATED
+void	BN_CTX_init(BN_CTX *c);
+#endif
+void	BN_CTX_free(BN_CTX *c);
+void	BN_CTX_start(BN_CTX *ctx);
+BIGNUM *BN_CTX_get(BN_CTX *ctx);
+void	BN_CTX_end(BN_CTX *ctx);
+int     BN_rand(BIGNUM *rnd, int bits, int top,int bottom);
+int     BN_pseudo_rand(BIGNUM *rnd, int bits, int top,int bottom);
+int	BN_rand_range(BIGNUM *rnd, const BIGNUM *range);
+int	BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range);
+int	BN_num_bits(const BIGNUM *a);
+int	BN_num_bits_word(BN_ULONG);
+BIGNUM *BN_new(void);
+void	BN_init(BIGNUM *);
+void	BN_clear_free(BIGNUM *a);
+BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
+void	BN_swap(BIGNUM *a, BIGNUM *b);
+BIGNUM *BN_bin2bn(const unsigned char *s,int len,BIGNUM *ret);
+int	BN_bn2bin(const BIGNUM *a, unsigned char *to);
+BIGNUM *BN_mpi2bn(const unsigned char *s,int len,BIGNUM *ret);
+int	BN_bn2mpi(const BIGNUM *a, unsigned char *to);
+int	BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int	BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int	BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int	BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int	BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+int	BN_sqr(BIGNUM *r, const BIGNUM *a,BN_CTX *ctx);
+/** BN_set_negative sets sign of a BIGNUM
+ * \param  b  pointer to the BIGNUM object
+ * \param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise 
+ */
+void	BN_set_negative(BIGNUM *b, int n);
+/** BN_is_negative returns 1 if the BIGNUM is negative
+ * \param  a  pointer to the BIGNUM object
+ * \return 1 if a < 0 and 0 otherwise
+ */
+#define BN_is_negative(a) ((a)->neg != 0)
+
+int	BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
+	BN_CTX *ctx);
+#define BN_mod(rem,m,d,ctx) BN_div(NULL,(rem),(m),(d),(ctx))
+int	BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+int	BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m);
+int	BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m);
+int	BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m);
+int	BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m, BN_CTX *ctx);
+int	BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m);
+
+BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);
+BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);
+int	BN_mul_word(BIGNUM *a, BN_ULONG w);
+int	BN_add_word(BIGNUM *a, BN_ULONG w);
+int	BN_sub_word(BIGNUM *a, BN_ULONG w);
+int	BN_set_word(BIGNUM *a, BN_ULONG w);
+BN_ULONG BN_get_word(const BIGNUM *a);
+
+int	BN_cmp(const BIGNUM *a, const BIGNUM *b);
+void	BN_free(BIGNUM *a);
+int	BN_is_bit_set(const BIGNUM *a, int n);
+int	BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
+int	BN_lshift1(BIGNUM *r, const BIGNUM *a);
+int	BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,BN_CTX *ctx);
+
+int	BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	const BIGNUM *m,BN_CTX *ctx);
+int	BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
+	const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont);
+int	BN_mod_exp_mont_word(BIGNUM *r, BN_ULONG a, const BIGNUM *p,
+	const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+int	BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1,
+	const BIGNUM *a2, const BIGNUM *p2,const BIGNUM *m,
+	BN_CTX *ctx,BN_MONT_CTX *m_ctx);
+int	BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	const BIGNUM *m,BN_CTX *ctx);
+
+int	BN_mask_bits(BIGNUM *a,int n);
+#ifndef OPENSSL_NO_FP_API
+int	BN_print_fp(FILE *fp, const BIGNUM *a);
+#endif
+#ifdef HEADER_BIO_H
+int	BN_print(BIO *fp, const BIGNUM *a);
+#else
+int	BN_print(void *fp, const BIGNUM *a);
+#endif
+int	BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx);
+int	BN_rshift(BIGNUM *r, const BIGNUM *a, int n);
+int	BN_rshift1(BIGNUM *r, const BIGNUM *a);
+void	BN_clear(BIGNUM *a);
+BIGNUM *BN_dup(const BIGNUM *a);
+int	BN_ucmp(const BIGNUM *a, const BIGNUM *b);
+int	BN_set_bit(BIGNUM *a, int n);
+int	BN_clear_bit(BIGNUM *a, int n);
+char *	BN_bn2hex(const BIGNUM *a);
+char *	BN_bn2dec(const BIGNUM *a);
+int 	BN_hex2bn(BIGNUM **a, const char *str);
+int 	BN_dec2bn(BIGNUM **a, const char *str);
+int	BN_asc2bn(BIGNUM **a, const char *str);
+int	BN_gcd(BIGNUM *r,const BIGNUM *a,const BIGNUM *b,BN_CTX *ctx);
+int	BN_kronecker(const BIGNUM *a,const BIGNUM *b,BN_CTX *ctx); /* returns -2 for error */
+BIGNUM *BN_mod_inverse(BIGNUM *ret,
+	const BIGNUM *a, const BIGNUM *n,BN_CTX *ctx);
+BIGNUM *BN_mod_sqrt(BIGNUM *ret,
+	const BIGNUM *a, const BIGNUM *n,BN_CTX *ctx);
+
+void	BN_consttime_swap(BN_ULONG swap, BIGNUM *a, BIGNUM *b, int nwords);
+
+/* Deprecated versions */
+#ifndef OPENSSL_NO_DEPRECATED
+BIGNUM *BN_generate_prime(BIGNUM *ret,int bits,int safe,
+	const BIGNUM *add, const BIGNUM *rem,
+	void (*callback)(int,int,void *),void *cb_arg);
+int	BN_is_prime(const BIGNUM *p,int nchecks,
+	void (*callback)(int,int,void *),
+	BN_CTX *ctx,void *cb_arg);
+int	BN_is_prime_fasttest(const BIGNUM *p,int nchecks,
+	void (*callback)(int,int,void *),BN_CTX *ctx,void *cb_arg,
+	int do_trial_division);
+#endif /* !defined(OPENSSL_NO_DEPRECATED) */
+
+/* Newer versions */
+int	BN_generate_prime_ex(BIGNUM *ret,int bits,int safe, const BIGNUM *add,
+		const BIGNUM *rem, BN_GENCB *cb);
+int	BN_is_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb);
+int	BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx,
+		int do_trial_division, BN_GENCB *cb);
+
+int BN_X931_generate_Xpq(BIGNUM *Xp, BIGNUM *Xq, int nbits, BN_CTX *ctx);
+
+int BN_X931_derive_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,
+			const BIGNUM *Xp, const BIGNUM *Xp1, const BIGNUM *Xp2,
+			const BIGNUM *e, BN_CTX *ctx, BN_GENCB *cb);
+int BN_X931_generate_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,
+			BIGNUM *Xp1, BIGNUM *Xp2,
+			const BIGNUM *Xp,
+			const BIGNUM *e, BN_CTX *ctx,
+			BN_GENCB *cb);
+
+BN_MONT_CTX *BN_MONT_CTX_new(void );
+void BN_MONT_CTX_init(BN_MONT_CTX *ctx);
+int BN_mod_mul_montgomery(BIGNUM *r,const BIGNUM *a,const BIGNUM *b,
+	BN_MONT_CTX *mont, BN_CTX *ctx);
+#define BN_to_montgomery(r,a,mont,ctx)	BN_mod_mul_montgomery(\
+	(r),(a),&((mont)->RR),(mont),(ctx))
+int BN_from_montgomery(BIGNUM *r,const BIGNUM *a,
+	BN_MONT_CTX *mont, BN_CTX *ctx);
+void BN_MONT_CTX_free(BN_MONT_CTX *mont);
+int BN_MONT_CTX_set(BN_MONT_CTX *mont,const BIGNUM *mod,BN_CTX *ctx);
+BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to,BN_MONT_CTX *from);
+BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,
+					const BIGNUM *mod, BN_CTX *ctx);
+
+/* BN_BLINDING flags */
+#define	BN_BLINDING_NO_UPDATE	0x00000001
+#define	BN_BLINDING_NO_RECREATE	0x00000002
+
+BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod);
+void BN_BLINDING_free(BN_BLINDING *b);
+int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);
+int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
+int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
+int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *);
+int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b, BN_CTX *);
+#ifndef OPENSSL_NO_DEPRECATED
+unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);
+void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);
+#endif
+CRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);
+unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);
+void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);
+BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
+	const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,
+	int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+			  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),
+	BN_MONT_CTX *m_ctx);
+
+#ifndef OPENSSL_NO_DEPRECATED
+void BN_set_params(int mul,int high,int low,int mont);
+int BN_get_params(int which); /* 0, mul, 1 high, 2 low, 3 mont */
+#endif
+
+void	BN_RECP_CTX_init(BN_RECP_CTX *recp);
+BN_RECP_CTX *BN_RECP_CTX_new(void);
+void	BN_RECP_CTX_free(BN_RECP_CTX *recp);
+int	BN_RECP_CTX_set(BN_RECP_CTX *recp,const BIGNUM *rdiv,BN_CTX *ctx);
+int	BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,
+	BN_RECP_CTX *recp,BN_CTX *ctx);
+int	BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	const BIGNUM *m, BN_CTX *ctx);
+int	BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,
+	BN_RECP_CTX *recp, BN_CTX *ctx);
+
+#ifndef OPENSSL_NO_EC2M
+
+/* Functions for arithmetic over binary polynomials represented by BIGNUMs. 
+ *
+ * The BIGNUM::neg property of BIGNUMs representing binary polynomials is
+ * ignored.
+ *
+ * Note that input arguments are not const so that their bit arrays can
+ * be expanded to the appropriate size if needed.
+ */
+
+int	BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b); /*r = a + b*/
+#define BN_GF2m_sub(r, a, b) BN_GF2m_add(r, a, b)
+int	BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p); /*r=a mod p*/
+int	BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const BIGNUM *p, BN_CTX *ctx); /* r = (a * b) mod p */
+int	BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	BN_CTX *ctx); /* r = (a * a) mod p */
+int	BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *b, const BIGNUM *p,
+	BN_CTX *ctx); /* r = (1 / b) mod p */
+int	BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const BIGNUM *p, BN_CTX *ctx); /* r = (a / b) mod p */
+int	BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const BIGNUM *p, BN_CTX *ctx); /* r = (a ^ b) mod p */
+int	BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	BN_CTX *ctx); /* r = sqrt(a) mod p */
+int	BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+	BN_CTX *ctx); /* r^2 + r = a mod p */
+#define BN_GF2m_cmp(a, b) BN_ucmp((a), (b))
+/* Some functions allow for representation of the irreducible polynomials
+ * as an unsigned int[], say p.  The irreducible f(t) is then of the form:
+ *     t^p[0] + t^p[1] + ... + t^p[k]
+ * where m = p[0] > p[1] > ... > p[k] = 0.
+ */
+int	BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[]);
+	/* r = a mod p */
+int	BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const int p[], BN_CTX *ctx); /* r = (a * b) mod p */
+int	BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],
+	BN_CTX *ctx); /* r = (a * a) mod p */
+int	BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *b, const int p[],
+	BN_CTX *ctx); /* r = (1 / b) mod p */
+int	BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const int p[], BN_CTX *ctx); /* r = (a / b) mod p */
+int	BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+	const int p[], BN_CTX *ctx); /* r = (a ^ b) mod p */
+int	BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a,
+	const int p[], BN_CTX *ctx); /* r = sqrt(a) mod p */
+int	BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a,
+	const int p[], BN_CTX *ctx); /* r^2 + r = a mod p */
+int	BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max);
+int	BN_GF2m_arr2poly(const int p[], BIGNUM *a);
+
+#endif
+
+/* faster mod functions for the 'NIST primes' 
+ * 0 <= a < p^2 */
+int BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
+int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
+int BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
+int BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
+int BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
+
+const BIGNUM *BN_get0_nist_prime_192(void);
+const BIGNUM *BN_get0_nist_prime_224(void);
+const BIGNUM *BN_get0_nist_prime_256(void);
+const BIGNUM *BN_get0_nist_prime_384(void);
+const BIGNUM *BN_get0_nist_prime_521(void);
+
+/* library internal functions */
+
+#define bn_expand(a,bits) ((((((bits+BN_BITS2-1))/BN_BITS2)) <= (a)->dmax)?\
+	(a):bn_expand2((a),(bits+BN_BITS2-1)/BN_BITS2))
+#define bn_wexpand(a,words) (((words) <= (a)->dmax)?(a):bn_expand2((a),(words)))
+BIGNUM *bn_expand2(BIGNUM *a, int words);
+#ifndef OPENSSL_NO_DEPRECATED
+BIGNUM *bn_dup_expand(const BIGNUM *a, int words); /* unused */
+#endif
+
+/* Bignum consistency macros
+ * There is one "API" macro, bn_fix_top(), for stripping leading zeroes from
+ * bignum data after direct manipulations on the data. There is also an
+ * "internal" macro, bn_check_top(), for verifying that there are no leading
+ * zeroes. Unfortunately, some auditing is required due to the fact that
+ * bn_fix_top() has become an overabused duct-tape because bignum data is
+ * occasionally passed around in an inconsistent state. So the following
+ * changes have been made to sort this out;
+ * - bn_fix_top()s implementation has been moved to bn_correct_top()
+ * - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and
+ *   bn_check_top() is as before.
+ * - if BN_DEBUG *is* defined;
+ *   - bn_check_top() tries to pollute unused words even if the bignum 'top' is
+ *     consistent. (ed: only if BN_DEBUG_RAND is defined)
+ *   - bn_fix_top() maps to bn_check_top() rather than "fixing" anything.
+ * The idea is to have debug builds flag up inconsistent bignums when they
+ * occur. If that occurs in a bn_fix_top(), we examine the code in question; if
+ * the use of bn_fix_top() was appropriate (ie. it follows directly after code
+ * that manipulates the bignum) it is converted to bn_correct_top(), and if it
+ * was not appropriate, we convert it permanently to bn_check_top() and track
+ * down the cause of the bug. Eventually, no internal code should be using the
+ * bn_fix_top() macro. External applications and libraries should try this with
+ * their own code too, both in terms of building against the openssl headers
+ * with BN_DEBUG defined *and* linking with a version of OpenSSL built with it
+ * defined. This not only improves external code, it provides more test
+ * coverage for openssl's own code.
+ */
+
+#ifdef BN_DEBUG
+
+/* We only need assert() when debugging */
+#include <assert.h>
+
+#ifdef BN_DEBUG_RAND
+/* To avoid "make update" cvs wars due to BN_DEBUG, use some tricks */
+#ifndef RAND_pseudo_bytes
+int RAND_pseudo_bytes(unsigned char *buf,int num);
+#define BN_DEBUG_TRIX
+#endif
+#define bn_pollute(a) \
+	do { \
+		const BIGNUM *_bnum1 = (a); \
+		if(_bnum1->top < _bnum1->dmax) { \
+			unsigned char _tmp_char; \
+			/* We cast away const without the compiler knowing, any \
+			 * *genuinely* constant variables that aren't mutable \
+			 * wouldn't be constructed with top!=dmax. */ \
+			BN_ULONG *_not_const; \
+			memcpy(&_not_const, &_bnum1->d, sizeof(BN_ULONG*)); \
+			RAND_pseudo_bytes(&_tmp_char, 1); \
+			memset((unsigned char *)(_not_const + _bnum1->top), _tmp_char, \
+				(_bnum1->dmax - _bnum1->top) * sizeof(BN_ULONG)); \
+		} \
+	} while(0)
+#ifdef BN_DEBUG_TRIX
+#undef RAND_pseudo_bytes
+#endif
+#else
+#define bn_pollute(a)
+#endif
+#define bn_check_top(a) \
+	do { \
+		const BIGNUM *_bnum2 = (a); \
+		if (_bnum2 != NULL) { \
+			assert((_bnum2->top == 0) || \
+				(_bnum2->d[_bnum2->top - 1] != 0)); \
+			bn_pollute(_bnum2); \
+		} \
+	} while(0)
+
+#define bn_fix_top(a)		bn_check_top(a)
+
+#define bn_check_size(bn, bits) bn_wcheck_size(bn, ((bits+BN_BITS2-1))/BN_BITS2)
+#define bn_wcheck_size(bn, words) \
+	do { \
+		const BIGNUM *_bnum2 = (bn); \
+		assert(words <= (_bnum2)->dmax && words >= (_bnum2)->top); \
+	} while(0)
+
+#else /* !BN_DEBUG */
+
+#define bn_pollute(a)
+#define bn_check_top(a)
+#define bn_fix_top(a)		bn_correct_top(a)
+#define bn_check_size(bn, bits)
+#define bn_wcheck_size(bn, words)
+
+#endif
+
+#define bn_correct_top(a) \
+        { \
+        BN_ULONG *ftl; \
+	int tmp_top = (a)->top; \
+	if (tmp_top > 0) \
+		{ \
+		for (ftl= &((a)->d[tmp_top-1]); tmp_top > 0; tmp_top--) \
+			if (*(ftl--)) break; \
+		(a)->top = tmp_top; \
+		} \
+	bn_pollute(a); \
+	}
+
+BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w);
+BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w);
+void     bn_sqr_words(BN_ULONG *rp, const BN_ULONG *ap, int num);
+BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
+BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,int num);
+BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,int num);
+
+/* Primes from RFC 2409 */
+BIGNUM *get_rfc2409_prime_768(BIGNUM *bn);
+BIGNUM *get_rfc2409_prime_1024(BIGNUM *bn);
+
+/* Primes from RFC 3526 */
+BIGNUM *get_rfc3526_prime_1536(BIGNUM *bn);
+BIGNUM *get_rfc3526_prime_2048(BIGNUM *bn);
+BIGNUM *get_rfc3526_prime_3072(BIGNUM *bn);
+BIGNUM *get_rfc3526_prime_4096(BIGNUM *bn);
+BIGNUM *get_rfc3526_prime_6144(BIGNUM *bn);
+BIGNUM *get_rfc3526_prime_8192(BIGNUM *bn);
+
+int BN_bntest_rand(BIGNUM *rnd, int bits, int top,int bottom);
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_BN_strings(void);
+
+/* Error codes for the BN functions. */
+
+/* Function codes. */
+#define BN_F_BNRAND					 127
+#define BN_F_BN_BLINDING_CONVERT_EX			 100
+#define BN_F_BN_BLINDING_CREATE_PARAM			 128
+#define BN_F_BN_BLINDING_INVERT_EX			 101
+#define BN_F_BN_BLINDING_NEW				 102
+#define BN_F_BN_BLINDING_UPDATE				 103
+#define BN_F_BN_BN2DEC					 104
+#define BN_F_BN_BN2HEX					 105
+#define BN_F_BN_CTX_GET					 116
+#define BN_F_BN_CTX_NEW					 106
+#define BN_F_BN_CTX_START				 129
+#define BN_F_BN_DIV					 107
+#define BN_F_BN_DIV_NO_BRANCH				 138
+#define BN_F_BN_DIV_RECP				 130
+#define BN_F_BN_EXP					 123
+#define BN_F_BN_EXPAND2					 108
+#define BN_F_BN_EXPAND_INTERNAL				 120
+#define BN_F_BN_GF2M_MOD				 131
+#define BN_F_BN_GF2M_MOD_EXP				 132
+#define BN_F_BN_GF2M_MOD_MUL				 133
+#define BN_F_BN_GF2M_MOD_SOLVE_QUAD			 134
+#define BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR			 135
+#define BN_F_BN_GF2M_MOD_SQR				 136
+#define BN_F_BN_GF2M_MOD_SQRT				 137
+#define BN_F_BN_MOD_EXP2_MONT				 118
+#define BN_F_BN_MOD_EXP_MONT				 109
+#define BN_F_BN_MOD_EXP_MONT_CONSTTIME			 124
+#define BN_F_BN_MOD_EXP_MONT_WORD			 117
+#define BN_F_BN_MOD_EXP_RECP				 125
+#define BN_F_BN_MOD_EXP_SIMPLE				 126
+#define BN_F_BN_MOD_INVERSE				 110
+#define BN_F_BN_MOD_INVERSE_NO_BRANCH			 139
+#define BN_F_BN_MOD_LSHIFT_QUICK			 119
+#define BN_F_BN_MOD_MUL_RECIPROCAL			 111
+#define BN_F_BN_MOD_SQRT				 121
+#define BN_F_BN_MPI2BN					 112
+#define BN_F_BN_NEW					 113
+#define BN_F_BN_RAND					 114
+#define BN_F_BN_RAND_RANGE				 122
+#define BN_F_BN_USUB					 115
+
+/* Reason codes. */
+#define BN_R_ARG2_LT_ARG3				 100
+#define BN_R_BAD_RECIPROCAL				 101
+#define BN_R_BIGNUM_TOO_LONG				 114
+#define BN_R_CALLED_WITH_EVEN_MODULUS			 102
+#define BN_R_DIV_BY_ZERO				 103
+#define BN_R_ENCODING_ERROR				 104
+#define BN_R_EXPAND_ON_STATIC_BIGNUM_DATA		 105
+#define BN_R_INPUT_NOT_REDUCED				 110
+#define BN_R_INVALID_LENGTH				 106
+#define BN_R_INVALID_RANGE				 115
+#define BN_R_NOT_A_SQUARE				 111
+#define BN_R_NOT_INITIALIZED				 107
+#define BN_R_NO_INVERSE					 108
+#define BN_R_NO_SOLUTION				 116
+#define BN_R_P_IS_NOT_PRIME				 112
+#define BN_R_TOO_MANY_ITERATIONS			 113
+#define BN_R_TOO_MANY_TEMPORARY_VARIABLES		 109
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Nur tools-org/vboot_utils/src/host/include/openssl/evp.h tools/vboot_utils/src/host/include/openssl/evp.h
--- tools-org/vboot_utils/src/host/include/openssl/evp.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/include/openssl/evp.h	2014-04-27 13:03:45.772118330 +0000
@@ -0,0 +1,1402 @@
+/* crypto/evp/evp.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_ENVELOPE_H
+#define HEADER_ENVELOPE_H
+
+#ifdef OPENSSL_ALGORITHM_DEFINES
+# include <openssl/opensslconf.h>
+#else
+# define OPENSSL_ALGORITHM_DEFINES
+# include <openssl/opensslconf.h>
+# undef OPENSSL_ALGORITHM_DEFINES
+#endif
+
+#include <openssl/ossl_typ.h>
+
+#include <openssl/symhacks.h>
+
+#ifndef OPENSSL_NO_BIO
+#include <openssl/bio.h>
+#endif
+
+/*
+#define EVP_RC2_KEY_SIZE		16
+#define EVP_RC4_KEY_SIZE		16
+#define EVP_BLOWFISH_KEY_SIZE		16
+#define EVP_CAST5_KEY_SIZE		16
+#define EVP_RC5_32_12_16_KEY_SIZE	16
+*/
+#define EVP_MAX_MD_SIZE			64	/* longest known is SHA512 */
+#define EVP_MAX_KEY_LENGTH		64
+#define EVP_MAX_IV_LENGTH		16
+#define EVP_MAX_BLOCK_LENGTH		32
+
+#define PKCS5_SALT_LEN			8
+/* Default PKCS#5 iteration count */
+#define PKCS5_DEFAULT_ITER		2048
+
+#include <openssl/objects.h>
+
+#define EVP_PK_RSA	0x0001
+#define EVP_PK_DSA	0x0002
+#define EVP_PK_DH	0x0004
+#define EVP_PK_EC	0x0008
+#define EVP_PKT_SIGN	0x0010
+#define EVP_PKT_ENC	0x0020
+#define EVP_PKT_EXCH	0x0040
+#define EVP_PKS_RSA	0x0100
+#define EVP_PKS_DSA	0x0200
+#define EVP_PKS_EC	0x0400
+#define EVP_PKT_EXP	0x1000 /* <= 512 bit key */
+
+#define EVP_PKEY_NONE	NID_undef
+#define EVP_PKEY_RSA	NID_rsaEncryption
+#define EVP_PKEY_RSA2	NID_rsa
+#define EVP_PKEY_DSA	NID_dsa
+#define EVP_PKEY_DSA1	NID_dsa_2
+#define EVP_PKEY_DSA2	NID_dsaWithSHA
+#define EVP_PKEY_DSA3	NID_dsaWithSHA1
+#define EVP_PKEY_DSA4	NID_dsaWithSHA1_2
+#define EVP_PKEY_DH	NID_dhKeyAgreement
+#define EVP_PKEY_EC	NID_X9_62_id_ecPublicKey
+#define EVP_PKEY_HMAC	NID_hmac
+#define EVP_PKEY_CMAC	NID_cmac
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Type needs to be a bit field
+ * Sub-type needs to be for variations on the method, as in, can it do
+ * arbitrary encryption.... */
+struct evp_pkey_st
+	{
+	int type;
+	int save_type;
+	int references;
+	const EVP_PKEY_ASN1_METHOD *ameth;
+	ENGINE *engine;
+	union	{
+		char *ptr;
+#ifndef OPENSSL_NO_RSA
+		struct rsa_st *rsa;	/* RSA */
+#endif
+#ifndef OPENSSL_NO_DSA
+		struct dsa_st *dsa;	/* DSA */
+#endif
+#ifndef OPENSSL_NO_DH
+		struct dh_st *dh;	/* DH */
+#endif
+#ifndef OPENSSL_NO_EC
+		struct ec_key_st *ec;	/* ECC */
+#endif
+		} pkey;
+	int save_parameters;
+	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
+	} /* EVP_PKEY */;
+
+#define EVP_PKEY_MO_SIGN	0x0001
+#define EVP_PKEY_MO_VERIFY	0x0002
+#define EVP_PKEY_MO_ENCRYPT	0x0004
+#define EVP_PKEY_MO_DECRYPT	0x0008
+
+#ifndef EVP_MD
+struct env_md_st
+	{
+	int type;
+	int pkey_type;
+	int md_size;
+	unsigned long flags;
+	int (*init)(EVP_MD_CTX *ctx);
+	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
+	int (*final)(EVP_MD_CTX *ctx,unsigned char *md);
+	int (*copy)(EVP_MD_CTX *to,const EVP_MD_CTX *from);
+	int (*cleanup)(EVP_MD_CTX *ctx);
+
+	/* FIXME: prototype these some day */
+	int (*sign)(int type, const unsigned char *m, unsigned int m_length,
+		    unsigned char *sigret, unsigned int *siglen, void *key);
+	int (*verify)(int type, const unsigned char *m, unsigned int m_length,
+		      const unsigned char *sigbuf, unsigned int siglen,
+		      void *key);
+	int required_pkey_type[5]; /*EVP_PKEY_xxx */
+	int block_size;
+	int ctx_size; /* how big does the ctx->md_data need to be */
+	/* control function */
+	int (*md_ctrl)(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
+	} /* EVP_MD */;
+
+typedef int evp_sign_method(int type,const unsigned char *m,
+			    unsigned int m_length,unsigned char *sigret,
+			    unsigned int *siglen, void *key);
+typedef int evp_verify_method(int type,const unsigned char *m,
+			    unsigned int m_length,const unsigned char *sigbuf,
+			    unsigned int siglen, void *key);
+
+#define EVP_MD_FLAG_ONESHOT	0x0001 /* digest can only handle a single
+					* block */
+
+#define EVP_MD_FLAG_PKEY_DIGEST	0x0002 /* digest is a "clone" digest used
+					* which is a copy of an existing
+					* one for a specific public key type.
+					* EVP_dss1() etc */
+
+/* Digest uses EVP_PKEY_METHOD for signing instead of MD specific signing */
+
+#define EVP_MD_FLAG_PKEY_METHOD_SIGNATURE	0x0004
+
+/* DigestAlgorithmIdentifier flags... */
+
+#define EVP_MD_FLAG_DIGALGID_MASK		0x0018
+
+/* NULL or absent parameter accepted. Use NULL */
+
+#define EVP_MD_FLAG_DIGALGID_NULL		0x0000
+
+/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */
+
+#define EVP_MD_FLAG_DIGALGID_ABSENT		0x0008
+
+/* Custom handling via ctrl */
+
+#define EVP_MD_FLAG_DIGALGID_CUSTOM		0x0018
+
+#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */
+
+/* Digest ctrls */
+
+#define	EVP_MD_CTRL_DIGALGID			0x1
+#define	EVP_MD_CTRL_MICALG			0x2
+
+/* Minimum Algorithm specific ctrl value */
+
+#define	EVP_MD_CTRL_ALG_CTRL			0x1000
+
+#define EVP_PKEY_NULL_method	NULL,NULL,{0,0,0,0}
+
+#ifndef OPENSSL_NO_DSA
+#define EVP_PKEY_DSA_method	(evp_sign_method *)DSA_sign, \
+				(evp_verify_method *)DSA_verify, \
+				{EVP_PKEY_DSA,EVP_PKEY_DSA2,EVP_PKEY_DSA3, \
+					EVP_PKEY_DSA4,0}
+#else
+#define EVP_PKEY_DSA_method	EVP_PKEY_NULL_method
+#endif
+
+#ifndef OPENSSL_NO_ECDSA
+#define EVP_PKEY_ECDSA_method   (evp_sign_method *)ECDSA_sign, \
+				(evp_verify_method *)ECDSA_verify, \
+                                 {EVP_PKEY_EC,0,0,0}
+#else   
+#define EVP_PKEY_ECDSA_method   EVP_PKEY_NULL_method
+#endif
+
+#ifndef OPENSSL_NO_RSA
+#define EVP_PKEY_RSA_method	(evp_sign_method *)RSA_sign, \
+				(evp_verify_method *)RSA_verify, \
+				{EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}
+#define EVP_PKEY_RSA_ASN1_OCTET_STRING_method \
+				(evp_sign_method *)RSA_sign_ASN1_OCTET_STRING, \
+				(evp_verify_method *)RSA_verify_ASN1_OCTET_STRING, \
+				{EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}
+#else
+#define EVP_PKEY_RSA_method	EVP_PKEY_NULL_method
+#define EVP_PKEY_RSA_ASN1_OCTET_STRING_method EVP_PKEY_NULL_method
+#endif
+
+#endif /* !EVP_MD */
+
+struct env_md_ctx_st
+	{
+	const EVP_MD *digest;
+	ENGINE *engine; /* functional reference if 'digest' is ENGINE-provided */
+	unsigned long flags;
+	void *md_data;
+	/* Public key context for sign/verify */
+	EVP_PKEY_CTX *pctx;
+	/* Update function: usually copied from EVP_MD */
+	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
+	} /* EVP_MD_CTX */;
+
+/* values for EVP_MD_CTX flags */
+
+#define EVP_MD_CTX_FLAG_ONESHOT		0x0001 /* digest update will be called
+						* once only */
+#define EVP_MD_CTX_FLAG_CLEANED		0x0002 /* context has already been
+						* cleaned */
+#define EVP_MD_CTX_FLAG_REUSE		0x0004 /* Don't free up ctx->md_data
+						* in EVP_MD_CTX_cleanup */
+/* FIPS and pad options are ignored in 1.0.0, definitions are here
+ * so we don't accidentally reuse the values for other purposes.
+ */
+
+#define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW	0x0008	/* Allow use of non FIPS digest
+						 * in FIPS mode */
+
+/* The following PAD options are also currently ignored in 1.0.0, digest
+ * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()
+ * instead.
+ */
+#define EVP_MD_CTX_FLAG_PAD_MASK	0xF0	/* RSA mode to use */
+#define EVP_MD_CTX_FLAG_PAD_PKCS1	0x00	/* PKCS#1 v1.5 mode */
+#define EVP_MD_CTX_FLAG_PAD_X931	0x10	/* X9.31 mode */
+#define EVP_MD_CTX_FLAG_PAD_PSS		0x20	/* PSS mode */
+
+#define EVP_MD_CTX_FLAG_NO_INIT		0x0100 /* Don't initialize md_data */
+
+struct evp_cipher_st
+	{
+	int nid;
+	int block_size;
+	int key_len;		/* Default value for variable length ciphers */
+	int iv_len;
+	unsigned long flags;	/* Various flags */
+	int (*init)(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+		    const unsigned char *iv, int enc);	/* init key */
+	int (*do_cipher)(EVP_CIPHER_CTX *ctx, unsigned char *out,
+			 const unsigned char *in, size_t inl);/* encrypt/decrypt data */
+	int (*cleanup)(EVP_CIPHER_CTX *); /* cleanup ctx */
+	int ctx_size;		/* how big ctx->cipher_data needs to be */
+	int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Populate a ASN1_TYPE with parameters */
+	int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */
+	int (*ctrl)(EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Miscellaneous operations */
+	void *app_data;		/* Application data */
+	} /* EVP_CIPHER */;
+
+/* Values for cipher flags */
+
+/* Modes for ciphers */
+
+#define		EVP_CIPH_STREAM_CIPHER		0x0
+#define		EVP_CIPH_ECB_MODE		0x1
+#define		EVP_CIPH_CBC_MODE		0x2
+#define		EVP_CIPH_CFB_MODE		0x3
+#define		EVP_CIPH_OFB_MODE		0x4
+#define		EVP_CIPH_CTR_MODE		0x5
+#define		EVP_CIPH_GCM_MODE		0x6
+#define		EVP_CIPH_CCM_MODE		0x7
+#define		EVP_CIPH_XTS_MODE		0x10001
+#define 	EVP_CIPH_MODE			0xF0007
+/* Set if variable length cipher */
+#define 	EVP_CIPH_VARIABLE_LENGTH	0x8
+/* Set if the iv handling should be done by the cipher itself */
+#define 	EVP_CIPH_CUSTOM_IV		0x10
+/* Set if the cipher's init() function should be called if key is NULL */
+#define 	EVP_CIPH_ALWAYS_CALL_INIT	0x20
+/* Call ctrl() to init cipher parameters */
+#define 	EVP_CIPH_CTRL_INIT		0x40
+/* Don't use standard key length function */
+#define 	EVP_CIPH_CUSTOM_KEY_LENGTH	0x80
+/* Don't use standard block padding */
+#define 	EVP_CIPH_NO_PADDING		0x100
+/* cipher handles random key generation */
+#define 	EVP_CIPH_RAND_KEY		0x200
+/* cipher has its own additional copying logic */
+#define 	EVP_CIPH_CUSTOM_COPY		0x400
+/* Allow use default ASN1 get/set iv */
+#define		EVP_CIPH_FLAG_DEFAULT_ASN1	0x1000
+/* Buffer length in bits not bytes: CFB1 mode only */
+#define		EVP_CIPH_FLAG_LENGTH_BITS	0x2000
+/* Note if suitable for use in FIPS mode */
+#define		EVP_CIPH_FLAG_FIPS		0x4000
+/* Allow non FIPS cipher in FIPS mode */
+#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x8000
+/* Cipher handles any and all padding logic as well
+ * as finalisation.
+ */
+#define 	EVP_CIPH_FLAG_CUSTOM_CIPHER	0x100000
+#define		EVP_CIPH_FLAG_AEAD_CIPHER	0x200000
+
+/* ctrl() values */
+
+#define		EVP_CTRL_INIT			0x0
+#define 	EVP_CTRL_SET_KEY_LENGTH		0x1
+#define 	EVP_CTRL_GET_RC2_KEY_BITS	0x2
+#define 	EVP_CTRL_SET_RC2_KEY_BITS	0x3
+#define 	EVP_CTRL_GET_RC5_ROUNDS		0x4
+#define 	EVP_CTRL_SET_RC5_ROUNDS		0x5
+#define 	EVP_CTRL_RAND_KEY		0x6
+#define 	EVP_CTRL_PBE_PRF_NID		0x7
+#define 	EVP_CTRL_COPY			0x8
+#define 	EVP_CTRL_GCM_SET_IVLEN		0x9
+#define 	EVP_CTRL_GCM_GET_TAG		0x10
+#define 	EVP_CTRL_GCM_SET_TAG		0x11
+#define		EVP_CTRL_GCM_SET_IV_FIXED	0x12
+#define		EVP_CTRL_GCM_IV_GEN		0x13
+#define		EVP_CTRL_CCM_SET_IVLEN		EVP_CTRL_GCM_SET_IVLEN
+#define		EVP_CTRL_CCM_GET_TAG		EVP_CTRL_GCM_GET_TAG
+#define		EVP_CTRL_CCM_SET_TAG		EVP_CTRL_GCM_SET_TAG
+#define		EVP_CTRL_CCM_SET_L		0x14
+#define		EVP_CTRL_CCM_SET_MSGLEN		0x15
+/* AEAD cipher deduces payload length and returns number of bytes
+ * required to store MAC and eventual padding. Subsequent call to
+ * EVP_Cipher even appends/verifies MAC.
+ */
+#define		EVP_CTRL_AEAD_TLS1_AAD		0x16
+/* Used by composite AEAD ciphers, no-op in GCM, CCM... */
+#define		EVP_CTRL_AEAD_SET_MAC_KEY	0x17
+/* Set the GCM invocation field, decrypt only */
+#define		EVP_CTRL_GCM_SET_IV_INV		0x18
+
+/* GCM TLS constants */
+/* Length of fixed part of IV derived from PRF */
+#define EVP_GCM_TLS_FIXED_IV_LEN			4
+/* Length of explicit part of IV part of TLS records */
+#define EVP_GCM_TLS_EXPLICIT_IV_LEN			8
+/* Length of tag for TLS */
+#define EVP_GCM_TLS_TAG_LEN				16
+
+
+typedef struct evp_cipher_info_st
+	{
+	const EVP_CIPHER *cipher;
+	unsigned char iv[EVP_MAX_IV_LENGTH];
+	} EVP_CIPHER_INFO;
+
+struct evp_cipher_ctx_st
+	{
+	const EVP_CIPHER *cipher;
+	ENGINE *engine;	/* functional reference if 'cipher' is ENGINE-provided */
+	int encrypt;		/* encrypt or decrypt */
+	int buf_len;		/* number we have left */
+
+	unsigned char  oiv[EVP_MAX_IV_LENGTH];	/* original iv */
+	unsigned char  iv[EVP_MAX_IV_LENGTH];	/* working iv */
+	unsigned char buf[EVP_MAX_BLOCK_LENGTH];/* saved partial block */
+	int num;				/* used by cfb/ofb/ctr mode */
+
+	void *app_data;		/* application stuff */
+	int key_len;		/* May change for variable length cipher */
+	unsigned long flags;	/* Various flags */
+	void *cipher_data; /* per EVP data */
+	int final_used;
+	int block_mask;
+	unsigned char final[EVP_MAX_BLOCK_LENGTH];/* possible final block */
+	} /* EVP_CIPHER_CTX */;
+
+typedef struct evp_Encode_Ctx_st
+	{
+	int num;	/* number saved in a partial encode/decode */
+	int length;	/* The length is either the output line length
+			 * (in input bytes) or the shortest input line
+			 * length that is ok.  Once decoding begins,
+			 * the length is adjusted up each time a longer
+			 * line is decoded */
+	unsigned char enc_data[80];	/* data to encode */
+	int line_num;	/* number read on current line */
+	int expect_nl;
+	} EVP_ENCODE_CTX;
+
+/* Password based encryption function */
+typedef int (EVP_PBE_KEYGEN)(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+		ASN1_TYPE *param, const EVP_CIPHER *cipher,
+                const EVP_MD *md, int en_de);
+
+#ifndef OPENSSL_NO_RSA
+#define EVP_PKEY_assign_RSA(pkey,rsa) EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\
+					(char *)(rsa))
+#endif
+
+#ifndef OPENSSL_NO_DSA
+#define EVP_PKEY_assign_DSA(pkey,dsa) EVP_PKEY_assign((pkey),EVP_PKEY_DSA,\
+					(char *)(dsa))
+#endif
+
+#ifndef OPENSSL_NO_DH
+#define EVP_PKEY_assign_DH(pkey,dh) EVP_PKEY_assign((pkey),EVP_PKEY_DH,\
+					(char *)(dh))
+#endif
+
+#ifndef OPENSSL_NO_EC
+#define EVP_PKEY_assign_EC_KEY(pkey,eckey) EVP_PKEY_assign((pkey),EVP_PKEY_EC,\
+                                        (char *)(eckey))
+#endif
+
+/* Add some extra combinations */
+#define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))
+#define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))
+#define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
+#define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
+
+int EVP_MD_type(const EVP_MD *md);
+#define EVP_MD_nid(e)			EVP_MD_type(e)
+#define EVP_MD_name(e)			OBJ_nid2sn(EVP_MD_nid(e))
+int EVP_MD_pkey_type(const EVP_MD *md);	
+int EVP_MD_size(const EVP_MD *md);
+int EVP_MD_block_size(const EVP_MD *md);
+unsigned long EVP_MD_flags(const EVP_MD *md);
+
+const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
+#define EVP_MD_CTX_size(e)		EVP_MD_size(EVP_MD_CTX_md(e))
+#define EVP_MD_CTX_block_size(e)	EVP_MD_block_size(EVP_MD_CTX_md(e))
+#define EVP_MD_CTX_type(e)		EVP_MD_type(EVP_MD_CTX_md(e))
+
+int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
+#define EVP_CIPHER_name(e)		OBJ_nid2sn(EVP_CIPHER_nid(e))
+int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
+int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
+int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
+unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
+#define EVP_CIPHER_mode(e)		(EVP_CIPHER_flags(e) & EVP_CIPH_MODE)
+
+const EVP_CIPHER * EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
+void * EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
+void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);
+#define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
+unsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);
+#define EVP_CIPHER_CTX_mode(e)		(EVP_CIPHER_CTX_flags(e) & EVP_CIPH_MODE)
+
+#define EVP_ENCODE_LENGTH(l)	(((l+2)/3*4)+(l/48+1)*2+80)
+#define EVP_DECODE_LENGTH(l)	((l+3)/4*3+80)
+
+#define EVP_SignInit_ex(a,b,c)		EVP_DigestInit_ex(a,b,c)
+#define EVP_SignInit(a,b)		EVP_DigestInit(a,b)
+#define EVP_SignUpdate(a,b,c)		EVP_DigestUpdate(a,b,c)
+#define	EVP_VerifyInit_ex(a,b,c)	EVP_DigestInit_ex(a,b,c)
+#define	EVP_VerifyInit(a,b)		EVP_DigestInit(a,b)
+#define	EVP_VerifyUpdate(a,b,c)		EVP_DigestUpdate(a,b,c)
+#define EVP_OpenUpdate(a,b,c,d,e)	EVP_DecryptUpdate(a,b,c,d,e)
+#define EVP_SealUpdate(a,b,c,d,e)	EVP_EncryptUpdate(a,b,c,d,e)	
+#define EVP_DigestSignUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)
+#define EVP_DigestVerifyUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)
+
+#ifdef CONST_STRICT
+void BIO_set_md(BIO *,const EVP_MD *md);
+#else
+# define BIO_set_md(b,md)		BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)
+#endif
+#define BIO_get_md(b,mdp)		BIO_ctrl(b,BIO_C_GET_MD,0,(char *)mdp)
+#define BIO_get_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_GET_MD_CTX,0,(char *)mdcp)
+#define BIO_set_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_SET_MD_CTX,0,(char *)mdcp)
+#define BIO_get_cipher_status(b)	BIO_ctrl(b,BIO_C_GET_CIPHER_STATUS,0,NULL)
+#define BIO_get_cipher_ctx(b,c_pp)	BIO_ctrl(b,BIO_C_GET_CIPHER_CTX,0,(char *)c_pp)
+
+int EVP_Cipher(EVP_CIPHER_CTX *c,
+		unsigned char *out,
+		const unsigned char *in,
+		unsigned int inl);
+
+#define EVP_add_cipher_alias(n,alias) \
+	OBJ_NAME_add((alias),OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS,(n))
+#define EVP_add_digest_alias(n,alias) \
+	OBJ_NAME_add((alias),OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,(n))
+#define EVP_delete_cipher_alias(alias) \
+	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS);
+#define EVP_delete_digest_alias(alias) \
+	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS);
+
+void	EVP_MD_CTX_init(EVP_MD_CTX *ctx);
+int	EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
+EVP_MD_CTX *EVP_MD_CTX_create(void);
+void	EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
+int     EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
+void	EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
+void	EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
+int 	EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx,int flags);
+int	EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
+int	EVP_DigestUpdate(EVP_MD_CTX *ctx,const void *d,
+			 size_t cnt);
+int	EVP_DigestFinal_ex(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
+int	EVP_Digest(const void *data, size_t count,
+		unsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl);
+
+int     EVP_MD_CTX_copy(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
+int	EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
+int	EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
+
+int	EVP_read_pw_string(char *buf,int length,const char *prompt,int verify);
+int	EVP_read_pw_string_min(char *buf,int minlen,int maxlen,const char *prompt,int verify);
+void	EVP_set_pw_prompt(const char *prompt);
+char *	EVP_get_pw_prompt(void);
+
+int	EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
+		const unsigned char *salt, const unsigned char *data,
+		int datal, int count, unsigned char *key,unsigned char *iv);
+
+void	EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
+void	EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
+int 	EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx,int flags);
+
+int	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
+		const unsigned char *key, const unsigned char *iv);
+int	EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
+		const unsigned char *key, const unsigned char *iv);
+int	EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
+		int *outl, const unsigned char *in, int inl);
+int	EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
+int	EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
+
+int	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
+		const unsigned char *key, const unsigned char *iv);
+int	EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
+		const unsigned char *key, const unsigned char *iv);
+int	EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
+		int *outl, const unsigned char *in, int inl);
+int	EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
+int	EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
+
+int	EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
+		       const unsigned char *key,const unsigned char *iv,
+		       int enc);
+int	EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
+		       const unsigned char *key,const unsigned char *iv,
+		       int enc);
+int	EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
+		int *outl, const unsigned char *in, int inl);
+int	EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
+int	EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
+
+int	EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s,
+		EVP_PKEY *pkey);
+
+int	EVP_VerifyFinal(EVP_MD_CTX *ctx,const unsigned char *sigbuf,
+		unsigned int siglen,EVP_PKEY *pkey);
+
+int	EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
+int	EVP_DigestSignFinal(EVP_MD_CTX *ctx,
+			unsigned char *sigret, size_t *siglen);
+
+int	EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
+int	EVP_DigestVerifyFinal(EVP_MD_CTX *ctx,
+			unsigned char *sig, size_t siglen);
+
+int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
+		const unsigned char *ek, int ekl, const unsigned char *iv,
+		EVP_PKEY *priv);
+int	EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
+
+int	EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
+		 unsigned char **ek, int *ekl, unsigned char *iv,
+		EVP_PKEY **pubk, int npubk);
+int	EVP_SealFinal(EVP_CIPHER_CTX *ctx,unsigned char *out,int *outl);
+
+void	EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
+void	EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
+		const unsigned char *in,int inl);
+void	EVP_EncodeFinal(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl);
+int	EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);
+
+void	EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
+int	EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
+		const unsigned char *in, int inl);
+int	EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned
+		char *out, int *outl);
+int	EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);
+
+void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
+int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
+EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
+void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);
+int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
+int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
+int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
+int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);
+
+#ifndef OPENSSL_NO_BIO
+BIO_METHOD *BIO_f_md(void);
+BIO_METHOD *BIO_f_base64(void);
+BIO_METHOD *BIO_f_cipher(void);
+BIO_METHOD *BIO_f_reliable(void);
+void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,const unsigned char *k,
+		const unsigned char *i, int enc);
+#endif
+
+const EVP_MD *EVP_md_null(void);
+#ifndef OPENSSL_NO_MD2
+const EVP_MD *EVP_md2(void);
+#endif
+#ifndef OPENSSL_NO_MD4
+const EVP_MD *EVP_md4(void);
+#endif
+#ifndef OPENSSL_NO_MD5
+const EVP_MD *EVP_md5(void);
+#endif
+#ifndef OPENSSL_NO_SHA
+const EVP_MD *EVP_sha(void);
+const EVP_MD *EVP_sha1(void);
+const EVP_MD *EVP_dss(void);
+const EVP_MD *EVP_dss1(void);
+const EVP_MD *EVP_ecdsa(void);
+#endif
+#ifndef OPENSSL_NO_SHA256
+const EVP_MD *EVP_sha224(void);
+const EVP_MD *EVP_sha256(void);
+#endif
+#ifndef OPENSSL_NO_SHA512
+const EVP_MD *EVP_sha384(void);
+const EVP_MD *EVP_sha512(void);
+#endif
+#ifndef OPENSSL_NO_MDC2
+const EVP_MD *EVP_mdc2(void);
+#endif
+#ifndef OPENSSL_NO_RIPEMD
+const EVP_MD *EVP_ripemd160(void);
+#endif
+#ifndef OPENSSL_NO_WHIRLPOOL
+const EVP_MD *EVP_whirlpool(void);
+#endif
+const EVP_CIPHER *EVP_enc_null(void);		/* does nothing :-) */
+#ifndef OPENSSL_NO_DES
+const EVP_CIPHER *EVP_des_ecb(void);
+const EVP_CIPHER *EVP_des_ede(void);
+const EVP_CIPHER *EVP_des_ede3(void);
+const EVP_CIPHER *EVP_des_ede_ecb(void);
+const EVP_CIPHER *EVP_des_ede3_ecb(void);
+const EVP_CIPHER *EVP_des_cfb64(void);
+# define EVP_des_cfb EVP_des_cfb64
+const EVP_CIPHER *EVP_des_cfb1(void);
+const EVP_CIPHER *EVP_des_cfb8(void);
+const EVP_CIPHER *EVP_des_ede_cfb64(void);
+# define EVP_des_ede_cfb EVP_des_ede_cfb64
+#if 0
+const EVP_CIPHER *EVP_des_ede_cfb1(void);
+const EVP_CIPHER *EVP_des_ede_cfb8(void);
+#endif
+const EVP_CIPHER *EVP_des_ede3_cfb64(void);
+# define EVP_des_ede3_cfb EVP_des_ede3_cfb64
+const EVP_CIPHER *EVP_des_ede3_cfb1(void);
+const EVP_CIPHER *EVP_des_ede3_cfb8(void);
+const EVP_CIPHER *EVP_des_ofb(void);
+const EVP_CIPHER *EVP_des_ede_ofb(void);
+const EVP_CIPHER *EVP_des_ede3_ofb(void);
+const EVP_CIPHER *EVP_des_cbc(void);
+const EVP_CIPHER *EVP_des_ede_cbc(void);
+const EVP_CIPHER *EVP_des_ede3_cbc(void);
+const EVP_CIPHER *EVP_desx_cbc(void);
+/* This should now be supported through the dev_crypto ENGINE. But also, why are
+ * rc4 and md5 declarations made here inside a "NO_DES" precompiler branch? */
+#if 0
+# ifdef OPENSSL_OPENBSD_DEV_CRYPTO
+const EVP_CIPHER *EVP_dev_crypto_des_ede3_cbc(void);
+const EVP_CIPHER *EVP_dev_crypto_rc4(void);
+const EVP_MD *EVP_dev_crypto_md5(void);
+# endif
+#endif
+#endif
+#ifndef OPENSSL_NO_RC4
+const EVP_CIPHER *EVP_rc4(void);
+const EVP_CIPHER *EVP_rc4_40(void);
+#ifndef OPENSSL_NO_MD5
+const EVP_CIPHER *EVP_rc4_hmac_md5(void);
+#endif
+#endif
+#ifndef OPENSSL_NO_IDEA
+const EVP_CIPHER *EVP_idea_ecb(void);
+const EVP_CIPHER *EVP_idea_cfb64(void);
+# define EVP_idea_cfb EVP_idea_cfb64
+const EVP_CIPHER *EVP_idea_ofb(void);
+const EVP_CIPHER *EVP_idea_cbc(void);
+#endif
+#ifndef OPENSSL_NO_RC2
+const EVP_CIPHER *EVP_rc2_ecb(void);
+const EVP_CIPHER *EVP_rc2_cbc(void);
+const EVP_CIPHER *EVP_rc2_40_cbc(void);
+const EVP_CIPHER *EVP_rc2_64_cbc(void);
+const EVP_CIPHER *EVP_rc2_cfb64(void);
+# define EVP_rc2_cfb EVP_rc2_cfb64
+const EVP_CIPHER *EVP_rc2_ofb(void);
+#endif
+#ifndef OPENSSL_NO_BF
+const EVP_CIPHER *EVP_bf_ecb(void);
+const EVP_CIPHER *EVP_bf_cbc(void);
+const EVP_CIPHER *EVP_bf_cfb64(void);
+# define EVP_bf_cfb EVP_bf_cfb64
+const EVP_CIPHER *EVP_bf_ofb(void);
+#endif
+#ifndef OPENSSL_NO_CAST
+const EVP_CIPHER *EVP_cast5_ecb(void);
+const EVP_CIPHER *EVP_cast5_cbc(void);
+const EVP_CIPHER *EVP_cast5_cfb64(void);
+# define EVP_cast5_cfb EVP_cast5_cfb64
+const EVP_CIPHER *EVP_cast5_ofb(void);
+#endif
+#ifndef OPENSSL_NO_RC5
+const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);
+const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);
+const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);
+# define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64
+const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
+#endif
+#ifndef OPENSSL_NO_AES
+const EVP_CIPHER *EVP_aes_128_ecb(void);
+const EVP_CIPHER *EVP_aes_128_cbc(void);
+const EVP_CIPHER *EVP_aes_128_cfb1(void);
+const EVP_CIPHER *EVP_aes_128_cfb8(void);
+const EVP_CIPHER *EVP_aes_128_cfb128(void);
+# define EVP_aes_128_cfb EVP_aes_128_cfb128
+const EVP_CIPHER *EVP_aes_128_ofb(void);
+const EVP_CIPHER *EVP_aes_128_ctr(void);
+const EVP_CIPHER *EVP_aes_128_gcm(void);
+const EVP_CIPHER *EVP_aes_128_ccm(void);
+const EVP_CIPHER *EVP_aes_128_xts(void);
+const EVP_CIPHER *EVP_aes_192_ecb(void);
+const EVP_CIPHER *EVP_aes_192_cbc(void);
+const EVP_CIPHER *EVP_aes_192_cfb1(void);
+const EVP_CIPHER *EVP_aes_192_cfb8(void);
+const EVP_CIPHER *EVP_aes_192_cfb128(void);
+# define EVP_aes_192_cfb EVP_aes_192_cfb128
+const EVP_CIPHER *EVP_aes_192_ofb(void);
+const EVP_CIPHER *EVP_aes_192_ctr(void);
+const EVP_CIPHER *EVP_aes_192_gcm(void);
+const EVP_CIPHER *EVP_aes_192_ccm(void);
+const EVP_CIPHER *EVP_aes_256_ecb(void);
+const EVP_CIPHER *EVP_aes_256_cbc(void);
+const EVP_CIPHER *EVP_aes_256_cfb1(void);
+const EVP_CIPHER *EVP_aes_256_cfb8(void);
+const EVP_CIPHER *EVP_aes_256_cfb128(void);
+# define EVP_aes_256_cfb EVP_aes_256_cfb128
+const EVP_CIPHER *EVP_aes_256_ofb(void);
+const EVP_CIPHER *EVP_aes_256_ctr(void);
+const EVP_CIPHER *EVP_aes_256_gcm(void);
+const EVP_CIPHER *EVP_aes_256_ccm(void);
+const EVP_CIPHER *EVP_aes_256_xts(void);
+#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
+const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
+const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);
+#endif
+#endif
+#ifndef OPENSSL_NO_CAMELLIA
+const EVP_CIPHER *EVP_camellia_128_ecb(void);
+const EVP_CIPHER *EVP_camellia_128_cbc(void);
+const EVP_CIPHER *EVP_camellia_128_cfb1(void);
+const EVP_CIPHER *EVP_camellia_128_cfb8(void);
+const EVP_CIPHER *EVP_camellia_128_cfb128(void);
+# define EVP_camellia_128_cfb EVP_camellia_128_cfb128
+const EVP_CIPHER *EVP_camellia_128_ofb(void);
+const EVP_CIPHER *EVP_camellia_192_ecb(void);
+const EVP_CIPHER *EVP_camellia_192_cbc(void);
+const EVP_CIPHER *EVP_camellia_192_cfb1(void);
+const EVP_CIPHER *EVP_camellia_192_cfb8(void);
+const EVP_CIPHER *EVP_camellia_192_cfb128(void);
+# define EVP_camellia_192_cfb EVP_camellia_192_cfb128
+const EVP_CIPHER *EVP_camellia_192_ofb(void);
+const EVP_CIPHER *EVP_camellia_256_ecb(void);
+const EVP_CIPHER *EVP_camellia_256_cbc(void);
+const EVP_CIPHER *EVP_camellia_256_cfb1(void);
+const EVP_CIPHER *EVP_camellia_256_cfb8(void);
+const EVP_CIPHER *EVP_camellia_256_cfb128(void);
+# define EVP_camellia_256_cfb EVP_camellia_256_cfb128
+const EVP_CIPHER *EVP_camellia_256_ofb(void);
+#endif
+
+#ifndef OPENSSL_NO_SEED
+const EVP_CIPHER *EVP_seed_ecb(void);
+const EVP_CIPHER *EVP_seed_cbc(void);
+const EVP_CIPHER *EVP_seed_cfb128(void);
+# define EVP_seed_cfb EVP_seed_cfb128
+const EVP_CIPHER *EVP_seed_ofb(void);
+#endif
+
+void OPENSSL_add_all_algorithms_noconf(void);
+void OPENSSL_add_all_algorithms_conf(void);
+
+#ifdef OPENSSL_LOAD_CONF
+#define OpenSSL_add_all_algorithms() \
+		OPENSSL_add_all_algorithms_conf()
+#else
+#define OpenSSL_add_all_algorithms() \
+		OPENSSL_add_all_algorithms_noconf()
+#endif
+
+void OpenSSL_add_all_ciphers(void);
+void OpenSSL_add_all_digests(void);
+#define SSLeay_add_all_algorithms() OpenSSL_add_all_algorithms()
+#define SSLeay_add_all_ciphers() OpenSSL_add_all_ciphers()
+#define SSLeay_add_all_digests() OpenSSL_add_all_digests()
+
+int EVP_add_cipher(const EVP_CIPHER *cipher);
+int EVP_add_digest(const EVP_MD *digest);
+
+const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
+const EVP_MD *EVP_get_digestbyname(const char *name);
+void EVP_cleanup(void);
+
+void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph,
+		const char *from, const char *to, void *x), void *arg);
+void EVP_CIPHER_do_all_sorted(void (*fn)(const EVP_CIPHER *ciph,
+		const char *from, const char *to, void *x), void *arg);
+
+void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph,
+		const char *from, const char *to, void *x), void *arg);
+void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph,
+		const char *from, const char *to, void *x), void *arg);
+
+int		EVP_PKEY_decrypt_old(unsigned char *dec_key,
+			const unsigned char *enc_key,int enc_key_len,
+			EVP_PKEY *private_key);
+int		EVP_PKEY_encrypt_old(unsigned char *enc_key,
+			const unsigned char *key,int key_len,
+			EVP_PKEY *pub_key);
+int		EVP_PKEY_type(int type);
+int		EVP_PKEY_id(const EVP_PKEY *pkey);
+int		EVP_PKEY_base_id(const EVP_PKEY *pkey);
+int		EVP_PKEY_bits(EVP_PKEY *pkey);
+int		EVP_PKEY_size(EVP_PKEY *pkey);
+int 		EVP_PKEY_set_type(EVP_PKEY *pkey,int type);
+int		EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
+int 		EVP_PKEY_assign(EVP_PKEY *pkey,int type,void *key);
+void *		EVP_PKEY_get0(EVP_PKEY *pkey);
+
+#ifndef OPENSSL_NO_RSA
+struct rsa_st;
+int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,struct rsa_st *key);
+struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
+#endif
+#ifndef OPENSSL_NO_DSA
+struct dsa_st;
+int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,struct dsa_st *key);
+struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
+#endif
+#ifndef OPENSSL_NO_DH
+struct dh_st;
+int EVP_PKEY_set1_DH(EVP_PKEY *pkey,struct dh_st *key);
+struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);
+#endif
+#ifndef OPENSSL_NO_EC
+struct ec_key_st;
+int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,struct ec_key_st *key);
+struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
+#endif
+
+EVP_PKEY *	EVP_PKEY_new(void);
+void		EVP_PKEY_free(EVP_PKEY *pkey);
+
+EVP_PKEY *	d2i_PublicKey(int type,EVP_PKEY **a, const unsigned char **pp,
+			long length);
+int		i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);
+
+EVP_PKEY *	d2i_PrivateKey(int type,EVP_PKEY **a, const unsigned char **pp,
+			long length);
+EVP_PKEY *	d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
+			long length);
+int		i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);
+
+int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);
+int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
+int EVP_PKEY_save_parameters(EVP_PKEY *pkey,int mode);
+int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);
+
+int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);
+
+int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
+				int indent, ASN1_PCTX *pctx);
+int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
+				int indent, ASN1_PCTX *pctx);
+int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
+				int indent, ASN1_PCTX *pctx);
+
+int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);
+
+int EVP_CIPHER_type(const EVP_CIPHER *ctx);
+
+/* calls methods */
+int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
+int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
+
+/* These are used by EVP_CIPHER methods */
+int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);
+int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);
+
+/* PKCS5 password based encryption */
+int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
+			 int en_de);
+int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
+			   const unsigned char *salt, int saltlen, int iter,
+			   int keylen, unsigned char *out);
+int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
+			   const unsigned char *salt, int saltlen, int iter,
+			   const EVP_MD *digest,
+		      int keylen, unsigned char *out);
+int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
+			 int en_de);
+
+void PKCS5_PBE_add(void);
+
+int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
+	     ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);
+
+/* PBE type */
+
+/* Can appear as the outermost AlgorithmIdentifier */
+#define EVP_PBE_TYPE_OUTER	0x0
+/* Is an PRF type OID */
+#define EVP_PBE_TYPE_PRF	0x1
+
+int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid,
+	     EVP_PBE_KEYGEN *keygen);
+int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
+		    EVP_PBE_KEYGEN *keygen);
+int EVP_PBE_find(int type, int pbe_nid,
+			int *pcnid, int *pmnid, EVP_PBE_KEYGEN **pkeygen);
+void EVP_PBE_cleanup(void);
+
+#define ASN1_PKEY_ALIAS		0x1
+#define ASN1_PKEY_DYNAMIC	0x2
+#define ASN1_PKEY_SIGPARAM_NULL	0x4
+
+#define ASN1_PKEY_CTRL_PKCS7_SIGN	0x1
+#define ASN1_PKEY_CTRL_PKCS7_ENCRYPT	0x2
+#define ASN1_PKEY_CTRL_DEFAULT_MD_NID	0x3
+#define ASN1_PKEY_CTRL_CMS_SIGN		0x5
+#define ASN1_PKEY_CTRL_CMS_ENVELOPE	0x7
+
+int EVP_PKEY_asn1_get_count(void);
+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);
+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,
+					const char *str, int len);
+int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);
+int EVP_PKEY_asn1_add_alias(int to, int from);
+int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id, int *ppkey_flags,
+				const char **pinfo, const char **ppem_str,
+					const EVP_PKEY_ASN1_METHOD *ameth);
+
+const EVP_PKEY_ASN1_METHOD* EVP_PKEY_get0_asn1(EVP_PKEY *pkey);
+EVP_PKEY_ASN1_METHOD* EVP_PKEY_asn1_new(int id, int flags,
+					const char *pem_str, const char *info);
+void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst, 
+			const EVP_PKEY_ASN1_METHOD *src);
+void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);
+void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,
+		int (*pub_decode)(EVP_PKEY *pk, X509_PUBKEY *pub),
+		int (*pub_encode)(X509_PUBKEY *pub, const EVP_PKEY *pk),
+		int (*pub_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
+		int (*pub_print)(BIO *out, const EVP_PKEY *pkey, int indent,
+							ASN1_PCTX *pctx),
+		int (*pkey_size)(const EVP_PKEY *pk),
+		int (*pkey_bits)(const EVP_PKEY *pk));
+void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,
+		int (*priv_decode)(EVP_PKEY *pk, PKCS8_PRIV_KEY_INFO *p8inf),
+		int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pk),
+		int (*priv_print)(BIO *out, const EVP_PKEY *pkey, int indent,
+							ASN1_PCTX *pctx));
+void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,
+		int (*param_decode)(EVP_PKEY *pkey,
+				const unsigned char **pder, int derlen),
+		int (*param_encode)(const EVP_PKEY *pkey, unsigned char **pder),
+		int (*param_missing)(const EVP_PKEY *pk),
+		int (*param_copy)(EVP_PKEY *to, const EVP_PKEY *from),
+		int (*param_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
+		int (*param_print)(BIO *out, const EVP_PKEY *pkey, int indent,
+							ASN1_PCTX *pctx));
+
+void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,
+		void (*pkey_free)(EVP_PKEY *pkey));
+void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,
+		int (*pkey_ctrl)(EVP_PKEY *pkey, int op,
+							long arg1, void *arg2));
+
+
+#define EVP_PKEY_OP_UNDEFINED		0
+#define EVP_PKEY_OP_PARAMGEN		(1<<1)
+#define EVP_PKEY_OP_KEYGEN		(1<<2)
+#define EVP_PKEY_OP_SIGN		(1<<3)
+#define EVP_PKEY_OP_VERIFY		(1<<4)
+#define EVP_PKEY_OP_VERIFYRECOVER	(1<<5)
+#define EVP_PKEY_OP_SIGNCTX		(1<<6)
+#define EVP_PKEY_OP_VERIFYCTX		(1<<7)
+#define EVP_PKEY_OP_ENCRYPT		(1<<8)
+#define EVP_PKEY_OP_DECRYPT		(1<<9)
+#define EVP_PKEY_OP_DERIVE		(1<<10)
+
+#define EVP_PKEY_OP_TYPE_SIG	\
+	(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY | EVP_PKEY_OP_VERIFYRECOVER \
+		| EVP_PKEY_OP_SIGNCTX | EVP_PKEY_OP_VERIFYCTX)
+
+#define EVP_PKEY_OP_TYPE_CRYPT \
+	(EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT)
+
+#define EVP_PKEY_OP_TYPE_NOGEN \
+	(EVP_PKEY_OP_SIG | EVP_PKEY_OP_CRYPT | EVP_PKEY_OP_DERIVE)
+
+#define EVP_PKEY_OP_TYPE_GEN \
+		(EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN)
+
+#define	 EVP_PKEY_CTX_set_signature_md(ctx, md)	\
+		EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \
+					EVP_PKEY_CTRL_MD, 0, (void *)md)
+
+#define EVP_PKEY_CTRL_MD		1
+#define EVP_PKEY_CTRL_PEER_KEY		2
+
+#define EVP_PKEY_CTRL_PKCS7_ENCRYPT	3
+#define EVP_PKEY_CTRL_PKCS7_DECRYPT	4
+
+#define EVP_PKEY_CTRL_PKCS7_SIGN	5
+
+#define EVP_PKEY_CTRL_SET_MAC_KEY	6
+
+#define EVP_PKEY_CTRL_DIGESTINIT	7
+
+/* Used by GOST key encryption in TLS */
+#define EVP_PKEY_CTRL_SET_IV 		8
+
+#define EVP_PKEY_CTRL_CMS_ENCRYPT	9
+#define EVP_PKEY_CTRL_CMS_DECRYPT	10
+#define EVP_PKEY_CTRL_CMS_SIGN		11
+
+#define EVP_PKEY_CTRL_CIPHER		12
+
+#define EVP_PKEY_ALG_CTRL		0x1000
+
+
+#define EVP_PKEY_FLAG_AUTOARGLEN	2
+/* Method handles all operations: don't assume any digest related
+ * defaults.
+ */
+#define EVP_PKEY_FLAG_SIGCTX_CUSTOM	4
+
+const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
+EVP_PKEY_METHOD* EVP_PKEY_meth_new(int id, int flags);
+void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
+				const EVP_PKEY_METHOD *meth);
+void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
+void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
+int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);
+
+EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
+EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
+EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);
+void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);
+
+int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
+				int cmd, int p1, void *p2);
+int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
+						const char *value);
+
+int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);
+void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);
+
+EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
+				const unsigned char *key, int keylen);
+
+void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);
+void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);
+EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);
+
+EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);
+
+void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
+void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);
+
+int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
+			unsigned char *sig, size_t *siglen,
+			const unsigned char *tbs, size_t tbslen);
+int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
+			const unsigned char *sig, size_t siglen,
+			const unsigned char *tbs, size_t tbslen);
+int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
+			unsigned char *rout, size_t *routlen,
+			const unsigned char *sig, size_t siglen);
+int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
+			unsigned char *out, size_t *outlen,
+			const unsigned char *in, size_t inlen);
+int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
+			unsigned char *out, size_t *outlen,
+			const unsigned char *in, size_t inlen);
+
+int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
+int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);
+
+typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);
+
+int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+
+void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
+EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);
+
+int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);
+
+void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
+	int (*init)(EVP_PKEY_CTX *ctx));
+
+void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
+	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src));
+
+void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
+	void (*cleanup)(EVP_PKEY_CTX *ctx));
+
+void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
+	int (*paramgen_init)(EVP_PKEY_CTX *ctx),
+	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));
+
+void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
+	int (*keygen_init)(EVP_PKEY_CTX *ctx),
+	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));
+
+void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
+	int (*sign_init)(EVP_PKEY_CTX *ctx),
+	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
+					const unsigned char *tbs, size_t tbslen));
+
+void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
+	int (*verify_init)(EVP_PKEY_CTX *ctx),
+	int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
+					const unsigned char *tbs, size_t tbslen));
+
+void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
+	int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
+	int (*verify_recover)(EVP_PKEY_CTX *ctx,
+					unsigned char *sig, size_t *siglen,
+					const unsigned char *tbs, size_t tbslen));
+
+void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
+	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
+	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
+					EVP_MD_CTX *mctx));
+
+void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
+	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
+	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
+					EVP_MD_CTX *mctx));
+
+void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
+	int (*encrypt_init)(EVP_PKEY_CTX *ctx),
+	int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
+					const unsigned char *in, size_t inlen));
+
+void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
+	int (*decrypt_init)(EVP_PKEY_CTX *ctx),
+	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
+					const unsigned char *in, size_t inlen));
+
+void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
+	int (*derive_init)(EVP_PKEY_CTX *ctx),
+	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen));
+
+void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
+	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
+	int (*ctrl_str)(EVP_PKEY_CTX *ctx,
+					const char *type, const char *value));
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_EVP_strings(void);
+
+/* Error codes for the EVP functions. */
+
+/* Function codes. */
+#define EVP_F_AESNI_INIT_KEY				 165
+#define EVP_F_AESNI_XTS_CIPHER				 176
+#define EVP_F_AES_INIT_KEY				 133
+#define EVP_F_AES_XTS					 172
+#define EVP_F_AES_XTS_CIPHER				 175
+#define EVP_F_CAMELLIA_INIT_KEY				 159
+#define EVP_F_CMAC_INIT					 173
+#define EVP_F_D2I_PKEY					 100
+#define EVP_F_DO_SIGVER_INIT				 161
+#define EVP_F_DSAPKEY2PKCS8				 134
+#define EVP_F_DSA_PKEY2PKCS8				 135
+#define EVP_F_ECDSA_PKEY2PKCS8				 129
+#define EVP_F_ECKEY_PKEY2PKCS8				 132
+#define EVP_F_EVP_CIPHERINIT_EX				 123
+#define EVP_F_EVP_CIPHER_CTX_COPY			 163
+#define EVP_F_EVP_CIPHER_CTX_CTRL			 124
+#define EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH		 122
+#define EVP_F_EVP_DECRYPTFINAL_EX			 101
+#define EVP_F_EVP_DIGESTINIT_EX				 128
+#define EVP_F_EVP_ENCRYPTFINAL_EX			 127
+#define EVP_F_EVP_MD_CTX_COPY_EX			 110
+#define EVP_F_EVP_MD_SIZE				 162
+#define EVP_F_EVP_OPENINIT				 102
+#define EVP_F_EVP_PBE_ALG_ADD				 115
+#define EVP_F_EVP_PBE_ALG_ADD_TYPE			 160
+#define EVP_F_EVP_PBE_CIPHERINIT			 116
+#define EVP_F_EVP_PKCS82PKEY				 111
+#define EVP_F_EVP_PKCS82PKEY_BROKEN			 136
+#define EVP_F_EVP_PKEY2PKCS8_BROKEN			 113
+#define EVP_F_EVP_PKEY_COPY_PARAMETERS			 103
+#define EVP_F_EVP_PKEY_CTX_CTRL				 137
+#define EVP_F_EVP_PKEY_CTX_CTRL_STR			 150
+#define EVP_F_EVP_PKEY_CTX_DUP				 156
+#define EVP_F_EVP_PKEY_DECRYPT				 104
+#define EVP_F_EVP_PKEY_DECRYPT_INIT			 138
+#define EVP_F_EVP_PKEY_DECRYPT_OLD			 151
+#define EVP_F_EVP_PKEY_DERIVE				 153
+#define EVP_F_EVP_PKEY_DERIVE_INIT			 154
+#define EVP_F_EVP_PKEY_DERIVE_SET_PEER			 155
+#define EVP_F_EVP_PKEY_ENCRYPT				 105
+#define EVP_F_EVP_PKEY_ENCRYPT_INIT			 139
+#define EVP_F_EVP_PKEY_ENCRYPT_OLD			 152
+#define EVP_F_EVP_PKEY_GET1_DH				 119
+#define EVP_F_EVP_PKEY_GET1_DSA				 120
+#define EVP_F_EVP_PKEY_GET1_ECDSA			 130
+#define EVP_F_EVP_PKEY_GET1_EC_KEY			 131
+#define EVP_F_EVP_PKEY_GET1_RSA				 121
+#define EVP_F_EVP_PKEY_KEYGEN				 146
+#define EVP_F_EVP_PKEY_KEYGEN_INIT			 147
+#define EVP_F_EVP_PKEY_NEW				 106
+#define EVP_F_EVP_PKEY_PARAMGEN				 148
+#define EVP_F_EVP_PKEY_PARAMGEN_INIT			 149
+#define EVP_F_EVP_PKEY_SIGN				 140
+#define EVP_F_EVP_PKEY_SIGN_INIT			 141
+#define EVP_F_EVP_PKEY_VERIFY				 142
+#define EVP_F_EVP_PKEY_VERIFY_INIT			 143
+#define EVP_F_EVP_PKEY_VERIFY_RECOVER			 144
+#define EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT		 145
+#define EVP_F_EVP_RIJNDAEL				 126
+#define EVP_F_EVP_SIGNFINAL				 107
+#define EVP_F_EVP_VERIFYFINAL				 108
+#define EVP_F_FIPS_CIPHERINIT				 166
+#define EVP_F_FIPS_CIPHER_CTX_COPY			 170
+#define EVP_F_FIPS_CIPHER_CTX_CTRL			 167
+#define EVP_F_FIPS_CIPHER_CTX_SET_KEY_LENGTH		 171
+#define EVP_F_FIPS_DIGESTINIT				 168
+#define EVP_F_FIPS_MD_CTX_COPY				 169
+#define EVP_F_HMAC_INIT_EX				 174
+#define EVP_F_INT_CTX_NEW				 157
+#define EVP_F_PKCS5_PBE_KEYIVGEN			 117
+#define EVP_F_PKCS5_V2_PBE_KEYIVGEN			 118
+#define EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN			 164
+#define EVP_F_PKCS8_SET_BROKEN				 112
+#define EVP_F_PKEY_SET_TYPE				 158
+#define EVP_F_RC2_MAGIC_TO_METH				 109
+#define EVP_F_RC5_CTRL					 125
+
+/* Reason codes. */
+#define EVP_R_AES_IV_SETUP_FAILED			 162
+#define EVP_R_AES_KEY_SETUP_FAILED			 143
+#define EVP_R_ASN1_LIB					 140
+#define EVP_R_BAD_BLOCK_LENGTH				 136
+#define EVP_R_BAD_DECRYPT				 100
+#define EVP_R_BAD_KEY_LENGTH				 137
+#define EVP_R_BN_DECODE_ERROR				 112
+#define EVP_R_BN_PUBKEY_ERROR				 113
+#define EVP_R_BUFFER_TOO_SMALL				 155
+#define EVP_R_CAMELLIA_KEY_SETUP_FAILED			 157
+#define EVP_R_CIPHER_PARAMETER_ERROR			 122
+#define EVP_R_COMMAND_NOT_SUPPORTED			 147
+#define EVP_R_CTRL_NOT_IMPLEMENTED			 132
+#define EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED		 133
+#define EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH		 138
+#define EVP_R_DECODE_ERROR				 114
+#define EVP_R_DIFFERENT_KEY_TYPES			 101
+#define EVP_R_DIFFERENT_PARAMETERS			 153
+#define EVP_R_DISABLED_FOR_FIPS				 163
+#define EVP_R_ENCODE_ERROR				 115
+#define EVP_R_EVP_PBE_CIPHERINIT_ERROR			 119
+#define EVP_R_EXPECTING_AN_RSA_KEY			 127
+#define EVP_R_EXPECTING_A_DH_KEY			 128
+#define EVP_R_EXPECTING_A_DSA_KEY			 129
+#define EVP_R_EXPECTING_A_ECDSA_KEY			 141
+#define EVP_R_EXPECTING_A_EC_KEY			 142
+#define EVP_R_INITIALIZATION_ERROR			 134
+#define EVP_R_INPUT_NOT_INITIALIZED			 111
+#define EVP_R_INVALID_DIGEST				 152
+#define EVP_R_INVALID_KEY_LENGTH			 130
+#define EVP_R_INVALID_OPERATION				 148
+#define EVP_R_IV_TOO_LARGE				 102
+#define EVP_R_KEYGEN_FAILURE				 120
+#define EVP_R_MESSAGE_DIGEST_IS_NULL			 159
+#define EVP_R_METHOD_NOT_SUPPORTED			 144
+#define EVP_R_MISSING_PARAMETERS			 103
+#define EVP_R_NO_CIPHER_SET				 131
+#define EVP_R_NO_DEFAULT_DIGEST				 158
+#define EVP_R_NO_DIGEST_SET				 139
+#define EVP_R_NO_DSA_PARAMETERS				 116
+#define EVP_R_NO_KEY_SET				 154
+#define EVP_R_NO_OPERATION_SET				 149
+#define EVP_R_NO_SIGN_FUNCTION_CONFIGURED		 104
+#define EVP_R_NO_VERIFY_FUNCTION_CONFIGURED		 105
+#define EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 150
+#define EVP_R_OPERATON_NOT_INITIALIZED			 151
+#define EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE			 117
+#define EVP_R_PRIVATE_KEY_DECODE_ERROR			 145
+#define EVP_R_PRIVATE_KEY_ENCODE_ERROR			 146
+#define EVP_R_PUBLIC_KEY_NOT_RSA			 106
+#define EVP_R_TOO_LARGE					 164
+#define EVP_R_UNKNOWN_CIPHER				 160
+#define EVP_R_UNKNOWN_DIGEST				 161
+#define EVP_R_UNKNOWN_PBE_ALGORITHM			 121
+#define EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS		 135
+#define EVP_R_UNSUPPORTED_ALGORITHM			 156
+#define EVP_R_UNSUPPORTED_CIPHER			 107
+#define EVP_R_UNSUPPORTED_KEYLENGTH			 123
+#define EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION	 124
+#define EVP_R_UNSUPPORTED_KEY_SIZE			 108
+#define EVP_R_UNSUPPORTED_PRF				 125
+#define EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM		 118
+#define EVP_R_UNSUPPORTED_SALT_TYPE			 126
+#define EVP_R_WRONG_FINAL_BLOCK_LENGTH			 109
+#define EVP_R_WRONG_PUBLIC_KEY_TYPE			 110
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Nur tools-org/vboot_utils/src/host/include/openssl/pem.h tools/vboot_utils/src/host/include/openssl/pem.h
--- tools-org/vboot_utils/src/host/include/openssl/pem.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/include/openssl/pem.h	2014-04-27 13:03:45.776118604 +0000
@@ -0,0 +1,641 @@
+/* crypto/pem/pem.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_PEM_H
+#define HEADER_PEM_H
+
+#include <openssl/e_os2.h>
+#ifndef OPENSSL_NO_BIO
+#include <openssl/bio.h>
+#endif
+#ifndef OPENSSL_NO_STACK
+#include <openssl/stack.h>
+#endif
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+#include <openssl/pem2.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define PEM_BUFSIZE		1024
+
+#define PEM_OBJ_UNDEF		0
+#define PEM_OBJ_X509		1
+#define PEM_OBJ_X509_REQ	2
+#define PEM_OBJ_CRL		3
+#define PEM_OBJ_SSL_SESSION	4
+#define PEM_OBJ_PRIV_KEY	10
+#define PEM_OBJ_PRIV_RSA	11
+#define PEM_OBJ_PRIV_DSA	12
+#define PEM_OBJ_PRIV_DH		13
+#define PEM_OBJ_PUB_RSA		14
+#define PEM_OBJ_PUB_DSA		15
+#define PEM_OBJ_PUB_DH		16
+#define PEM_OBJ_DHPARAMS	17
+#define PEM_OBJ_DSAPARAMS	18
+#define PEM_OBJ_PRIV_RSA_PUBLIC	19
+#define PEM_OBJ_PRIV_ECDSA	20
+#define PEM_OBJ_PUB_ECDSA	21
+#define PEM_OBJ_ECPARAMETERS	22
+
+#define PEM_ERROR		30
+#define PEM_DEK_DES_CBC         40
+#define PEM_DEK_IDEA_CBC        45
+#define PEM_DEK_DES_EDE         50
+#define PEM_DEK_DES_ECB         60
+#define PEM_DEK_RSA             70
+#define PEM_DEK_RSA_MD2         80
+#define PEM_DEK_RSA_MD5         90
+
+#define PEM_MD_MD2		NID_md2
+#define PEM_MD_MD5		NID_md5
+#define PEM_MD_SHA		NID_sha
+#define PEM_MD_MD2_RSA		NID_md2WithRSAEncryption
+#define PEM_MD_MD5_RSA		NID_md5WithRSAEncryption
+#define PEM_MD_SHA_RSA		NID_sha1WithRSAEncryption
+
+#define PEM_STRING_X509_OLD	"X509 CERTIFICATE"
+#define PEM_STRING_X509		"CERTIFICATE"
+#define PEM_STRING_X509_PAIR	"CERTIFICATE PAIR"
+#define PEM_STRING_X509_TRUSTED	"TRUSTED CERTIFICATE"
+#define PEM_STRING_X509_REQ_OLD	"NEW CERTIFICATE REQUEST"
+#define PEM_STRING_X509_REQ	"CERTIFICATE REQUEST"
+#define PEM_STRING_X509_CRL	"X509 CRL"
+#define PEM_STRING_EVP_PKEY	"ANY PRIVATE KEY"
+#define PEM_STRING_PUBLIC	"PUBLIC KEY"
+#define PEM_STRING_RSA		"RSA PRIVATE KEY"
+#define PEM_STRING_RSA_PUBLIC	"RSA PUBLIC KEY"
+#define PEM_STRING_DSA		"DSA PRIVATE KEY"
+#define PEM_STRING_DSA_PUBLIC	"DSA PUBLIC KEY"
+#define PEM_STRING_PKCS7	"PKCS7"
+#define PEM_STRING_PKCS7_SIGNED	"PKCS #7 SIGNED DATA"
+#define PEM_STRING_PKCS8	"ENCRYPTED PRIVATE KEY"
+#define PEM_STRING_PKCS8INF	"PRIVATE KEY"
+#define PEM_STRING_DHPARAMS	"DH PARAMETERS"
+#define PEM_STRING_SSL_SESSION	"SSL SESSION PARAMETERS"
+#define PEM_STRING_DSAPARAMS	"DSA PARAMETERS"
+#define PEM_STRING_ECDSA_PUBLIC "ECDSA PUBLIC KEY"
+#define PEM_STRING_ECPARAMETERS "EC PARAMETERS"
+#define PEM_STRING_ECPRIVATEKEY	"EC PRIVATE KEY"
+#define PEM_STRING_PARAMETERS	"PARAMETERS"
+#define PEM_STRING_CMS		"CMS"
+
+  /* Note that this structure is initialised by PEM_SealInit and cleaned up
+     by PEM_SealFinal (at least for now) */
+typedef struct PEM_Encode_Seal_st
+	{
+	EVP_ENCODE_CTX encode;
+	EVP_MD_CTX md;
+	EVP_CIPHER_CTX cipher;
+	} PEM_ENCODE_SEAL_CTX;
+
+/* enc_type is one off */
+#define PEM_TYPE_ENCRYPTED      10
+#define PEM_TYPE_MIC_ONLY       20
+#define PEM_TYPE_MIC_CLEAR      30
+#define PEM_TYPE_CLEAR		40
+
+typedef struct pem_recip_st
+	{
+	char *name;
+	X509_NAME *dn;
+
+	int cipher;
+	int key_enc;
+	/*	char iv[8]; unused and wrong size */
+	} PEM_USER;
+
+typedef struct pem_ctx_st
+	{
+	int type;		/* what type of object */
+
+	struct	{
+		int version;	
+		int mode;		
+		} proc_type;
+
+	char *domain;
+
+	struct	{
+		int cipher;
+	/* unused, and wrong size
+	   unsigned char iv[8]; */
+		} DEK_info;
+		
+	PEM_USER *originator;
+
+	int num_recipient;
+	PEM_USER **recipient;
+
+	/* XXX(ben): don#t think this is used! 
+		STACK *x509_chain;	/ * certificate chain */
+	EVP_MD *md;		/* signature type */
+
+	int md_enc;		/* is the md encrypted or not? */
+	int md_len;		/* length of md_data */
+	char *md_data;		/* message digest, could be pkey encrypted */
+
+	EVP_CIPHER *dec;	/* date encryption cipher */
+	int key_len;		/* key length */
+	unsigned char *key;	/* key */
+	/* unused, and wrong size
+	   unsigned char iv[8]; */
+
+	
+	int  data_enc;		/* is the data encrypted */
+	int data_len;
+	unsigned char *data;
+	} PEM_CTX;
+
+/* These macros make the PEM_read/PEM_write functions easier to maintain and
+ * write. Now they are all implemented with either:
+ * IMPLEMENT_PEM_rw(...) or IMPLEMENT_PEM_rw_cb(...)
+ */
+
+#ifdef OPENSSL_NO_FP_API
+
+#define IMPLEMENT_PEM_read_fp(name, type, str, asn1) /**/
+#define IMPLEMENT_PEM_write_fp(name, type, str, asn1) /**/
+#define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) /**/
+#define IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) /**/
+#define IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) /**/
+
+#else
+
+#define IMPLEMENT_PEM_read_fp(name, type, str, asn1) \
+type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u)\
+{ \
+return PEM_ASN1_read((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,cb,u); \
+} 
+
+#define IMPLEMENT_PEM_write_fp(name, type, str, asn1) \
+int PEM_write_##name(FILE *fp, type *x) \
+{ \
+return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,NULL,NULL,0,NULL,NULL); \
+}
+
+#define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) \
+int PEM_write_##name(FILE *fp, const type *x) \
+{ \
+return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,(void *)x,NULL,NULL,0,NULL,NULL); \
+}
+
+#define IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) \
+int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, \
+		  void *u) \
+	{ \
+	return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,enc,kstr,klen,cb,u); \
+	}
+
+#define IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) \
+int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, \
+		  void *u) \
+	{ \
+	return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,enc,kstr,klen,cb,u); \
+	}
+
+#endif
+
+#define IMPLEMENT_PEM_read_bio(name, type, str, asn1) \
+type *PEM_read_bio_##name(BIO *bp, type **x, pem_password_cb *cb, void *u)\
+{ \
+return PEM_ASN1_read_bio((d2i_of_void *)d2i_##asn1, str,bp,(void **)x,cb,u); \
+}
+
+#define IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
+int PEM_write_bio_##name(BIO *bp, type *x) \
+{ \
+return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,x,NULL,NULL,0,NULL,NULL); \
+}
+
+#define IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
+int PEM_write_bio_##name(BIO *bp, const type *x) \
+{ \
+return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,(void *)x,NULL,NULL,0,NULL,NULL); \
+}
+
+#define IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \
+int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u) \
+	{ \
+	return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,x,enc,kstr,klen,cb,u); \
+	}
+
+#define IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \
+int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u) \
+	{ \
+	return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,(void *)x,enc,kstr,klen,cb,u); \
+	}
+
+#define IMPLEMENT_PEM_write(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_fp(name, type, str, asn1) 
+
+#define IMPLEMENT_PEM_write_const(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) 
+
+#define IMPLEMENT_PEM_write_cb(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) 
+
+#define IMPLEMENT_PEM_write_cb_const(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) 
+
+#define IMPLEMENT_PEM_read(name, type, str, asn1) \
+	IMPLEMENT_PEM_read_bio(name, type, str, asn1) \
+	IMPLEMENT_PEM_read_fp(name, type, str, asn1) 
+
+#define IMPLEMENT_PEM_rw(name, type, str, asn1) \
+	IMPLEMENT_PEM_read(name, type, str, asn1) \
+	IMPLEMENT_PEM_write(name, type, str, asn1)
+
+#define IMPLEMENT_PEM_rw_const(name, type, str, asn1) \
+	IMPLEMENT_PEM_read(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_const(name, type, str, asn1)
+
+#define IMPLEMENT_PEM_rw_cb(name, type, str, asn1) \
+	IMPLEMENT_PEM_read(name, type, str, asn1) \
+	IMPLEMENT_PEM_write_cb(name, type, str, asn1)
+
+/* These are the same except they are for the declarations */
+
+#if defined(OPENSSL_NO_FP_API)
+
+#define DECLARE_PEM_read_fp(name, type) /**/
+#define DECLARE_PEM_write_fp(name, type) /**/
+#define DECLARE_PEM_write_cb_fp(name, type) /**/
+
+#else
+
+#define DECLARE_PEM_read_fp(name, type) \
+	type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u);
+
+#define DECLARE_PEM_write_fp(name, type) \
+	int PEM_write_##name(FILE *fp, type *x);
+
+#define DECLARE_PEM_write_fp_const(name, type) \
+	int PEM_write_##name(FILE *fp, const type *x);
+
+#define DECLARE_PEM_write_cb_fp(name, type) \
+	int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
+
+#endif
+
+#ifndef OPENSSL_NO_BIO
+#define DECLARE_PEM_read_bio(name, type) \
+	type *PEM_read_bio_##name(BIO *bp, type **x, pem_password_cb *cb, void *u);
+
+#define DECLARE_PEM_write_bio(name, type) \
+	int PEM_write_bio_##name(BIO *bp, type *x);
+
+#define DECLARE_PEM_write_bio_const(name, type) \
+	int PEM_write_bio_##name(BIO *bp, const type *x);
+
+#define DECLARE_PEM_write_cb_bio(name, type) \
+	int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
+	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
+
+#else
+
+#define DECLARE_PEM_read_bio(name, type) /**/
+#define DECLARE_PEM_write_bio(name, type) /**/
+#define DECLARE_PEM_write_bio_const(name, type) /**/
+#define DECLARE_PEM_write_cb_bio(name, type) /**/
+
+#endif
+
+#define DECLARE_PEM_write(name, type) \
+	DECLARE_PEM_write_bio(name, type) \
+	DECLARE_PEM_write_fp(name, type) 
+
+#define DECLARE_PEM_write_const(name, type) \
+	DECLARE_PEM_write_bio_const(name, type) \
+	DECLARE_PEM_write_fp_const(name, type)
+
+#define DECLARE_PEM_write_cb(name, type) \
+	DECLARE_PEM_write_cb_bio(name, type) \
+	DECLARE_PEM_write_cb_fp(name, type) 
+
+#define DECLARE_PEM_read(name, type) \
+	DECLARE_PEM_read_bio(name, type) \
+	DECLARE_PEM_read_fp(name, type)
+
+#define DECLARE_PEM_rw(name, type) \
+	DECLARE_PEM_read(name, type) \
+	DECLARE_PEM_write(name, type)
+
+#define DECLARE_PEM_rw_const(name, type) \
+	DECLARE_PEM_read(name, type) \
+	DECLARE_PEM_write_const(name, type)
+
+#define DECLARE_PEM_rw_cb(name, type) \
+	DECLARE_PEM_read(name, type) \
+	DECLARE_PEM_write_cb(name, type)
+
+#if 1
+/* "userdata": new with OpenSSL 0.9.4 */
+typedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);
+#else
+/* OpenSSL 0.9.3, 0.9.3a */
+typedef int pem_password_cb(char *buf, int size, int rwflag);
+#endif
+
+int	PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
+int	PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data,long *len,
+	pem_password_cb *callback,void *u);
+
+#ifndef OPENSSL_NO_BIO
+int	PEM_read_bio(BIO *bp, char **name, char **header,
+		unsigned char **data,long *len);
+int	PEM_write_bio(BIO *bp,const char *name,char *hdr,unsigned char *data,
+		long len);
+int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
+	     pem_password_cb *cb, void *u);
+void *	PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp,
+			  void **x, pem_password_cb *cb, void *u);
+int	PEM_ASN1_write_bio(i2d_of_void *i2d,const char *name,BIO *bp, void *x,
+			   const EVP_CIPHER *enc,unsigned char *kstr,int klen,
+			   pem_password_cb *cb, void *u);
+
+STACK_OF(X509_INFO) *	PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
+int	PEM_X509_INFO_write_bio(BIO *bp,X509_INFO *xi, EVP_CIPHER *enc,
+		unsigned char *kstr, int klen, pem_password_cb *cd, void *u);
+#endif
+
+int	PEM_read(FILE *fp, char **name, char **header,
+		unsigned char **data,long *len);
+int	PEM_write(FILE *fp,char *name,char *hdr,unsigned char *data,long len);
+void *  PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
+		      pem_password_cb *cb, void *u);
+int	PEM_ASN1_write(i2d_of_void *i2d,const char *name,FILE *fp,
+		       void *x,const EVP_CIPHER *enc,unsigned char *kstr,
+		       int klen,pem_password_cb *callback, void *u);
+STACK_OF(X509_INFO) *	PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,
+	pem_password_cb *cb, void *u);
+
+int	PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type,
+		EVP_MD *md_type, unsigned char **ek, int *ekl,
+		unsigned char *iv, EVP_PKEY **pubk, int npubk);
+void	PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
+		unsigned char *in, int inl);
+int	PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig,int *sigl,
+		unsigned char *out, int *outl, EVP_PKEY *priv);
+
+void    PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);
+void    PEM_SignUpdate(EVP_MD_CTX *ctx,unsigned char *d,unsigned int cnt);
+int	PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
+		unsigned int *siglen, EVP_PKEY *pkey);
+
+int	PEM_def_callback(char *buf, int num, int w, void *key);
+void	PEM_proc_type(char *buf, int type);
+void	PEM_dek_info(char *buf, const char *type, int len, char *str);
+
+
+#include <openssl/symhacks.h>
+
+DECLARE_PEM_rw(X509, X509)
+
+DECLARE_PEM_rw(X509_AUX, X509)
+
+DECLARE_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR)
+
+DECLARE_PEM_rw(X509_REQ, X509_REQ)
+DECLARE_PEM_write(X509_REQ_NEW, X509_REQ)
+
+DECLARE_PEM_rw(X509_CRL, X509_CRL)
+
+DECLARE_PEM_rw(PKCS7, PKCS7)
+
+DECLARE_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE)
+
+DECLARE_PEM_rw(PKCS8, X509_SIG)
+
+DECLARE_PEM_rw(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO)
+
+#ifndef OPENSSL_NO_RSA
+
+DECLARE_PEM_rw_cb(RSAPrivateKey, RSA)
+
+DECLARE_PEM_rw_const(RSAPublicKey, RSA)
+DECLARE_PEM_rw(RSA_PUBKEY, RSA)
+
+#endif
+
+#ifndef OPENSSL_NO_DSA
+
+DECLARE_PEM_rw_cb(DSAPrivateKey, DSA)
+
+DECLARE_PEM_rw(DSA_PUBKEY, DSA)
+
+DECLARE_PEM_rw_const(DSAparams, DSA)
+
+#endif
+
+#ifndef OPENSSL_NO_EC
+DECLARE_PEM_rw_const(ECPKParameters, EC_GROUP)
+DECLARE_PEM_rw_cb(ECPrivateKey, EC_KEY)
+DECLARE_PEM_rw(EC_PUBKEY, EC_KEY)
+#endif
+
+#ifndef OPENSSL_NO_DH
+
+DECLARE_PEM_rw_const(DHparams, DH)
+
+#endif
+
+DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
+
+DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
+
+int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                                  char *, int, pem_password_cb *, void *);
+int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+
+int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
+				  char *kstr, int klen,
+				  pem_password_cb *cb, void *u);
+
+EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+
+int PEM_write_PKCS8PrivateKey(FILE *fp,EVP_PKEY *x,const EVP_CIPHER *enc,
+			      char *kstr,int klen, pem_password_cb *cd, void *u);
+
+EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
+int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);
+
+
+EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length);
+EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length);
+EVP_PKEY *b2i_PrivateKey_bio(BIO *in);
+EVP_PKEY *b2i_PublicKey_bio(BIO *in);
+int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);
+int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);
+#ifndef OPENSSL_NO_RC4
+EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);
+int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
+		pem_password_cb *cb, void *u);
+#endif
+
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_PEM_strings(void);
+
+/* Error codes for the PEM functions. */
+
+/* Function codes. */
+#define PEM_F_B2I_DSS					 127
+#define PEM_F_B2I_PVK_BIO				 128
+#define PEM_F_B2I_RSA					 129
+#define PEM_F_CHECK_BITLEN_DSA				 130
+#define PEM_F_CHECK_BITLEN_RSA				 131
+#define PEM_F_D2I_PKCS8PRIVATEKEY_BIO			 120
+#define PEM_F_D2I_PKCS8PRIVATEKEY_FP			 121
+#define PEM_F_DO_B2I					 132
+#define PEM_F_DO_B2I_BIO				 133
+#define PEM_F_DO_BLOB_HEADER				 134
+#define PEM_F_DO_PK8PKEY				 126
+#define PEM_F_DO_PK8PKEY_FP				 125
+#define PEM_F_DO_PVK_BODY				 135
+#define PEM_F_DO_PVK_HEADER				 136
+#define PEM_F_I2B_PVK					 137
+#define PEM_F_I2B_PVK_BIO				 138
+#define PEM_F_LOAD_IV					 101
+#define PEM_F_PEM_ASN1_READ				 102
+#define PEM_F_PEM_ASN1_READ_BIO				 103
+#define PEM_F_PEM_ASN1_WRITE				 104
+#define PEM_F_PEM_ASN1_WRITE_BIO			 105
+#define PEM_F_PEM_DEF_CALLBACK				 100
+#define PEM_F_PEM_DO_HEADER				 106
+#define PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY		 118
+#define PEM_F_PEM_GET_EVP_CIPHER_INFO			 107
+#define PEM_F_PEM_PK8PKEY				 119
+#define PEM_F_PEM_READ					 108
+#define PEM_F_PEM_READ_BIO				 109
+#define PEM_F_PEM_READ_BIO_PARAMETERS			 140
+#define PEM_F_PEM_READ_BIO_PRIVATEKEY			 123
+#define PEM_F_PEM_READ_PRIVATEKEY			 124
+#define PEM_F_PEM_SEALFINAL				 110
+#define PEM_F_PEM_SEALINIT				 111
+#define PEM_F_PEM_SIGNFINAL				 112
+#define PEM_F_PEM_WRITE					 113
+#define PEM_F_PEM_WRITE_BIO				 114
+#define PEM_F_PEM_WRITE_PRIVATEKEY			 139
+#define PEM_F_PEM_X509_INFO_READ			 115
+#define PEM_F_PEM_X509_INFO_READ_BIO			 116
+#define PEM_F_PEM_X509_INFO_WRITE_BIO			 117
+
+/* Reason codes. */
+#define PEM_R_BAD_BASE64_DECODE				 100
+#define PEM_R_BAD_DECRYPT				 101
+#define PEM_R_BAD_END_LINE				 102
+#define PEM_R_BAD_IV_CHARS				 103
+#define PEM_R_BAD_MAGIC_NUMBER				 116
+#define PEM_R_BAD_PASSWORD_READ				 104
+#define PEM_R_BAD_VERSION_NUMBER			 117
+#define PEM_R_BIO_WRITE_FAILURE				 118
+#define PEM_R_CIPHER_IS_NULL				 127
+#define PEM_R_ERROR_CONVERTING_PRIVATE_KEY		 115
+#define PEM_R_EXPECTING_PRIVATE_KEY_BLOB		 119
+#define PEM_R_EXPECTING_PUBLIC_KEY_BLOB			 120
+#define PEM_R_INCONSISTENT_HEADER			 121
+#define PEM_R_KEYBLOB_HEADER_PARSE_ERROR		 122
+#define PEM_R_KEYBLOB_TOO_SHORT				 123
+#define PEM_R_NOT_DEK_INFO				 105
+#define PEM_R_NOT_ENCRYPTED				 106
+#define PEM_R_NOT_PROC_TYPE				 107
+#define PEM_R_NO_START_LINE				 108
+#define PEM_R_PROBLEMS_GETTING_PASSWORD			 109
+#define PEM_R_PUBLIC_KEY_NO_RSA				 110
+#define PEM_R_PVK_DATA_TOO_SHORT			 124
+#define PEM_R_PVK_TOO_SHORT				 125
+#define PEM_R_READ_KEY					 111
+#define PEM_R_SHORT_HEADER				 112
+#define PEM_R_UNSUPPORTED_CIPHER			 113
+#define PEM_R_UNSUPPORTED_ENCRYPTION			 114
+#define PEM_R_UNSUPPORTED_KEY_COMPONENTS		 126
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Nur tools-org/vboot_utils/src/host/include/openssl/x509.h tools/vboot_utils/src/host/include/openssl/x509.h
--- tools-org/vboot_utils/src/host/include/openssl/x509.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/include/openssl/x509.h	2014-04-27 13:03:45.776118604 +0000
@@ -0,0 +1,1297 @@
+/* crypto/x509/x509.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
+ * ECDH support in OpenSSL originally developed by 
+ * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
+ */
+
+#ifndef HEADER_X509_H
+#define HEADER_X509_H
+
+#include <openssl/e_os2.h>
+#include <openssl/symhacks.h>
+#ifndef OPENSSL_NO_BUFFER
+#include <openssl/buffer.h>
+#endif
+#ifndef OPENSSL_NO_EVP
+#include <openssl/evp.h>
+#endif
+#ifndef OPENSSL_NO_BIO
+#include <openssl/bio.h>
+#endif
+#include <openssl/stack.h>
+#include <openssl/asn1.h>
+#include <openssl/safestack.h>
+
+#ifndef OPENSSL_NO_EC
+#include <openssl/ec.h>
+#endif
+
+#ifndef OPENSSL_NO_ECDSA
+#include <openssl/ecdsa.h>
+#endif
+
+#ifndef OPENSSL_NO_ECDH
+#include <openssl/ecdh.h>
+#endif
+
+#ifndef OPENSSL_NO_DEPRECATED
+#ifndef OPENSSL_NO_RSA
+#include <openssl/rsa.h>
+#endif
+#ifndef OPENSSL_NO_DSA
+#include <openssl/dsa.h>
+#endif
+#ifndef OPENSSL_NO_DH
+#include <openssl/dh.h>
+#endif
+#endif
+
+#ifndef OPENSSL_NO_SHA
+#include <openssl/sha.h>
+#endif
+#include <openssl/ossl_typ.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_SYS_WIN32
+/* Under Win32 these are defined in wincrypt.h */
+#undef X509_NAME
+#undef X509_CERT_PAIR
+#undef X509_EXTENSIONS
+#endif
+
+#define X509_FILETYPE_PEM	1
+#define X509_FILETYPE_ASN1	2
+#define X509_FILETYPE_DEFAULT	3
+
+#define X509v3_KU_DIGITAL_SIGNATURE	0x0080
+#define X509v3_KU_NON_REPUDIATION	0x0040
+#define X509v3_KU_KEY_ENCIPHERMENT	0x0020
+#define X509v3_KU_DATA_ENCIPHERMENT	0x0010
+#define X509v3_KU_KEY_AGREEMENT		0x0008
+#define X509v3_KU_KEY_CERT_SIGN		0x0004
+#define X509v3_KU_CRL_SIGN		0x0002
+#define X509v3_KU_ENCIPHER_ONLY		0x0001
+#define X509v3_KU_DECIPHER_ONLY		0x8000
+#define X509v3_KU_UNDEF			0xffff
+
+typedef struct X509_objects_st
+	{
+	int nid;
+	int (*a2i)(void);
+	int (*i2a)(void);
+	} X509_OBJECTS;
+
+struct X509_algor_st
+	{
+	ASN1_OBJECT *algorithm;
+	ASN1_TYPE *parameter;
+	} /* X509_ALGOR */;
+
+DECLARE_ASN1_SET_OF(X509_ALGOR)
+
+typedef STACK_OF(X509_ALGOR) X509_ALGORS;
+
+typedef struct X509_val_st
+	{
+	ASN1_TIME *notBefore;
+	ASN1_TIME *notAfter;
+	} X509_VAL;
+
+struct X509_pubkey_st
+	{
+	X509_ALGOR *algor;
+	ASN1_BIT_STRING *public_key;
+	EVP_PKEY *pkey;
+	};
+
+typedef struct X509_sig_st
+	{
+	X509_ALGOR *algor;
+	ASN1_OCTET_STRING *digest;
+	} X509_SIG;
+
+typedef struct X509_name_entry_st
+	{
+	ASN1_OBJECT *object;
+	ASN1_STRING *value;
+	int set;
+	int size; 	/* temp variable */
+	} X509_NAME_ENTRY;
+
+DECLARE_STACK_OF(X509_NAME_ENTRY)
+DECLARE_ASN1_SET_OF(X509_NAME_ENTRY)
+
+/* we always keep X509_NAMEs in 2 forms. */
+struct X509_name_st
+	{
+	STACK_OF(X509_NAME_ENTRY) *entries;
+	int modified;	/* true if 'bytes' needs to be built */
+#ifndef OPENSSL_NO_BUFFER
+	BUF_MEM *bytes;
+#else
+	char *bytes;
+#endif
+/*	unsigned long hash; Keep the hash around for lookups */
+	unsigned char *canon_enc;
+	int canon_enclen;
+	} /* X509_NAME */;
+
+DECLARE_STACK_OF(X509_NAME)
+
+#define X509_EX_V_NETSCAPE_HACK		0x8000
+#define X509_EX_V_INIT			0x0001
+typedef struct X509_extension_st
+	{
+	ASN1_OBJECT *object;
+	ASN1_BOOLEAN critical;
+	ASN1_OCTET_STRING *value;
+	} X509_EXTENSION;
+
+typedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;
+
+DECLARE_STACK_OF(X509_EXTENSION)
+DECLARE_ASN1_SET_OF(X509_EXTENSION)
+
+/* a sequence of these are used */
+typedef struct x509_attributes_st
+	{
+	ASN1_OBJECT *object;
+	int single; /* 0 for a set, 1 for a single item (which is wrong) */
+	union	{
+		char		*ptr;
+/* 0 */		STACK_OF(ASN1_TYPE) *set;
+/* 1 */		ASN1_TYPE	*single;
+		} value;
+	} X509_ATTRIBUTE;
+
+DECLARE_STACK_OF(X509_ATTRIBUTE)
+DECLARE_ASN1_SET_OF(X509_ATTRIBUTE)
+
+
+typedef struct X509_req_info_st
+	{
+	ASN1_ENCODING enc;
+	ASN1_INTEGER *version;
+	X509_NAME *subject;
+	X509_PUBKEY *pubkey;
+	/*  d=2 hl=2 l=  0 cons: cont: 00 */
+	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
+	} X509_REQ_INFO;
+
+typedef struct X509_req_st
+	{
+	X509_REQ_INFO *req_info;
+	X509_ALGOR *sig_alg;
+	ASN1_BIT_STRING *signature;
+	int references;
+	} X509_REQ;
+
+typedef struct x509_cinf_st
+	{
+	ASN1_INTEGER *version;		/* [ 0 ] default of v1 */
+	ASN1_INTEGER *serialNumber;
+	X509_ALGOR *signature;
+	X509_NAME *issuer;
+	X509_VAL *validity;
+	X509_NAME *subject;
+	X509_PUBKEY *key;
+	ASN1_BIT_STRING *issuerUID;		/* [ 1 ] optional in v2 */
+	ASN1_BIT_STRING *subjectUID;		/* [ 2 ] optional in v2 */
+	STACK_OF(X509_EXTENSION) *extensions;	/* [ 3 ] optional in v3 */
+	ASN1_ENCODING enc;
+	} X509_CINF;
+
+/* This stuff is certificate "auxiliary info"
+ * it contains details which are useful in certificate
+ * stores and databases. When used this is tagged onto
+ * the end of the certificate itself
+ */
+
+typedef struct x509_cert_aux_st
+	{
+	STACK_OF(ASN1_OBJECT) *trust;		/* trusted uses */
+	STACK_OF(ASN1_OBJECT) *reject;		/* rejected uses */
+	ASN1_UTF8STRING *alias;			/* "friendly name" */
+	ASN1_OCTET_STRING *keyid;		/* key id of private key */
+	STACK_OF(X509_ALGOR) *other;		/* other unspecified info */
+	} X509_CERT_AUX;
+
+struct x509_st
+	{
+	X509_CINF *cert_info;
+	X509_ALGOR *sig_alg;
+	ASN1_BIT_STRING *signature;
+	int valid;
+	int references;
+	char *name;
+	CRYPTO_EX_DATA ex_data;
+	/* These contain copies of various extension values */
+	long ex_pathlen;
+	long ex_pcpathlen;
+	unsigned long ex_flags;
+	unsigned long ex_kusage;
+	unsigned long ex_xkusage;
+	unsigned long ex_nscert;
+	ASN1_OCTET_STRING *skid;
+	AUTHORITY_KEYID *akid;
+	X509_POLICY_CACHE *policy_cache;
+	STACK_OF(DIST_POINT) *crldp;
+	STACK_OF(GENERAL_NAME) *altname;
+	NAME_CONSTRAINTS *nc;
+#ifndef OPENSSL_NO_RFC3779
+	STACK_OF(IPAddressFamily) *rfc3779_addr;
+	struct ASIdentifiers_st *rfc3779_asid;
+#endif
+#ifndef OPENSSL_NO_SHA
+	unsigned char sha1_hash[SHA_DIGEST_LENGTH];
+#endif
+	X509_CERT_AUX *aux;
+	} /* X509 */;
+
+DECLARE_STACK_OF(X509)
+DECLARE_ASN1_SET_OF(X509)
+
+/* This is used for a table of trust checking functions */
+
+typedef struct x509_trust_st {
+	int trust;
+	int flags;
+	int (*check_trust)(struct x509_trust_st *, X509 *, int);
+	char *name;
+	int arg1;
+	void *arg2;
+} X509_TRUST;
+
+DECLARE_STACK_OF(X509_TRUST)
+
+typedef struct x509_cert_pair_st {
+	X509 *forward;
+	X509 *reverse;
+} X509_CERT_PAIR;
+
+/* standard trust ids */
+
+#define X509_TRUST_DEFAULT	-1	/* Only valid in purpose settings */
+
+#define X509_TRUST_COMPAT	1
+#define X509_TRUST_SSL_CLIENT	2
+#define X509_TRUST_SSL_SERVER	3
+#define X509_TRUST_EMAIL	4
+#define X509_TRUST_OBJECT_SIGN	5
+#define X509_TRUST_OCSP_SIGN	6
+#define X509_TRUST_OCSP_REQUEST	7
+#define X509_TRUST_TSA		8
+
+/* Keep these up to date! */
+#define X509_TRUST_MIN		1
+#define X509_TRUST_MAX		8
+
+
+/* trust_flags values */
+#define	X509_TRUST_DYNAMIC 	1
+#define	X509_TRUST_DYNAMIC_NAME	2
+
+/* check_trust return codes */
+
+#define X509_TRUST_TRUSTED	1
+#define X509_TRUST_REJECTED	2
+#define X509_TRUST_UNTRUSTED	3
+
+/* Flags for X509_print_ex() */
+
+#define	X509_FLAG_COMPAT		0
+#define	X509_FLAG_NO_HEADER		1L
+#define	X509_FLAG_NO_VERSION		(1L << 1)
+#define	X509_FLAG_NO_SERIAL		(1L << 2)
+#define	X509_FLAG_NO_SIGNAME		(1L << 3)
+#define	X509_FLAG_NO_ISSUER		(1L << 4)
+#define	X509_FLAG_NO_VALIDITY		(1L << 5)
+#define	X509_FLAG_NO_SUBJECT		(1L << 6)
+#define	X509_FLAG_NO_PUBKEY		(1L << 7)
+#define	X509_FLAG_NO_EXTENSIONS		(1L << 8)
+#define	X509_FLAG_NO_SIGDUMP		(1L << 9)
+#define	X509_FLAG_NO_AUX		(1L << 10)
+#define	X509_FLAG_NO_ATTRIBUTES		(1L << 11)
+
+/* Flags specific to X509_NAME_print_ex() */	
+
+/* The field separator information */
+
+#define XN_FLAG_SEP_MASK	(0xf << 16)
+
+#define XN_FLAG_COMPAT		0		/* Traditional SSLeay: use old X509_NAME_print */
+#define XN_FLAG_SEP_COMMA_PLUS	(1 << 16)	/* RFC2253 ,+ */
+#define XN_FLAG_SEP_CPLUS_SPC	(2 << 16)	/* ,+ spaced: more readable */
+#define XN_FLAG_SEP_SPLUS_SPC	(3 << 16)	/* ;+ spaced */
+#define XN_FLAG_SEP_MULTILINE	(4 << 16)	/* One line per field */
+
+#define XN_FLAG_DN_REV		(1 << 20)	/* Reverse DN order */
+
+/* How the field name is shown */
+
+#define XN_FLAG_FN_MASK		(0x3 << 21)
+
+#define XN_FLAG_FN_SN		0		/* Object short name */
+#define XN_FLAG_FN_LN		(1 << 21)	/* Object long name */
+#define XN_FLAG_FN_OID		(2 << 21)	/* Always use OIDs */
+#define XN_FLAG_FN_NONE		(3 << 21)	/* No field names */
+
+#define XN_FLAG_SPC_EQ		(1 << 23)	/* Put spaces round '=' */
+
+/* This determines if we dump fields we don't recognise:
+ * RFC2253 requires this.
+ */
+
+#define XN_FLAG_DUMP_UNKNOWN_FIELDS (1 << 24)
+
+#define XN_FLAG_FN_ALIGN	(1 << 25)	/* Align field names to 20 characters */
+
+/* Complete set of RFC2253 flags */
+
+#define XN_FLAG_RFC2253 (ASN1_STRFLGS_RFC2253 | \
+			XN_FLAG_SEP_COMMA_PLUS | \
+			XN_FLAG_DN_REV | \
+			XN_FLAG_FN_SN | \
+			XN_FLAG_DUMP_UNKNOWN_FIELDS)
+
+/* readable oneline form */
+
+#define XN_FLAG_ONELINE (ASN1_STRFLGS_RFC2253 | \
+			ASN1_STRFLGS_ESC_QUOTE | \
+			XN_FLAG_SEP_CPLUS_SPC | \
+			XN_FLAG_SPC_EQ | \
+			XN_FLAG_FN_SN)
+
+/* readable multiline form */
+
+#define XN_FLAG_MULTILINE (ASN1_STRFLGS_ESC_CTRL | \
+			ASN1_STRFLGS_ESC_MSB | \
+			XN_FLAG_SEP_MULTILINE | \
+			XN_FLAG_SPC_EQ | \
+			XN_FLAG_FN_LN | \
+			XN_FLAG_FN_ALIGN)
+
+struct x509_revoked_st
+	{
+	ASN1_INTEGER *serialNumber;
+	ASN1_TIME *revocationDate;
+	STACK_OF(X509_EXTENSION) /* optional */ *extensions;
+	/* Set up if indirect CRL */
+	STACK_OF(GENERAL_NAME) *issuer;
+	/* Revocation reason */
+	int reason;
+	int sequence; /* load sequence */
+	};
+
+DECLARE_STACK_OF(X509_REVOKED)
+DECLARE_ASN1_SET_OF(X509_REVOKED)
+
+typedef struct X509_crl_info_st
+	{
+	ASN1_INTEGER *version;
+	X509_ALGOR *sig_alg;
+	X509_NAME *issuer;
+	ASN1_TIME *lastUpdate;
+	ASN1_TIME *nextUpdate;
+	STACK_OF(X509_REVOKED) *revoked;
+	STACK_OF(X509_EXTENSION) /* [0] */ *extensions;
+	ASN1_ENCODING enc;
+	} X509_CRL_INFO;
+
+struct X509_crl_st
+	{
+	/* actual signature */
+	X509_CRL_INFO *crl;
+	X509_ALGOR *sig_alg;
+	ASN1_BIT_STRING *signature;
+	int references;
+	int flags;
+	/* Copies of various extensions */
+	AUTHORITY_KEYID *akid;
+	ISSUING_DIST_POINT *idp;
+	/* Convenient breakdown of IDP */
+	int idp_flags;
+	int idp_reasons;
+	/* CRL and base CRL numbers for delta processing */
+	ASN1_INTEGER *crl_number;
+	ASN1_INTEGER *base_crl_number;
+#ifndef OPENSSL_NO_SHA
+	unsigned char sha1_hash[SHA_DIGEST_LENGTH];
+#endif
+	STACK_OF(GENERAL_NAMES) *issuers;
+	const X509_CRL_METHOD *meth;
+	void *meth_data;
+	} /* X509_CRL */;
+
+DECLARE_STACK_OF(X509_CRL)
+DECLARE_ASN1_SET_OF(X509_CRL)
+
+typedef struct private_key_st
+	{
+	int version;
+	/* The PKCS#8 data types */
+	X509_ALGOR *enc_algor;
+	ASN1_OCTET_STRING *enc_pkey;	/* encrypted pub key */
+
+	/* When decrypted, the following will not be NULL */
+	EVP_PKEY *dec_pkey;
+
+	/* used to encrypt and decrypt */
+	int key_length;
+	char *key_data;
+	int key_free;	/* true if we should auto free key_data */
+
+	/* expanded version of 'enc_algor' */
+	EVP_CIPHER_INFO cipher;
+
+	int references;
+	} X509_PKEY;
+
+#ifndef OPENSSL_NO_EVP
+typedef struct X509_info_st
+	{
+	X509 *x509;
+	X509_CRL *crl;
+	X509_PKEY *x_pkey;
+
+	EVP_CIPHER_INFO enc_cipher;
+	int enc_len;
+	char *enc_data;
+
+	int references;
+	} X509_INFO;
+
+DECLARE_STACK_OF(X509_INFO)
+#endif
+
+/* The next 2 structures and their 8 routines were sent to me by
+ * Pat Richard <patr@x509.com> and are used to manipulate
+ * Netscapes spki structures - useful if you are writing a CA web page
+ */
+typedef struct Netscape_spkac_st
+	{
+	X509_PUBKEY *pubkey;
+	ASN1_IA5STRING *challenge;	/* challenge sent in atlas >= PR2 */
+	} NETSCAPE_SPKAC;
+
+typedef struct Netscape_spki_st
+	{
+	NETSCAPE_SPKAC *spkac;	/* signed public key and challenge */
+	X509_ALGOR *sig_algor;
+	ASN1_BIT_STRING *signature;
+	} NETSCAPE_SPKI;
+
+/* Netscape certificate sequence structure */
+typedef struct Netscape_certificate_sequence
+	{
+	ASN1_OBJECT *type;
+	STACK_OF(X509) *certs;
+	} NETSCAPE_CERT_SEQUENCE;
+
+/* Unused (and iv length is wrong)
+typedef struct CBCParameter_st
+	{
+	unsigned char iv[8];
+	} CBC_PARAM;
+*/
+
+/* Password based encryption structure */
+
+typedef struct PBEPARAM_st {
+ASN1_OCTET_STRING *salt;
+ASN1_INTEGER *iter;
+} PBEPARAM;
+
+/* Password based encryption V2 structures */
+
+typedef struct PBE2PARAM_st {
+X509_ALGOR *keyfunc;
+X509_ALGOR *encryption;
+} PBE2PARAM;
+
+typedef struct PBKDF2PARAM_st {
+ASN1_TYPE *salt;	/* Usually OCTET STRING but could be anything */
+ASN1_INTEGER *iter;
+ASN1_INTEGER *keylength;
+X509_ALGOR *prf;
+} PBKDF2PARAM;
+
+
+/* PKCS#8 private key info structure */
+
+struct pkcs8_priv_key_info_st
+        {
+        int broken;     /* Flag for various broken formats */
+#define PKCS8_OK		0
+#define PKCS8_NO_OCTET		1
+#define PKCS8_EMBEDDED_PARAM	2
+#define PKCS8_NS_DB		3
+#define PKCS8_NEG_PRIVKEY	4
+        ASN1_INTEGER *version;
+        X509_ALGOR *pkeyalg;
+        ASN1_TYPE *pkey; /* Should be OCTET STRING but some are broken */
+        STACK_OF(X509_ATTRIBUTE) *attributes;
+        };
+
+#ifdef  __cplusplus
+}
+#endif
+
+#include <openssl/x509_vfy.h>
+#include <openssl/pkcs7.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define X509_EXT_PACK_UNKNOWN	1
+#define X509_EXT_PACK_STRING	2
+
+#define		X509_get_version(x) ASN1_INTEGER_get((x)->cert_info->version)
+/* #define	X509_get_serialNumber(x) ((x)->cert_info->serialNumber) */
+#define		X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)
+#define		X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)
+#define		X509_extract_key(x)	X509_get_pubkey(x) /*****/
+#define		X509_REQ_get_version(x) ASN1_INTEGER_get((x)->req_info->version)
+#define		X509_REQ_get_subject_name(x) ((x)->req_info->subject)
+#define		X509_REQ_extract_key(a)	X509_REQ_get_pubkey(a)
+#define		X509_name_cmp(a,b)	X509_NAME_cmp((a),(b))
+#define		X509_get_signature_type(x) EVP_PKEY_type(OBJ_obj2nid((x)->sig_alg->algorithm))
+
+#define		X509_CRL_get_version(x) ASN1_INTEGER_get((x)->crl->version)
+#define 	X509_CRL_get_lastUpdate(x) ((x)->crl->lastUpdate)
+#define 	X509_CRL_get_nextUpdate(x) ((x)->crl->nextUpdate)
+#define		X509_CRL_get_issuer(x) ((x)->crl->issuer)
+#define		X509_CRL_get_REVOKED(x) ((x)->crl->revoked)
+
+void X509_CRL_set_default_method(const X509_CRL_METHOD *meth);
+X509_CRL_METHOD *X509_CRL_METHOD_new(
+	int (*crl_init)(X509_CRL *crl),
+	int (*crl_free)(X509_CRL *crl),
+	int (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,
+				ASN1_INTEGER *ser, X509_NAME *issuer),
+	int (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk));
+void X509_CRL_METHOD_free(X509_CRL_METHOD *m);
+
+void X509_CRL_set_meth_data(X509_CRL *crl, void *dat);
+void *X509_CRL_get_meth_data(X509_CRL *crl);
+
+/* This one is only used so that a binary form can output, as in
+ * i2d_X509_NAME(X509_get_X509_PUBKEY(x),&buf) */
+#define 	X509_get_X509_PUBKEY(x) ((x)->cert_info->key)
+
+
+const char *X509_verify_cert_error_string(long n);
+
+#ifndef OPENSSL_NO_EVP
+int X509_verify(X509 *a, EVP_PKEY *r);
+
+int X509_REQ_verify(X509_REQ *a, EVP_PKEY *r);
+int X509_CRL_verify(X509_CRL *a, EVP_PKEY *r);
+int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r);
+
+NETSCAPE_SPKI * NETSCAPE_SPKI_b64_decode(const char *str, int len);
+char * NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *x);
+EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x);
+int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey);
+
+int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki);
+
+int X509_signature_dump(BIO *bp,const ASN1_STRING *sig, int indent);
+int X509_signature_print(BIO *bp,X509_ALGOR *alg, ASN1_STRING *sig);
+
+int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
+int X509_sign_ctx(X509 *x, EVP_MD_CTX *ctx);
+int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md);
+int X509_REQ_sign_ctx(X509_REQ *x, EVP_MD_CTX *ctx);
+int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md);
+int X509_CRL_sign_ctx(X509_CRL *x, EVP_MD_CTX *ctx);
+int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md);
+
+int X509_pubkey_digest(const X509 *data,const EVP_MD *type,
+		unsigned char *md, unsigned int *len);
+int X509_digest(const X509 *data,const EVP_MD *type,
+		unsigned char *md, unsigned int *len);
+int X509_CRL_digest(const X509_CRL *data,const EVP_MD *type,
+		unsigned char *md, unsigned int *len);
+int X509_REQ_digest(const X509_REQ *data,const EVP_MD *type,
+		unsigned char *md, unsigned int *len);
+int X509_NAME_digest(const X509_NAME *data,const EVP_MD *type,
+		unsigned char *md, unsigned int *len);
+#endif
+
+#ifndef OPENSSL_NO_FP_API
+X509 *d2i_X509_fp(FILE *fp, X509 **x509);
+int i2d_X509_fp(FILE *fp,X509 *x509);
+X509_CRL *d2i_X509_CRL_fp(FILE *fp,X509_CRL **crl);
+int i2d_X509_CRL_fp(FILE *fp,X509_CRL *crl);
+X509_REQ *d2i_X509_REQ_fp(FILE *fp,X509_REQ **req);
+int i2d_X509_REQ_fp(FILE *fp,X509_REQ *req);
+#ifndef OPENSSL_NO_RSA
+RSA *d2i_RSAPrivateKey_fp(FILE *fp,RSA **rsa);
+int i2d_RSAPrivateKey_fp(FILE *fp,RSA *rsa);
+RSA *d2i_RSAPublicKey_fp(FILE *fp,RSA **rsa);
+int i2d_RSAPublicKey_fp(FILE *fp,RSA *rsa);
+RSA *d2i_RSA_PUBKEY_fp(FILE *fp,RSA **rsa);
+int i2d_RSA_PUBKEY_fp(FILE *fp,RSA *rsa);
+#endif
+#ifndef OPENSSL_NO_DSA
+DSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa);
+int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);
+DSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);
+int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);
+#endif
+#ifndef OPENSSL_NO_EC
+EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);
+int   i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);
+EC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey);
+int   i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey);
+#endif
+X509_SIG *d2i_PKCS8_fp(FILE *fp,X509_SIG **p8);
+int i2d_PKCS8_fp(FILE *fp,X509_SIG *p8);
+PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,
+						PKCS8_PRIV_KEY_INFO **p8inf);
+int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,PKCS8_PRIV_KEY_INFO *p8inf);
+int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key);
+int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey);
+EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);
+int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey);
+EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);
+#endif
+
+#ifndef OPENSSL_NO_BIO
+X509 *d2i_X509_bio(BIO *bp,X509 **x509);
+int i2d_X509_bio(BIO *bp,X509 *x509);
+X509_CRL *d2i_X509_CRL_bio(BIO *bp,X509_CRL **crl);
+int i2d_X509_CRL_bio(BIO *bp,X509_CRL *crl);
+X509_REQ *d2i_X509_REQ_bio(BIO *bp,X509_REQ **req);
+int i2d_X509_REQ_bio(BIO *bp,X509_REQ *req);
+#ifndef OPENSSL_NO_RSA
+RSA *d2i_RSAPrivateKey_bio(BIO *bp,RSA **rsa);
+int i2d_RSAPrivateKey_bio(BIO *bp,RSA *rsa);
+RSA *d2i_RSAPublicKey_bio(BIO *bp,RSA **rsa);
+int i2d_RSAPublicKey_bio(BIO *bp,RSA *rsa);
+RSA *d2i_RSA_PUBKEY_bio(BIO *bp,RSA **rsa);
+int i2d_RSA_PUBKEY_bio(BIO *bp,RSA *rsa);
+#endif
+#ifndef OPENSSL_NO_DSA
+DSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa);
+int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);
+DSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);
+int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);
+#endif
+#ifndef OPENSSL_NO_EC
+EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);
+int   i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);
+EC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);
+int   i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);
+#endif
+X509_SIG *d2i_PKCS8_bio(BIO *bp,X509_SIG **p8);
+int i2d_PKCS8_bio(BIO *bp,X509_SIG *p8);
+PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
+						PKCS8_PRIV_KEY_INFO **p8inf);
+int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,PKCS8_PRIV_KEY_INFO *p8inf);
+int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key);
+int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey);
+EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);
+int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);
+EVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);
+#endif
+
+X509 *X509_dup(X509 *x509);
+X509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa);
+X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *ex);
+X509_CRL *X509_CRL_dup(X509_CRL *crl);
+X509_REQ *X509_REQ_dup(X509_REQ *req);
+X509_ALGOR *X509_ALGOR_dup(X509_ALGOR *xn);
+int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype, void *pval);
+void X509_ALGOR_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval,
+						X509_ALGOR *algor);
+void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md);
+
+X509_NAME *X509_NAME_dup(X509_NAME *xn);
+X509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne);
+
+int		X509_cmp_time(const ASN1_TIME *s, time_t *t);
+int		X509_cmp_current_time(const ASN1_TIME *s);
+ASN1_TIME *	X509_time_adj(ASN1_TIME *s, long adj, time_t *t);
+ASN1_TIME *	X509_time_adj_ex(ASN1_TIME *s,
+				int offset_day, long offset_sec, time_t *t);
+ASN1_TIME *	X509_gmtime_adj(ASN1_TIME *s, long adj);
+
+const char *	X509_get_default_cert_area(void );
+const char *	X509_get_default_cert_dir(void );
+const char *	X509_get_default_cert_file(void );
+const char *	X509_get_default_cert_dir_env(void );
+const char *	X509_get_default_cert_file_env(void );
+const char *	X509_get_default_private_dir(void );
+
+X509_REQ *	X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
+X509 *		X509_REQ_to_X509(X509_REQ *r, int days,EVP_PKEY *pkey);
+
+DECLARE_ASN1_FUNCTIONS(X509_ALGOR)
+DECLARE_ASN1_ENCODE_FUNCTIONS(X509_ALGORS, X509_ALGORS, X509_ALGORS)
+DECLARE_ASN1_FUNCTIONS(X509_VAL)
+
+DECLARE_ASN1_FUNCTIONS(X509_PUBKEY)
+
+int		X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey);
+EVP_PKEY *	X509_PUBKEY_get(X509_PUBKEY *key);
+int		X509_get_pubkey_parameters(EVP_PKEY *pkey,
+					   STACK_OF(X509) *chain);
+int		i2d_PUBKEY(EVP_PKEY *a,unsigned char **pp);
+EVP_PKEY *	d2i_PUBKEY(EVP_PKEY **a,const unsigned char **pp,
+			long length);
+#ifndef OPENSSL_NO_RSA
+int		i2d_RSA_PUBKEY(RSA *a,unsigned char **pp);
+RSA *		d2i_RSA_PUBKEY(RSA **a,const unsigned char **pp,
+			long length);
+#endif
+#ifndef OPENSSL_NO_DSA
+int		i2d_DSA_PUBKEY(DSA *a,unsigned char **pp);
+DSA *		d2i_DSA_PUBKEY(DSA **a,const unsigned char **pp,
+			long length);
+#endif
+#ifndef OPENSSL_NO_EC
+int		i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp);
+EC_KEY 		*d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp,
+			long length);
+#endif
+
+DECLARE_ASN1_FUNCTIONS(X509_SIG)
+DECLARE_ASN1_FUNCTIONS(X509_REQ_INFO)
+DECLARE_ASN1_FUNCTIONS(X509_REQ)
+
+DECLARE_ASN1_FUNCTIONS(X509_ATTRIBUTE)
+X509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int atrtype, void *value);
+
+DECLARE_ASN1_FUNCTIONS(X509_EXTENSION)
+DECLARE_ASN1_ENCODE_FUNCTIONS(X509_EXTENSIONS, X509_EXTENSIONS, X509_EXTENSIONS)
+
+DECLARE_ASN1_FUNCTIONS(X509_NAME_ENTRY)
+
+DECLARE_ASN1_FUNCTIONS(X509_NAME)
+
+int		X509_NAME_set(X509_NAME **xn, X509_NAME *name);
+
+DECLARE_ASN1_FUNCTIONS(X509_CINF)
+
+DECLARE_ASN1_FUNCTIONS(X509)
+DECLARE_ASN1_FUNCTIONS(X509_CERT_AUX)
+
+DECLARE_ASN1_FUNCTIONS(X509_CERT_PAIR)
+
+int X509_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int X509_set_ex_data(X509 *r, int idx, void *arg);
+void *X509_get_ex_data(X509 *r, int idx);
+int		i2d_X509_AUX(X509 *a,unsigned char **pp);
+X509 *		d2i_X509_AUX(X509 **a,const unsigned char **pp,long length);
+
+int X509_alias_set1(X509 *x, unsigned char *name, int len);
+int X509_keyid_set1(X509 *x, unsigned char *id, int len);
+unsigned char * X509_alias_get0(X509 *x, int *len);
+unsigned char * X509_keyid_get0(X509 *x, int *len);
+int (*X509_TRUST_set_default(int (*trust)(int , X509 *, int)))(int, X509 *, int);
+int X509_TRUST_set(int *t, int trust);
+int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);
+int X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj);
+void X509_trust_clear(X509 *x);
+void X509_reject_clear(X509 *x);
+
+DECLARE_ASN1_FUNCTIONS(X509_REVOKED)
+DECLARE_ASN1_FUNCTIONS(X509_CRL_INFO)
+DECLARE_ASN1_FUNCTIONS(X509_CRL)
+
+int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
+int X509_CRL_get0_by_serial(X509_CRL *crl,
+		X509_REVOKED **ret, ASN1_INTEGER *serial);
+int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x);
+
+X509_PKEY *	X509_PKEY_new(void );
+void		X509_PKEY_free(X509_PKEY *a);
+int		i2d_X509_PKEY(X509_PKEY *a,unsigned char **pp);
+X509_PKEY *	d2i_X509_PKEY(X509_PKEY **a,const unsigned char **pp,long length);
+
+DECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKI)
+DECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKAC)
+DECLARE_ASN1_FUNCTIONS(NETSCAPE_CERT_SEQUENCE)
+
+#ifndef OPENSSL_NO_EVP
+X509_INFO *	X509_INFO_new(void);
+void		X509_INFO_free(X509_INFO *a);
+char *		X509_NAME_oneline(X509_NAME *a,char *buf,int size);
+
+int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *algor1,
+		ASN1_BIT_STRING *signature,char *data,EVP_PKEY *pkey);
+
+int ASN1_digest(i2d_of_void *i2d,const EVP_MD *type,char *data,
+		unsigned char *md,unsigned int *len);
+
+int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1,
+	      X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
+	      char *data,EVP_PKEY *pkey, const EVP_MD *type);
+
+int ASN1_item_digest(const ASN1_ITEM *it,const EVP_MD *type,void *data,
+	unsigned char *md,unsigned int *len);
+
+int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1,
+	ASN1_BIT_STRING *signature,void *data,EVP_PKEY *pkey);
+
+int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2,
+	ASN1_BIT_STRING *signature,
+	void *data, EVP_PKEY *pkey, const EVP_MD *type);
+int ASN1_item_sign_ctx(const ASN1_ITEM *it,
+		X509_ALGOR *algor1, X509_ALGOR *algor2,
+	     	ASN1_BIT_STRING *signature, void *asn, EVP_MD_CTX *ctx);
+#endif
+
+int 		X509_set_version(X509 *x,long version);
+int 		X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial);
+ASN1_INTEGER *	X509_get_serialNumber(X509 *x);
+int 		X509_set_issuer_name(X509 *x, X509_NAME *name);
+X509_NAME *	X509_get_issuer_name(X509 *a);
+int 		X509_set_subject_name(X509 *x, X509_NAME *name);
+X509_NAME *	X509_get_subject_name(X509 *a);
+int 		X509_set_notBefore(X509 *x, const ASN1_TIME *tm);
+int 		X509_set_notAfter(X509 *x, const ASN1_TIME *tm);
+int 		X509_set_pubkey(X509 *x, EVP_PKEY *pkey);
+EVP_PKEY *	X509_get_pubkey(X509 *x);
+ASN1_BIT_STRING * X509_get0_pubkey_bitstr(const X509 *x);
+int		X509_certificate_type(X509 *x,EVP_PKEY *pubkey /* optional */);
+
+int		X509_REQ_set_version(X509_REQ *x,long version);
+int		X509_REQ_set_subject_name(X509_REQ *req,X509_NAME *name);
+int		X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey);
+EVP_PKEY *	X509_REQ_get_pubkey(X509_REQ *req);
+int		X509_REQ_extension_nid(int nid);
+int *		X509_REQ_get_extension_nids(void);
+void		X509_REQ_set_extension_nids(int *nids);
+STACK_OF(X509_EXTENSION) *X509_REQ_get_extensions(X509_REQ *req);
+int X509_REQ_add_extensions_nid(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts,
+				int nid);
+int X509_REQ_add_extensions(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts);
+int X509_REQ_get_attr_count(const X509_REQ *req);
+int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid,
+			  int lastpos);
+int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj,
+			  int lastpos);
+X509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc);
+X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc);
+int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr);
+int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,
+			const ASN1_OBJECT *obj, int type,
+			const unsigned char *bytes, int len);
+int X509_REQ_add1_attr_by_NID(X509_REQ *req,
+			int nid, int type,
+			const unsigned char *bytes, int len);
+int X509_REQ_add1_attr_by_txt(X509_REQ *req,
+			const char *attrname, int type,
+			const unsigned char *bytes, int len);
+
+int X509_CRL_set_version(X509_CRL *x, long version);
+int X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name);
+int X509_CRL_set_lastUpdate(X509_CRL *x, const ASN1_TIME *tm);
+int X509_CRL_set_nextUpdate(X509_CRL *x, const ASN1_TIME *tm);
+int X509_CRL_sort(X509_CRL *crl);
+
+int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial);
+int X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm);
+
+int		X509_REQ_check_private_key(X509_REQ *x509,EVP_PKEY *pkey);
+
+int		X509_check_private_key(X509 *x509,EVP_PKEY *pkey);
+
+int		X509_issuer_and_serial_cmp(const X509 *a, const X509 *b);
+unsigned long	X509_issuer_and_serial_hash(X509 *a);
+
+int		X509_issuer_name_cmp(const X509 *a, const X509 *b);
+unsigned long	X509_issuer_name_hash(X509 *a);
+
+int		X509_subject_name_cmp(const X509 *a, const X509 *b);
+unsigned long	X509_subject_name_hash(X509 *x);
+
+#ifndef OPENSSL_NO_MD5
+unsigned long	X509_issuer_name_hash_old(X509 *a);
+unsigned long	X509_subject_name_hash_old(X509 *x);
+#endif
+
+int		X509_cmp(const X509 *a, const X509 *b);
+int		X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b);
+unsigned long	X509_NAME_hash(X509_NAME *x);
+unsigned long	X509_NAME_hash_old(X509_NAME *x);
+
+int		X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b);
+int		X509_CRL_match(const X509_CRL *a, const X509_CRL *b);
+#ifndef OPENSSL_NO_FP_API
+int		X509_print_ex_fp(FILE *bp,X509 *x, unsigned long nmflag, unsigned long cflag);
+int		X509_print_fp(FILE *bp,X509 *x);
+int		X509_CRL_print_fp(FILE *bp,X509_CRL *x);
+int		X509_REQ_print_fp(FILE *bp,X509_REQ *req);
+int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags);
+#endif
+
+#ifndef OPENSSL_NO_BIO
+int		X509_NAME_print(BIO *bp, X509_NAME *name, int obase);
+int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags);
+int		X509_print_ex(BIO *bp,X509 *x, unsigned long nmflag, unsigned long cflag);
+int		X509_print(BIO *bp,X509 *x);
+int		X509_ocspid_print(BIO *bp,X509 *x);
+int		X509_CERT_AUX_print(BIO *bp,X509_CERT_AUX *x, int indent);
+int		X509_CRL_print(BIO *bp,X509_CRL *x);
+int		X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflag, unsigned long cflag);
+int		X509_REQ_print(BIO *bp,X509_REQ *req);
+#endif
+
+int 		X509_NAME_entry_count(X509_NAME *name);
+int 		X509_NAME_get_text_by_NID(X509_NAME *name, int nid,
+			char *buf,int len);
+int		X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj,
+			char *buf,int len);
+
+/* NOTE: you should be passsing -1, not 0 as lastpos.  The functions that use
+ * lastpos, search after that position on. */
+int 		X509_NAME_get_index_by_NID(X509_NAME *name,int nid,int lastpos);
+int 		X509_NAME_get_index_by_OBJ(X509_NAME *name,ASN1_OBJECT *obj,
+			int lastpos);
+X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc);
+X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);
+int 		X509_NAME_add_entry(X509_NAME *name,X509_NAME_ENTRY *ne,
+			int loc, int set);
+int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type,
+			unsigned char *bytes, int len, int loc, int set);
+int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,
+			unsigned char *bytes, int len, int loc, int set);
+X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,
+		const char *field, int type, const unsigned char *bytes, int len);
+X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,
+			int type,unsigned char *bytes, int len);
+int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,
+			const unsigned char *bytes, int len, int loc, int set);
+X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,
+			ASN1_OBJECT *obj, int type,const unsigned char *bytes,
+			int len);
+int 		X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne,
+			ASN1_OBJECT *obj);
+int 		X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,
+			const unsigned char *bytes, int len);
+ASN1_OBJECT *	X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne);
+ASN1_STRING *	X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne);
+
+int		X509v3_get_ext_count(const STACK_OF(X509_EXTENSION) *x);
+int		X509v3_get_ext_by_NID(const STACK_OF(X509_EXTENSION) *x,
+				      int nid, int lastpos);
+int		X509v3_get_ext_by_OBJ(const STACK_OF(X509_EXTENSION) *x,
+				      ASN1_OBJECT *obj,int lastpos);
+int		X509v3_get_ext_by_critical(const STACK_OF(X509_EXTENSION) *x,
+					   int crit, int lastpos);
+X509_EXTENSION *X509v3_get_ext(const STACK_OF(X509_EXTENSION) *x, int loc);
+X509_EXTENSION *X509v3_delete_ext(STACK_OF(X509_EXTENSION) *x, int loc);
+STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
+					 X509_EXTENSION *ex, int loc);
+
+int		X509_get_ext_count(X509 *x);
+int		X509_get_ext_by_NID(X509 *x, int nid, int lastpos);
+int		X509_get_ext_by_OBJ(X509 *x,ASN1_OBJECT *obj,int lastpos);
+int		X509_get_ext_by_critical(X509 *x, int crit, int lastpos);
+X509_EXTENSION *X509_get_ext(X509 *x, int loc);
+X509_EXTENSION *X509_delete_ext(X509 *x, int loc);
+int		X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc);
+void	*	X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx);
+int		X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,
+							unsigned long flags);
+
+int		X509_CRL_get_ext_count(X509_CRL *x);
+int		X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos);
+int		X509_CRL_get_ext_by_OBJ(X509_CRL *x,ASN1_OBJECT *obj,int lastpos);
+int		X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos);
+X509_EXTENSION *X509_CRL_get_ext(X509_CRL *x, int loc);
+X509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc);
+int		X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc);
+void	*	X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx);
+int		X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,
+							unsigned long flags);
+
+int		X509_REVOKED_get_ext_count(X509_REVOKED *x);
+int		X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos);
+int		X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x,ASN1_OBJECT *obj,int lastpos);
+int		X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos);
+X509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x, int loc);
+X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc);
+int		X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc);
+void	*	X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx);
+int		X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,
+							unsigned long flags);
+
+X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex,
+			int nid, int crit, ASN1_OCTET_STRING *data);
+X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex,
+			ASN1_OBJECT *obj,int crit,ASN1_OCTET_STRING *data);
+int		X509_EXTENSION_set_object(X509_EXTENSION *ex,ASN1_OBJECT *obj);
+int		X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit);
+int		X509_EXTENSION_set_data(X509_EXTENSION *ex,
+			ASN1_OCTET_STRING *data);
+ASN1_OBJECT *	X509_EXTENSION_get_object(X509_EXTENSION *ex);
+ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ne);
+int		X509_EXTENSION_get_critical(X509_EXTENSION *ex);
+
+int X509at_get_attr_count(const STACK_OF(X509_ATTRIBUTE) *x);
+int X509at_get_attr_by_NID(const STACK_OF(X509_ATTRIBUTE) *x, int nid,
+			  int lastpos);
+int X509at_get_attr_by_OBJ(const STACK_OF(X509_ATTRIBUTE) *sk, ASN1_OBJECT *obj,
+			  int lastpos);
+X509_ATTRIBUTE *X509at_get_attr(const STACK_OF(X509_ATTRIBUTE) *x, int loc);
+X509_ATTRIBUTE *X509at_delete_attr(STACK_OF(X509_ATTRIBUTE) *x, int loc);
+STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr(STACK_OF(X509_ATTRIBUTE) **x,
+					 X509_ATTRIBUTE *attr);
+STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_OBJ(STACK_OF(X509_ATTRIBUTE) **x,
+			const ASN1_OBJECT *obj, int type,
+			const unsigned char *bytes, int len);
+STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_NID(STACK_OF(X509_ATTRIBUTE) **x,
+			int nid, int type,
+			const unsigned char *bytes, int len);
+STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_txt(STACK_OF(X509_ATTRIBUTE) **x,
+			const char *attrname, int type,
+			const unsigned char *bytes, int len);
+void *X509at_get0_data_by_OBJ(STACK_OF(X509_ATTRIBUTE) *x,
+				ASN1_OBJECT *obj, int lastpos, int type);
+X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,
+	     int atrtype, const void *data, int len);
+X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,
+	     const ASN1_OBJECT *obj, int atrtype, const void *data, int len);
+X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr,
+		const char *atrname, int type, const unsigned char *bytes, int len);
+int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj);
+int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype, const void *data, int len);
+void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,
+					int atrtype, void *data);
+int X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr);
+ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);
+ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx);
+
+int EVP_PKEY_get_attr_count(const EVP_PKEY *key);
+int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid,
+			  int lastpos);
+int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,
+			  int lastpos);
+X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc);
+X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc);
+int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr);
+int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,
+			const ASN1_OBJECT *obj, int type,
+			const unsigned char *bytes, int len);
+int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,
+			int nid, int type,
+			const unsigned char *bytes, int len);
+int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,
+			const char *attrname, int type,
+			const unsigned char *bytes, int len);
+
+int		X509_verify_cert(X509_STORE_CTX *ctx);
+
+/* lookup a cert from a X509 STACK */
+X509 *X509_find_by_issuer_and_serial(STACK_OF(X509) *sk,X509_NAME *name,
+				     ASN1_INTEGER *serial);
+X509 *X509_find_by_subject(STACK_OF(X509) *sk,X509_NAME *name);
+
+DECLARE_ASN1_FUNCTIONS(PBEPARAM)
+DECLARE_ASN1_FUNCTIONS(PBE2PARAM)
+DECLARE_ASN1_FUNCTIONS(PBKDF2PARAM)
+
+int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
+				const unsigned char *salt, int saltlen);
+
+X509_ALGOR *PKCS5_pbe_set(int alg, int iter,
+				const unsigned char *salt, int saltlen);
+X509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter,
+					 unsigned char *salt, int saltlen);
+X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
+				 unsigned char *salt, int saltlen,
+				 unsigned char *aiv, int prf_nid);
+
+X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
+				int prf_nid, int keylen);
+
+/* PKCS#8 utilities */
+
+DECLARE_ASN1_FUNCTIONS(PKCS8_PRIV_KEY_INFO)
+
+EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8);
+PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey);
+PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken);
+PKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken);
+
+int PKCS8_pkey_set0(PKCS8_PRIV_KEY_INFO *priv, ASN1_OBJECT *aobj,
+			int version, int ptype, void *pval,
+				unsigned char *penc, int penclen);
+int PKCS8_pkey_get0(ASN1_OBJECT **ppkalg,
+		const unsigned char **pk, int *ppklen,
+		X509_ALGOR **pa,
+		PKCS8_PRIV_KEY_INFO *p8);
+
+int X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,
+					int ptype, void *pval,
+					unsigned char *penc, int penclen);
+int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,
+		const unsigned char **pk, int *ppklen,
+		X509_ALGOR **pa,
+		X509_PUBKEY *pub);
+
+int X509_check_trust(X509 *x, int id, int flags);
+int X509_TRUST_get_count(void);
+X509_TRUST * X509_TRUST_get0(int idx);
+int X509_TRUST_get_by_id(int id);
+int X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),
+					char *name, int arg1, void *arg2);
+void X509_TRUST_cleanup(void);
+int X509_TRUST_get_flags(X509_TRUST *xp);
+char *X509_TRUST_get0_name(X509_TRUST *xp);
+int X509_TRUST_get_trust(X509_TRUST *xp);
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_X509_strings(void);
+
+/* Error codes for the X509 functions. */
+
+/* Function codes. */
+#define X509_F_ADD_CERT_DIR				 100
+#define X509_F_BY_FILE_CTRL				 101
+#define X509_F_CHECK_POLICY				 145
+#define X509_F_DIR_CTRL					 102
+#define X509_F_GET_CERT_BY_SUBJECT			 103
+#define X509_F_NETSCAPE_SPKI_B64_DECODE			 129
+#define X509_F_NETSCAPE_SPKI_B64_ENCODE			 130
+#define X509_F_X509AT_ADD1_ATTR				 135
+#define X509_F_X509V3_ADD_EXT				 104
+#define X509_F_X509_ATTRIBUTE_CREATE_BY_NID		 136
+#define X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ		 137
+#define X509_F_X509_ATTRIBUTE_CREATE_BY_TXT		 140
+#define X509_F_X509_ATTRIBUTE_GET0_DATA			 139
+#define X509_F_X509_ATTRIBUTE_SET1_DATA			 138
+#define X509_F_X509_CHECK_PRIVATE_KEY			 128
+#define X509_F_X509_CRL_PRINT_FP			 147
+#define X509_F_X509_EXTENSION_CREATE_BY_NID		 108
+#define X509_F_X509_EXTENSION_CREATE_BY_OBJ		 109
+#define X509_F_X509_GET_PUBKEY_PARAMETERS		 110
+#define X509_F_X509_LOAD_CERT_CRL_FILE			 132
+#define X509_F_X509_LOAD_CERT_FILE			 111
+#define X509_F_X509_LOAD_CRL_FILE			 112
+#define X509_F_X509_NAME_ADD_ENTRY			 113
+#define X509_F_X509_NAME_ENTRY_CREATE_BY_NID		 114
+#define X509_F_X509_NAME_ENTRY_CREATE_BY_TXT		 131
+#define X509_F_X509_NAME_ENTRY_SET_OBJECT		 115
+#define X509_F_X509_NAME_ONELINE			 116
+#define X509_F_X509_NAME_PRINT				 117
+#define X509_F_X509_PRINT_EX_FP				 118
+#define X509_F_X509_PUBKEY_GET				 119
+#define X509_F_X509_PUBKEY_SET				 120
+#define X509_F_X509_REQ_CHECK_PRIVATE_KEY		 144
+#define X509_F_X509_REQ_PRINT_EX			 121
+#define X509_F_X509_REQ_PRINT_FP			 122
+#define X509_F_X509_REQ_TO_X509				 123
+#define X509_F_X509_STORE_ADD_CERT			 124
+#define X509_F_X509_STORE_ADD_CRL			 125
+#define X509_F_X509_STORE_CTX_GET1_ISSUER		 146
+#define X509_F_X509_STORE_CTX_INIT			 143
+#define X509_F_X509_STORE_CTX_NEW			 142
+#define X509_F_X509_STORE_CTX_PURPOSE_INHERIT		 134
+#define X509_F_X509_TO_X509_REQ				 126
+#define X509_F_X509_TRUST_ADD				 133
+#define X509_F_X509_TRUST_SET				 141
+#define X509_F_X509_VERIFY_CERT				 127
+
+/* Reason codes. */
+#define X509_R_BAD_X509_FILETYPE			 100
+#define X509_R_BASE64_DECODE_ERROR			 118
+#define X509_R_CANT_CHECK_DH_KEY			 114
+#define X509_R_CERT_ALREADY_IN_HASH_TABLE		 101
+#define X509_R_ERR_ASN1_LIB				 102
+#define X509_R_INVALID_DIRECTORY			 113
+#define X509_R_INVALID_FIELD_NAME			 119
+#define X509_R_INVALID_TRUST				 123
+#define X509_R_KEY_TYPE_MISMATCH			 115
+#define X509_R_KEY_VALUES_MISMATCH			 116
+#define X509_R_LOADING_CERT_DIR				 103
+#define X509_R_LOADING_DEFAULTS				 104
+#define X509_R_METHOD_NOT_SUPPORTED			 124
+#define X509_R_NO_CERT_SET_FOR_US_TO_VERIFY		 105
+#define X509_R_PUBLIC_KEY_DECODE_ERROR			 125
+#define X509_R_PUBLIC_KEY_ENCODE_ERROR			 126
+#define X509_R_SHOULD_RETRY				 106
+#define X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN	 107
+#define X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY		 108
+#define X509_R_UNKNOWN_KEY_TYPE				 117
+#define X509_R_UNKNOWN_NID				 109
+#define X509_R_UNKNOWN_PURPOSE_ID			 121
+#define X509_R_UNKNOWN_TRUST_ID				 120
+#define X509_R_UNSUPPORTED_ALGORITHM			 111
+#define X509_R_WRONG_LOOKUP_TYPE			 112
+#define X509_R_WRONG_TYPE				 122
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Nur tools-org/vboot_utils/src/host/include/vboot_host.h tools/vboot_utils/src/host/include/vboot_host.h
--- tools-org/vboot_utils/src/host/include/vboot_host.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/include/vboot_host.h	2014-04-27 13:03:45.776118604 +0000
@@ -0,0 +1,62 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * vboot-related functions exported for use by userspace programs
+ */
+
+#ifndef VBOOT_HOST_H_
+#define VBOOT_HOST_H_
+#include <inttypes.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+/****************************************************************************/
+/* EFI GPT manipulation */
+
+#include "cgpt_params.h"
+
+/* partition table manipulation */
+int CgptCreate(CgptCreateParams *params);
+int CgptAdd(CgptAddParams *params);
+int CgptSetAttributes(CgptAddParams *params);
+int CgptGetPartitionDetails(CgptAddParams *params);
+int CgptBoot(CgptBootParams *params);
+int CgptGetBootPartitionNumber(CgptBootParams *params);
+int CgptShow(CgptShowParams *params);
+int CgptGetNumNonEmptyPartitions(CgptShowParams *params);
+int CgptRepair(CgptRepairParams *params);
+int CgptPrioritize(CgptPrioritizeParams *params);
+void CgptFind(CgptFindParams *params);
+int CgptLegacy(CgptLegacyParams *params);
+
+/* GUID conversion functions. Accepted format:
+ *
+ *   "C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
+ *
+ * At least GUID_STRLEN bytes should be reserved in 'str' (included the tailing
+ * '\0').
+ */
+#define GUID_STRLEN 37
+int StrToGuid(const char *str, Guid *guid);
+void GuidToStr(const Guid *guid, char *str, unsigned int buflen);
+int GuidEqual(const Guid *guid1, const Guid *guid2);
+int GuidIsZero(const Guid *guid);
+
+
+/****************************************************************************/
+/* Kernel command line */
+
+/* TODO(wfrichar): This needs a better location */
+#define MAX_KERNEL_CONFIG_SIZE     4096
+
+/* Use this to obtain the body load address from the kernel preamble */
+#define USE_PREAMBLE_LOAD_ADDR     (~0)
+
+/* Returns a new copy of the kernel cmdline. The caller must free it. */
+char *FindKernelConfig(const char *filename,
+                       uint64_t kernel_body_load_address);
+
+/****************************************************************************/
+
+#endif  /* VBOOT_HOST_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/file_keys.c tools/vboot_utils/src/host/lib/file_keys.c
--- tools-org/vboot_utils/src/host/lib/file_keys.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/file_keys.c	2014-04-27 13:03:45.796119980 +0000
@@ -0,0 +1,120 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Utility functions for file and key handling.
+ */
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "file_keys.h"
+#include "host_common.h"
+#include "signature_digest.h"
+
+uint8_t* BufferFromFile(const char* input_file, uint64_t* len) {
+  int fd;
+  struct stat stat_fd;
+  uint8_t* buf = NULL;
+
+  if ((fd = open(input_file, O_RDONLY)) == -1) {
+    VBDEBUG(("Couldn't open file %s\n", input_file));
+    return NULL;
+  }
+
+  if (-1 == fstat(fd, &stat_fd)) {
+    VBDEBUG(("Couldn't stat file %s\n", input_file));
+    return NULL;
+  }
+  *len = stat_fd.st_size;
+
+  buf = (uint8_t*)malloc(*len);
+  if (!buf) {
+    VbExError("Couldn't allocate %ld bytes for file %s\n", *len, input_file);
+    return NULL;
+  }
+
+  if (*len != read(fd, buf, *len)) {
+    VBDEBUG(("Couldn't read file %s into a buffer\n", input_file));
+    return NULL;
+  }
+
+  close(fd);
+  return buf;
+}
+
+RSAPublicKey* RSAPublicKeyFromFile(const char* input_file) {
+  uint64_t len;
+  RSAPublicKey* key = NULL;
+  uint8_t* buf = BufferFromFile(input_file, &len);
+  if (buf)
+    key = RSAPublicKeyFromBuf(buf, len);
+  free(buf);
+  return key;
+}
+
+uint8_t* DigestFile(char* input_file, int sig_algorithm) {
+  int input_fd, len;
+  uint8_t data[SHA1_BLOCK_SIZE];
+  uint8_t* digest = NULL;
+  DigestContext ctx;
+
+  if( (input_fd = open(input_file, O_RDONLY)) == -1 ) {
+    VBDEBUG(("Couldn't open %s\n", input_file));
+    return NULL;
+  }
+  DigestInit(&ctx, sig_algorithm);
+  while ( (len = read(input_fd, data, SHA1_BLOCK_SIZE)) ==
+          SHA1_BLOCK_SIZE)
+    DigestUpdate(&ctx, data, len);
+  if (len != -1)
+    DigestUpdate(&ctx, data, len);
+  digest = DigestFinal(&ctx);
+  close(input_fd);
+  return digest;
+}
+
+uint8_t* SignatureFile(const char* input_file, const char* key_file,
+                       unsigned int algorithm) {
+  char* sign_utility = "./sign_data.sh";
+  char* cmd;  /* Command line to invoke. */
+  int cmd_len;
+  FILE* cmd_out;  /* File descriptor to command output. */
+  uint8_t* signature = NULL;
+  int signature_size = siglen_map[algorithm];
+
+  /* Build command line:
+   * sign_data.sh <algorithm> <key file> <input file>
+   */
+  cmd_len = (strlen(sign_utility) + 1 + /* +1 for space. */
+             2 + 1 + /* For [algorithm]. */
+             strlen(key_file) + 1 + /* +1 for space. */
+             strlen(input_file) +
+             1);  /* For the trailing '\0'. */
+  cmd = (char*) malloc(cmd_len);
+  snprintf(cmd, cmd_len, "%s %u %s %s", sign_utility, algorithm, key_file,
+           input_file);
+  cmd_out = popen(cmd, "r");
+  free(cmd);
+  if (!cmd_out) {
+    VBDEBUG(("Couldn't execute: %s\n", cmd));
+    return NULL;
+  }
+
+  signature = (uint8_t*) malloc(signature_size);
+  if (fread(signature, signature_size, 1, cmd_out) != 1) {
+    VBDEBUG(("Couldn't read signature.\n"));
+    pclose(cmd_out);
+    free(signature);
+    return NULL;
+  }
+
+  pclose(cmd_out);
+  return signature;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/fmap.c tools/vboot_utils/src/host/lib/fmap.c
--- tools-org/vboot_utils/src/host/lib/fmap.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/fmap.c	2014-04-27 13:03:45.796119980 +0000
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "fmap.h"
+
+const char* FmapFind(const char* ptr, size_t size)
+{
+  size_t i;
+  FmapHeader *fmap_header;
+  for (i=0; i<size; i += FMAP_SEARCH_STRIDE, ptr += FMAP_SEARCH_STRIDE) {
+    if (0 != strncmp(ptr, FMAP_SIGNATURE, FMAP_SIGNATURE_SIZE))
+      continue;
+    // Image may have multiple signatures (ex, in code that handles FMAP itself)
+    // so we do want to check at least major version.
+    fmap_header = (FmapHeader *)ptr;
+    if (fmap_header->fmap_ver_major == FMAP_VER_MAJOR)
+      return ptr;
+  }
+  return NULL;
+}
+
+int FmapAreaIndex(const FmapHeader* fh, const FmapAreaHeader* ah,
+		const char* name) {
+  int i;
+  for (i = 0; i < fh->fmap_nareas; i++)
+    if (!strcmp((const char*) ah[i].area_name, name))
+      return i;
+  return -1;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/host_common.c tools/vboot_utils/src/host/lib/host_common.c
--- tools-org/vboot_utils/src/host/lib/host_common.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/host_common.c	2014-04-27 13:03:45.800120255 +0000
@@ -0,0 +1,127 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host functions for verified boot.
+ *
+ * TODO: change all 'return 0', 'return 1' into meaningful return codes.
+ */
+
+#include <string.h>
+
+#include "host_common.h"
+#include "cryptolib.h"
+#include "utility.h"
+#include "vboot_common.h"
+
+VbFirmwarePreambleHeader *CreateFirmwarePreamble(
+	uint64_t firmware_version,
+	const VbPublicKey *kernel_subkey,
+	const VbSignature *body_signature,
+	const VbPrivateKey *signing_key,
+	uint32_t flags)
+{
+	VbFirmwarePreambleHeader *h;
+	uint64_t signed_size = (sizeof(VbFirmwarePreambleHeader) +
+				kernel_subkey->key_size +
+				body_signature->sig_size);
+	uint64_t block_size = signed_size + siglen_map[signing_key->algorithm];
+	uint8_t *kernel_subkey_dest;
+	uint8_t *body_sig_dest;
+	uint8_t *block_sig_dest;
+	VbSignature *sigtmp;
+
+	/* Allocate key block */
+	h = (VbFirmwarePreambleHeader *)malloc(block_size);
+	if (!h)
+		return NULL;
+
+	Memset(h, 0, block_size);
+	kernel_subkey_dest = (uint8_t *)(h + 1);
+	body_sig_dest = kernel_subkey_dest + kernel_subkey->key_size;
+	block_sig_dest = body_sig_dest + body_signature->sig_size;
+
+	h->header_version_major = FIRMWARE_PREAMBLE_HEADER_VERSION_MAJOR;
+	h->header_version_minor = FIRMWARE_PREAMBLE_HEADER_VERSION_MINOR;
+	h->preamble_size = block_size;
+	h->firmware_version = firmware_version;
+	h->flags = flags;
+
+	/* Copy data key */
+	PublicKeyInit(&h->kernel_subkey, kernel_subkey_dest,
+		      kernel_subkey->key_size);
+	PublicKeyCopy(&h->kernel_subkey, kernel_subkey);
+
+	/* Copy body signature */
+	SignatureInit(&h->body_signature, body_sig_dest,
+		      body_signature->sig_size, 0);
+	SignatureCopy(&h->body_signature, body_signature);
+
+	/* Set up signature struct so we can calculate the signature */
+	SignatureInit(&h->preamble_signature, block_sig_dest,
+		      siglen_map[signing_key->algorithm], signed_size);
+
+	/* Calculate signature */
+	sigtmp = CalculateSignature((uint8_t *)h, signed_size, signing_key);
+	SignatureCopy(&h->preamble_signature, sigtmp);
+	free(sigtmp);
+
+	/* Return the header */
+	return h;
+}
+
+VbKernelPreambleHeader *CreateKernelPreamble(
+	uint64_t kernel_version,
+	uint64_t body_load_address,
+	uint64_t bootloader_address,
+	uint64_t bootloader_size,
+	const VbSignature *body_signature,
+	uint64_t desired_size,
+	const VbPrivateKey *signing_key)
+{
+	VbKernelPreambleHeader *h;
+	uint64_t signed_size = (sizeof(VbKernelPreambleHeader) +
+				body_signature->sig_size);
+	uint64_t block_size = signed_size + siglen_map[signing_key->algorithm];
+	uint8_t *body_sig_dest;
+	uint8_t *block_sig_dest;
+	VbSignature *sigtmp;
+
+	/* If the block size is smaller than the desired size, pad it */
+	if (block_size < desired_size)
+		block_size = desired_size;
+
+	/* Allocate key block */
+	h = (VbKernelPreambleHeader *)malloc(block_size);
+	if (!h)
+		return NULL;
+
+	Memset(h, 0, block_size);
+	body_sig_dest = (uint8_t *)(h + 1);
+	block_sig_dest = body_sig_dest + body_signature->sig_size;
+
+	h->header_version_major = KERNEL_PREAMBLE_HEADER_VERSION_MAJOR;
+	h->header_version_minor = KERNEL_PREAMBLE_HEADER_VERSION_MINOR;
+	h->preamble_size = block_size;
+	h->kernel_version = kernel_version;
+	h->body_load_address = body_load_address;
+	h->bootloader_address = bootloader_address;
+	h->bootloader_size = bootloader_size;
+
+	/* Copy body signature */
+	SignatureInit(&h->body_signature, body_sig_dest,
+		      body_signature->sig_size, 0);
+	SignatureCopy(&h->body_signature, body_signature);
+
+	/* Set up signature struct so we can calculate the signature */
+	SignatureInit(&h->preamble_signature, block_sig_dest,
+		      siglen_map[signing_key->algorithm], signed_size);
+
+	/* Calculate signature */
+	sigtmp = CalculateSignature((uint8_t *)h, signed_size, signing_key);
+	SignatureCopy(&h->preamble_signature, sigtmp);
+	free(sigtmp);
+
+	/* Return the header */
+	return h;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/host_keyblock.c tools/vboot_utils/src/host/lib/host_keyblock.c
--- tools-org/vboot_utils/src/host/lib/host_keyblock.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/host_keyblock.c	2014-04-27 13:03:45.800120255 +0000
@@ -0,0 +1,168 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host functions for verified boot.
+ */
+
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "host_keyblock.h"
+#include "vboot_common.h"
+
+
+VbKeyBlockHeader* KeyBlockCreate(const VbPublicKey* data_key,
+                                 const VbPrivateKey* signing_key,
+                                 uint64_t flags) {
+
+  VbKeyBlockHeader* h;
+  uint64_t signed_size = sizeof(VbKeyBlockHeader) + data_key->key_size;
+  uint64_t block_size = (signed_size + SHA512_DIGEST_SIZE +
+                         (signing_key ?
+                          siglen_map[signing_key->algorithm] : 0));
+  uint8_t* data_key_dest;
+  uint8_t* block_sig_dest;
+  uint8_t* block_chk_dest;
+  VbSignature *sigtmp;
+
+  /* Allocate key block */
+  h = (VbKeyBlockHeader*)malloc(block_size);
+  if (!h)
+    return NULL;
+  data_key_dest = (uint8_t*)(h + 1);
+  block_chk_dest = data_key_dest + data_key->key_size;
+  block_sig_dest = block_chk_dest + SHA512_DIGEST_SIZE;
+
+  Memcpy(h->magic, KEY_BLOCK_MAGIC, KEY_BLOCK_MAGIC_SIZE);
+  h->header_version_major = KEY_BLOCK_HEADER_VERSION_MAJOR;
+  h->header_version_minor = KEY_BLOCK_HEADER_VERSION_MINOR;
+  h->key_block_size = block_size;
+  h->key_block_flags = flags;
+
+  /* Copy data key */
+  PublicKeyInit(&h->data_key, data_key_dest, data_key->key_size);
+  PublicKeyCopy(&h->data_key, data_key);
+
+  /* Set up signature structs so we can calculate the signatures */
+  SignatureInit(&h->key_block_checksum, block_chk_dest,
+                SHA512_DIGEST_SIZE, signed_size);
+  if (signing_key)
+    SignatureInit(&h->key_block_signature, block_sig_dest,
+                  siglen_map[signing_key->algorithm], signed_size);
+  else
+    Memset(&h->key_block_signature, 0, sizeof(VbSignature));
+
+  /* Calculate checksum */
+  sigtmp = CalculateChecksum((uint8_t*)h, signed_size);
+  SignatureCopy(&h->key_block_checksum, sigtmp);
+  free(sigtmp);
+
+  /* Calculate signature */
+  if (signing_key) {
+    sigtmp = CalculateSignature((uint8_t*)h, signed_size, signing_key);
+    SignatureCopy(&h->key_block_signature, sigtmp);
+    free(sigtmp);
+  }
+
+  /* Return the header */
+  return h;
+}
+
+/* TODO(gauravsh): This could easily be integrated into KeyBlockCreate()
+ * since the code is almost a mirror - I have kept it as such to avoid changing
+ * the existing interface. */
+VbKeyBlockHeader* KeyBlockCreate_external(const VbPublicKey* data_key,
+                                          const char* signing_key_pem_file,
+                                          uint64_t algorithm,
+                                          uint64_t flags,
+                                          const char* external_signer) {
+  VbKeyBlockHeader* h;
+  uint64_t signed_size = sizeof(VbKeyBlockHeader) + data_key->key_size;
+  uint64_t block_size = (signed_size + SHA512_DIGEST_SIZE +
+                         siglen_map[algorithm]);
+  uint8_t* data_key_dest;
+  uint8_t* block_sig_dest;
+  uint8_t* block_chk_dest;
+  VbSignature *sigtmp;
+
+  /* Allocate key block */
+  h = (VbKeyBlockHeader*)malloc(block_size);
+  if (!h)
+    return NULL;
+  if (!signing_key_pem_file || !data_key || !external_signer)
+    return NULL;
+
+  data_key_dest = (uint8_t*)(h + 1);
+  block_chk_dest = data_key_dest + data_key->key_size;
+  block_sig_dest = block_chk_dest + SHA512_DIGEST_SIZE;
+
+  Memcpy(h->magic, KEY_BLOCK_MAGIC, KEY_BLOCK_MAGIC_SIZE);
+  h->header_version_major = KEY_BLOCK_HEADER_VERSION_MAJOR;
+  h->header_version_minor = KEY_BLOCK_HEADER_VERSION_MINOR;
+  h->key_block_size = block_size;
+  h->key_block_flags = flags;
+
+  /* Copy data key */
+  PublicKeyInit(&h->data_key, data_key_dest, data_key->key_size);
+  PublicKeyCopy(&h->data_key, data_key);
+
+  /* Set up signature structs so we can calculate the signatures */
+  SignatureInit(&h->key_block_checksum, block_chk_dest,
+                SHA512_DIGEST_SIZE, signed_size);
+  SignatureInit(&h->key_block_signature, block_sig_dest,
+                siglen_map[algorithm], signed_size);
+
+  /* Calculate checksum */
+  sigtmp = CalculateChecksum((uint8_t*)h, signed_size);
+  SignatureCopy(&h->key_block_checksum, sigtmp);
+  free(sigtmp);
+
+  /* Calculate signature */
+  sigtmp = CalculateSignature_external((uint8_t*)h, signed_size,
+                                       signing_key_pem_file, algorithm,
+                                       external_signer);
+  SignatureCopy(&h->key_block_signature, sigtmp);
+  free(sigtmp);
+
+  /* Return the header */
+  return h;
+}
+
+/* Read a key block from a .keyblock file.  Caller owns the returned
+ * pointer, and must free it with free().
+ *
+ * Returns NULL if error. */
+VbKeyBlockHeader* KeyBlockRead(const char* filename) {
+
+  VbKeyBlockHeader* block;
+  uint64_t file_size;
+
+  block = (VbKeyBlockHeader*)ReadFile(filename, &file_size);
+  if (!block) {
+    VBDEBUG(("Error reading key block file: %s\n", filename));
+    return NULL;
+  }
+
+  /* Verify the hash of the key block, since we can do that without
+   * the public signing key. */
+  if (0 != KeyBlockVerify(block, file_size, NULL, 1)) {
+    VBDEBUG(("Invalid key block file: %s\n", filename));
+    free(block);
+    return NULL;
+  }
+
+  return block;
+}
+
+
+/* Write a key block to a file in .keyblock format. */
+int KeyBlockWrite(const char* filename, const VbKeyBlockHeader* key_block) {
+
+  if (0 != WriteFile(filename, key_block, key_block->key_block_size)) {
+    VBDEBUG(("KeyBlockWrite() error writing key block\n"));
+    return 1;
+  }
+
+  return 0;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/host_key.c tools/vboot_utils/src/host/lib/host_key.c
--- tools-org/vboot_utils/src/host/lib/host_key.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/host_key.c	2014-04-27 13:03:45.800120255 +0000
@@ -0,0 +1,260 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host functions for keys.
+ */
+
+/* TODO: change all 'return 0', 'return 1' into meaningful return codes */
+
+#define OPENSSL_NO_SHA
+#include <openssl/engine.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/x509.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "host_key.h"
+#include "host_misc.h"
+#include "vboot_common.h"
+
+
+VbPrivateKey* PrivateKeyReadPem(const char* filename, uint64_t algorithm) {
+
+  VbPrivateKey* key;
+  RSA* rsa_key;
+  FILE* f;
+
+  if (algorithm >= kNumAlgorithms) {
+    VBDEBUG(("%s() called with invalid algorithm!\n", __FUNCTION__));
+    return NULL;
+  }
+
+  /* Read private key */
+  f = fopen(filename, "r");
+  if (!f) {
+    VBDEBUG(("%s(): Couldn't open key file: %s\n", __FUNCTION__, filename));
+    return NULL;
+  }
+  rsa_key = PEM_read_RSAPrivateKey(f, NULL, NULL, NULL);
+  fclose(f);
+  if (!rsa_key) {
+    VBDEBUG(("%s(): Couldn't read private key from file: %s\n", __FUNCTION__,
+             filename));
+    return NULL;
+  }
+
+  /* Store key and algorithm in our struct */
+  key = (VbPrivateKey*)malloc(sizeof(VbPrivateKey));
+  if (!key) {
+    RSA_free(rsa_key);
+    return NULL;
+  }
+  key->rsa_private_key = rsa_key;
+  key->algorithm = algorithm;
+
+  /* Return the key */
+  return key;
+}
+
+
+void PrivateKeyFree(VbPrivateKey* key) {
+  if (!key)
+    return;
+  if (key->rsa_private_key)
+    RSA_free(key->rsa_private_key);
+  free(key);
+}
+
+
+/* Write a private key to a file in .vbprivk format. */
+int PrivateKeyWrite(const char* filename, const VbPrivateKey* key) {
+  uint8_t *outbuf = 0;
+  int buflen;
+  FILE *f;
+
+  buflen = i2d_RSAPrivateKey(key->rsa_private_key, &outbuf);
+  if (buflen <= 0) {
+    printf("Unable to write private key buffer\n");
+    return 1;
+  }
+
+  f = fopen(filename, "wb");
+  if (!f) {
+    printf("Unable to open file %s\n", filename);
+    free(outbuf);
+    return 1;
+  }
+
+  if (1 != fwrite(&key->algorithm, sizeof(key->algorithm), 1, f)) {
+    printf("Unable to write to file %s\n", filename);
+    fclose(f);
+    free(outbuf);
+    unlink(filename);  /* Delete any partial file */
+  }
+
+  if (1 != fwrite(outbuf, buflen, 1, f)) {
+    printf("Unable to write to file %s\n", filename);
+    fclose(f);
+    unlink(filename);  /* Delete any partial file */
+    free(outbuf);
+  }
+
+  fclose(f);
+  free(outbuf);
+  return 0;
+}
+
+VbPrivateKey* PrivateKeyRead(const char* filename) {
+  VbPrivateKey *key;
+  uint64_t filelen = 0;
+  uint8_t *buffer;
+  const unsigned char *start;
+
+  buffer = ReadFile(filename, &filelen);
+  if (!buffer) {
+    printf("unable to read from file %s\n", filename);
+    return 0;
+  }
+
+  key = (VbPrivateKey*)malloc(sizeof(VbPrivateKey));
+  if (!key) {
+    printf("Unable to allocate VbPrivateKey\n");
+    free(buffer);
+    return 0;
+  }
+
+  key->algorithm = *(typeof(key->algorithm) *)buffer;
+  start = buffer + sizeof(key->algorithm);
+
+  key->rsa_private_key = d2i_RSAPrivateKey(0, &start,
+                                           filelen - sizeof(key->algorithm));
+
+  if (!key->rsa_private_key) {
+    printf("Unable to parse RSA private key\n");
+    free(buffer);
+    free(key);
+    return 0;
+  }
+
+  free(buffer);
+  return key;
+}
+
+
+/* Allocate a new public key with space for a [key_size] byte key. */
+VbPublicKey* PublicKeyAlloc(uint64_t key_size, uint64_t algorithm,
+                            uint64_t version) {
+  VbPublicKey* key = (VbPublicKey*)malloc(sizeof(VbPublicKey) + key_size);
+  if (!key)
+    return NULL;
+
+  key->algorithm = algorithm;
+  key->key_version = version;
+  key->key_size = key_size;
+  key->key_offset = sizeof(VbPublicKey);
+  return key;
+}
+
+VbPublicKey* PublicKeyReadKeyb(const char* filename, uint64_t algorithm,
+                               uint64_t version) {
+  VbPublicKey* key;
+  uint8_t* key_data;
+  uint64_t key_size;
+  uint64_t expected_key_size;
+
+  if (algorithm >= kNumAlgorithms) {
+    VBDEBUG(("PublicKeyReadKeyb() called with invalid algorithm!\n"));
+    return NULL;
+  }
+  if (version > 0xFFFF) {
+    /* Currently, TPM only supports 16-bit version */
+    VBDEBUG(("PublicKeyReadKeyb() called with invalid version!\n"));
+    return NULL;
+  }
+
+  key_data = ReadFile(filename, &key_size);
+  if (!key_data)
+    return NULL;
+
+  if (!RSAProcessedKeySize(algorithm, &expected_key_size) ||
+      expected_key_size != key_size) {
+    VBDEBUG(("PublicKeyReadKeyb() wrong key size for algorithm\n"));
+    free(key_data);
+    return NULL;
+  }
+
+  key = PublicKeyAlloc(key_size, algorithm, version);
+  if (!key) {
+    free(key_data);
+    return NULL;
+  }
+  Memcpy(GetPublicKeyData(key), key_data, key_size);
+
+  free(key_data);
+  return key;
+}
+
+
+VbPublicKey* PublicKeyRead(const char* filename) {
+  VbPublicKey* key;
+  uint64_t file_size;
+  uint64_t key_size;
+
+  key = (VbPublicKey*)ReadFile(filename, &file_size);
+  if (!key)
+    return NULL;
+
+  do {
+    /* Sanity-check key data */
+    if (0 != VerifyPublicKeyInside(key, file_size, key)) {
+      VBDEBUG(("PublicKeyRead() not a VbPublicKey\n"));
+      break;
+    }
+    if (key->algorithm >= kNumAlgorithms) {
+      VBDEBUG(("PublicKeyRead() invalid algorithm\n"));
+      break;
+    }
+    if (key->key_version > 0xFFFF) {
+      VBDEBUG(("PublicKeyRead() invalid version\n"));
+      break;  /* Currently, TPM only supports 16-bit version */
+    }
+    if (!RSAProcessedKeySize(key->algorithm, &key_size) ||
+        key_size != key->key_size) {
+      VBDEBUG(("PublicKeyRead() wrong key size for algorithm\n"));
+      break;
+    }
+
+    /* Success */
+    return key;
+
+  } while(0);
+
+  /* Error */
+  free(key);
+  return NULL;
+}
+
+int PublicKeyWrite(const char* filename, const VbPublicKey* key) {
+  VbPublicKey* kcopy;
+  int rv;
+
+  /* Copy the key, so its data is contiguous with the header */
+  kcopy = PublicKeyAlloc(key->key_size, 0, 0);
+  if (!kcopy)
+    return 1;
+  if (0 != PublicKeyCopy(kcopy, key)) {
+    free(kcopy);
+    return 1;
+  }
+
+  /* Write the copy, then free it */
+  rv = WriteFile(filename, kcopy, kcopy->key_offset + kcopy->key_size);
+  free(kcopy);
+  return rv;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/host_misc.c tools/vboot_utils/src/host/lib/host_misc.c
--- tools-org/vboot_utils/src/host/lib/host_misc.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/host_misc.c	2014-04-27 13:03:45.800120255 +0000
@@ -0,0 +1,126 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host functions for verified boot.
+ */
+
+/* TODO: change all 'return 0', 'return 1' into meaningful return codes */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "vboot_common.h"
+
+
+char* StrCopy(char* dest, const char* src, int dest_size) {
+  strncpy(dest, src, dest_size);
+  dest[dest_size - 1] = '\0';
+  return dest;
+}
+
+
+uint8_t* ReadFile(const char* filename, uint64_t* sizeptr) {
+  FILE* f;
+  uint8_t* buf;
+  uint64_t size;
+
+  f = fopen(filename, "rb");
+  if (!f) {
+    VBDEBUG(("Unable to open file %s\n", filename));
+    return NULL;
+  }
+
+  fseek(f, 0, SEEK_END);
+  size = ftell(f);
+  rewind(f);
+
+  buf = malloc(size);
+  if (!buf) {
+    fclose(f);
+    return NULL;
+  }
+
+  if(1 != fread(buf, size, 1, f)) {
+    VBDEBUG(("Unable to read from file %s\n", filename));
+    fclose(f);
+    free(buf);
+    return NULL;
+  }
+
+  fclose(f);
+  if (sizeptr)
+    *sizeptr = size;
+  return buf;
+}
+
+
+char* ReadFileString(char* dest, int size, const char* filename) {
+  char* got;
+  FILE* f;
+
+  f = fopen(filename, "rt");
+  if (!f)
+    return NULL;
+
+  got = fgets(dest, size, f);
+  fclose(f);
+  return got;
+}
+
+
+int ReadFileInt(const char* filename) {
+  char buf[64];
+  int value;
+  char* e = NULL;
+
+  if (!ReadFileString(buf, sizeof(buf), filename))
+    return -1;
+
+  /* Convert to integer.  Allow characters after the int ("123 blah"). */
+  value = strtol(buf, &e, 0);
+  if (e == buf)
+    return -1;  /* No characters consumed, so conversion failed */
+
+  return value;
+}
+
+
+int ReadFileBit(const char* filename, int bitmask) {
+  int value = ReadFileInt(filename);
+  if (value == -1)
+    return -1;
+  else return (value & bitmask ? 1 : 0);
+}
+
+
+int WriteFile(const char* filename, const void *data, uint64_t size) {
+  FILE *f = fopen(filename, "wb");
+  if (!f) {
+    VBDEBUG(("Unable to open file %s\n", filename));
+    return 1;
+  }
+
+  if (1 != fwrite(data, size, 1, f)) {
+    VBDEBUG(("Unable to write to file %s\n", filename));
+    fclose(f);
+    unlink(filename);  /* Delete any partial file */
+  }
+
+  fclose(f);
+  return 0;
+}
+
+void PrintPubKeySha1Sum(VbPublicKey* key) {
+  uint8_t* buf = ((uint8_t *)key) + key->key_offset;
+  uint64_t buflen = key->key_size;
+  uint8_t* digest = DigestBuf(buf, buflen, SHA1_DIGEST_ALGORITHM);
+  int i;
+  for (i=0; i<SHA1_DIGEST_SIZE; i++)
+    printf("%02x", digest[i]);
+  free(digest);
+}
diff -Nur tools-org/vboot_utils/src/host/lib/host_signature.c tools/vboot_utils/src/host/lib/host_signature.c
--- tools-org/vboot_utils/src/host/lib/host_signature.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/host_signature.c	2014-04-27 13:03:45.804120531 +0000
@@ -0,0 +1,307 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host functions for signature generation.
+ */
+
+/* TODO: change all 'return 0', 'return 1' into meaningful return codes */
+
+#define OPENSSL_NO_SHA
+#include <openssl/engine.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "file_keys.h"
+#include "host_common.h"
+#include "vboot_common.h"
+
+
+VbSignature* SignatureAlloc(uint64_t sig_size, uint64_t data_size) {
+  VbSignature* sig = (VbSignature*)malloc(sizeof(VbSignature) + sig_size);
+  if (!sig)
+    return NULL;
+
+  sig->sig_offset = sizeof(VbSignature);
+  sig->sig_size = sig_size;
+  sig->data_size = data_size;
+  return sig;
+}
+
+
+void SignatureInit(VbSignature* sig, uint8_t* sig_data,
+                   uint64_t sig_size, uint64_t data_size) {
+  sig->sig_offset = OffsetOf(sig, sig_data);
+  sig->sig_size = sig_size;
+  sig->data_size = data_size;
+}
+
+
+int SignatureCopy(VbSignature* dest, const VbSignature* src) {
+  if (dest->sig_size < src->sig_size)
+    return 1;
+  dest->sig_size = src->sig_size;
+  dest->data_size = src->data_size;
+  Memcpy(GetSignatureData(dest), GetSignatureDataC(src), src->sig_size);
+  return 0;
+}
+
+
+VbSignature* CalculateChecksum(const uint8_t* data, uint64_t size) {
+
+  uint8_t* header_checksum;
+  VbSignature* sig;
+
+  header_checksum = DigestBuf(data, size, SHA512_DIGEST_ALGORITHM);
+  if (!header_checksum)
+    return NULL;
+
+  sig = SignatureAlloc(SHA512_DIGEST_SIZE, 0);
+  if (!sig) {
+    VbExFree(header_checksum);
+    return NULL;
+  }
+  sig->sig_offset = sizeof(VbSignature);
+  sig->sig_size = SHA512_DIGEST_SIZE;
+  sig->data_size = size;
+
+  /* Signature data immediately follows the header */
+  Memcpy(GetSignatureData(sig), header_checksum, SHA512_DIGEST_SIZE);
+  VbExFree(header_checksum);
+  return sig;
+}
+
+VbSignature* CalculateHash(const uint8_t* data, uint64_t size,
+                           const VbPrivateKey* key) {
+  uint8_t* digest = NULL;
+  int digest_size = hash_size_map[key->algorithm];
+  VbSignature* sig = NULL;
+
+  /* Calculate the digest */
+  digest = DigestBuf(data, size, key->algorithm);
+  if (!digest)
+    return NULL;
+
+  /* Allocate output signature */
+  sig = SignatureAlloc(digest_size, size);
+  if (!sig) {
+    free(digest);
+    return NULL;
+  }
+
+  /* The digest itself is the signature data */
+  Memcpy(GetSignatureData(sig), digest, digest_size);
+  free(digest);
+
+  /* Return the signature */
+  return sig;
+}
+
+VbSignature* CalculateSignature(const uint8_t* data, uint64_t size,
+                                const VbPrivateKey* key) {
+
+  uint8_t* digest;
+  int digest_size = hash_size_map[key->algorithm];
+
+  const uint8_t* digestinfo = hash_digestinfo_map[key->algorithm];
+  int digestinfo_size = digestinfo_size_map[key->algorithm];
+
+  uint8_t* signature_digest;
+  int signature_digest_len = digest_size + digestinfo_size;
+
+  VbSignature* sig;
+  int rv;
+
+  /* Calculate the digest */
+  /* TODO: rename param 3 of DigestBuf to hash_type */
+  digest = DigestBuf(data, size, hash_type_map[key->algorithm]);
+  if (!digest)
+    return NULL;
+
+  /* Prepend the digest info to the digest */
+  signature_digest = malloc(signature_digest_len);
+  if (!signature_digest) {
+    VbExFree(digest);
+    return NULL;
+  }
+  Memcpy(signature_digest, digestinfo, digestinfo_size);
+  Memcpy(signature_digest + digestinfo_size, digest, digest_size);
+  VbExFree(digest);
+
+  /* Allocate output signature */
+  sig = SignatureAlloc(siglen_map[key->algorithm], size);
+  if (!sig) {
+    free(signature_digest);
+    return NULL;
+  }
+
+  /* Sign the signature_digest into our output buffer */
+  rv = RSA_private_encrypt(signature_digest_len,   /* Input length */
+                           signature_digest,       /* Input data */
+                           GetSignatureData(sig),  /* Output sig */
+                           key->rsa_private_key,   /* Key to use */
+                           RSA_PKCS1_PADDING);     /* Padding to use */
+  free(signature_digest);
+
+  if (-1 == rv) {
+    VBDEBUG(("SignatureBuf(): RSA_private_encrypt() failed.\n"));
+    free(sig);
+    return NULL;
+  }
+
+  /* Return the signature */
+  return sig;
+}
+
+/* Invoke [external_signer] command with [pem_file] as
+ * an argument, contents of [inbuf] passed redirected to stdin,
+ * and the stdout of the command is put back into [outbuf].
+ * Returns -1 on error, 0 on success.
+ */
+int InvokeExternalSigner(uint64_t size,
+                         const uint8_t* inbuf,
+                         uint8_t* outbuf,
+                         uint64_t outbufsize,
+                         const char* pem_file,
+                         const char* external_signer) {
+
+  int rv = 0, n;
+  int p_to_c[2], c_to_p[2];  /* pipe descriptors */
+  pid_t pid;
+
+  VBDEBUG(("Will invoke \"%s %s\" to perform signing.\n"
+           "Input to the signer will be provided on standard in.\n"
+           "Output of the signer will be read from standard out.\n",
+           external_signer, pem_file));
+
+  /* Need two pipes since we want to invoke the external_signer as
+   * a co-process writing to its stdin and reading from its stdout. */
+  if (pipe(p_to_c) < 0 || pipe(c_to_p) < 0) {
+    VBDEBUG(("pipe() error\n"));
+    return -1;
+  }
+  if ((pid = fork()) < 0) {
+    VBDEBUG(("fork() error"));
+    return -1;
+  }
+  else if (pid > 0) {  /* Parent. */
+    close(p_to_c[STDIN_FILENO]);
+    close(c_to_p[STDOUT_FILENO]);
+
+    /* We provide input to the child process (external signer). */
+    if (write(p_to_c[STDOUT_FILENO], inbuf, size) != size) {
+      VBDEBUG(("write() error while providing input to external signer\n"));
+      rv = -1;
+    } else {
+      close(p_to_c[STDOUT_FILENO]);  /* Send EOF to child (signer process). */
+      do {
+        n = read(c_to_p[STDIN_FILENO], outbuf, outbufsize);
+        outbuf += n;
+        outbufsize -= n;
+      } while (n > 0 && outbufsize);
+
+      if (n < 0) {
+        VBDEBUG(("read() error while reading output from external signer\n"));
+        rv = -1;
+      }
+    }
+    if (waitpid(pid, NULL, 0) < 0) {
+      VBDEBUG(("waitpid() error\n"));
+      rv = -1;
+    }
+  } else {  /* Child. */
+    close (p_to_c[STDOUT_FILENO]);
+    close (c_to_p[STDIN_FILENO]);
+    /* Map the stdin to the first pipe (this pipe gets input
+     * from the parent) */
+    if (STDIN_FILENO != p_to_c[STDIN_FILENO]) {
+      if (dup2(p_to_c[STDIN_FILENO], STDIN_FILENO) != STDIN_FILENO) {
+        VBDEBUG(("stdin dup2() failed (external signer)\n"));
+        close(p_to_c[0]);
+        return -1;
+      }
+    }
+    /* Map the stdout to the second pipe (this pipe sends back
+     * signer output to the parent) */
+    if (STDOUT_FILENO != c_to_p[STDOUT_FILENO]) {
+      if (dup2(c_to_p[STDOUT_FILENO], STDOUT_FILENO) != STDOUT_FILENO) {
+        VBDEBUG(("stdout dup2() failed (external signer)\n"));
+        close(c_to_p[STDOUT_FILENO]);
+        return -1;
+      }
+    }
+    /* External signer is invoked here. */
+    if (execl(external_signer, external_signer, pem_file, (char *) 0) < 0) {
+      VBDEBUG(("execl() of external signer failed\n"));
+    }
+  }
+  return rv;
+}
+
+/* TODO(gauravsh): This could easily be integrated into CalculateSignature()
+ * since the code is almost a mirror - I have kept it as such to avoid changing
+ * the existing interface. */
+VbSignature* CalculateSignature_external(const uint8_t* data, uint64_t size,
+                                         const char* key_file,
+                                         uint64_t key_algorithm,
+                                         const char* external_signer) {
+  uint8_t* digest;
+  uint64_t digest_size = hash_size_map[key_algorithm];
+
+  const uint8_t* digestinfo = hash_digestinfo_map[key_algorithm];
+  uint64_t digestinfo_size = digestinfo_size_map[key_algorithm];
+
+  uint8_t* signature_digest;
+  uint64_t signature_digest_len = digest_size + digestinfo_size;
+
+  VbSignature* sig;
+  int rv;
+
+  /* Calculate the digest */
+  /* TODO: rename param 3 of DigestBuf to hash_type */
+  digest = DigestBuf(data, size, hash_type_map[key_algorithm]);
+  if (!digest)
+    return NULL;
+
+  /* Prepend the digest info to the digest */
+  signature_digest = malloc(signature_digest_len);
+  if (!signature_digest) {
+    free(digest);
+    return NULL;
+  }
+  Memcpy(signature_digest, digestinfo, digestinfo_size);
+  Memcpy(signature_digest + digestinfo_size, digest, digest_size);
+  free(digest);
+
+  /* Allocate output signature */
+  sig = SignatureAlloc(siglen_map[key_algorithm], size);
+  if (!sig) {
+    free(signature_digest);
+    return NULL;
+  }
+
+  /* Sign the signature_digest into our output buffer */
+  rv = InvokeExternalSigner(signature_digest_len, /* Input length */
+                            signature_digest,     /* Input data */
+                            GetSignatureData(sig), /* Output sig */
+                            siglen_map[key_algorithm], /* Max Output sig size */
+                            key_file,             /* Key file to use */
+                            external_signer);     /* External cmd to invoke */
+  free(signature_digest);
+
+  if (-1 == rv) {
+    VBDEBUG(("SignatureBuf(): RSA_private_encrypt() failed.\n"));
+    free(sig);
+    return NULL;
+  }
+
+  /* Return the signature */
+  return sig;
+}
diff -Nur tools-org/vboot_utils/src/host/lib/include/file_keys.h tools/vboot_utils/src/host/lib/include/file_keys.h
--- tools-org/vboot_utils/src/host/lib/include/file_keys.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/file_keys.h	2014-04-27 13:03:45.804120531 +0000
@@ -0,0 +1,43 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Utility functions for file and key handling.
+ */
+
+#ifndef VBOOT_REFERENCE_FILE_KEYS_H_
+#define VBOOT_REFERENCE_FILE_KEYS_H_
+
+#include "cryptolib.h"
+
+/* Read file named [input_file] into a buffer and stores the length into
+ * [len].
+ *
+ * Returns a pointer to the buffer. Caller owns the returned pointer and
+ * must free it.
+ */
+uint8_t* BufferFromFile(const char* input_file, uint64_t* len);
+
+/* Read a pre-processed RSA Public Key from file [input_file].
+ *
+ * Returns a pointer to the read key. Caller owns the returned pointer and
+ * must free it.
+ */
+RSAPublicKey* RSAPublicKeyFromFile(const char* input_file);
+
+/* Returns the appropriate digest for the data in [input_file]
+ * based on the signature [algorithm].
+ * Caller owns the returned digest and must free it.
+ */
+uint8_t* DigestFile(char* input_file, int sig_algorithm);
+
+/* Helper function to invoke external program to calculate signature on
+ * [input_file] using private key [key_file] and signature algorithm
+ * [algorithm].
+ *
+ * Returns the signature. Caller owns the buffer and must Free() it.
+ */
+uint8_t* SignatureFile(const char* input_file, const char* key_file,
+                       unsigned int algorithm);
+
+#endif  /* VBOOT_REFERENCE_FILE_KEYS_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/fmap.h tools/vboot_utils/src/host/lib/include/fmap.h
--- tools-org/vboot_utils/src/host/lib/include/fmap.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/fmap.h	2014-04-27 13:03:45.804120531 +0000
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __FMAP_H__
+#define __FMAP_H__
+
+#include <inttypes.h>
+#include <stddef.h>
+
+/* FMAP structs. See http://code.google.com/p/flashmap/wiki/FmapSpec */
+#define FMAP_NAMELEN 32
+#define FMAP_SIGNATURE "__FMAP__"
+#define FMAP_SIGNATURE_SIZE 8
+#define FMAP_SEARCH_STRIDE 4
+#define FMAP_VER_MAJOR 1
+typedef struct _FmapHeader {
+  char        fmap_signature[FMAP_SIGNATURE_SIZE]; /* avoiding endian issues */
+  uint8_t     fmap_ver_major;
+  uint8_t     fmap_ver_minor;
+  uint64_t    fmap_base;
+  uint32_t    fmap_size;
+  char        fmap_name[FMAP_NAMELEN];
+  uint16_t    fmap_nareas;
+} __attribute__((packed)) FmapHeader;
+
+typedef struct _FmapAreaHeader {
+  uint32_t area_offset;
+  uint32_t area_size;
+  char     area_name[FMAP_NAMELEN];
+  uint16_t area_flags;
+} __attribute__((packed)) FmapAreaHeader;
+
+
+/* Scan firmware image, pointed by [ptr] with length [size], for fmap header.
+ * Return pointer to fmap header, or NULL if not found.
+ */
+const char* FmapFind(const char *ptr, size_t size);
+
+/* Look up fmap area by name, that is, strcmp(fh->fmap_name, name) == 0.
+ * Return index of fmap area, that is, ah[returned_index],
+ * or -1 if not found. */
+int FmapAreaIndex(const FmapHeader* fh, const FmapAreaHeader* ah,
+		const char* name);
+
+#endif  /* __FMAP_H__ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/host_common.h tools/vboot_utils/src/host/lib/include/host_common.h
--- tools-org/vboot_utils/src/host/lib/include/host_common.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/host_common.h	2014-04-27 13:03:45.808120806 +0000
@@ -0,0 +1,56 @@
+/* Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host-side functions for verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_HOST_COMMON_H_
+#define VBOOT_REFERENCE_HOST_COMMON_H_
+
+/*
+ * Host is allowed direct use of stdlib funcs such as malloc() and free(),
+ * since it's using the stub implementation from firmware/lib/stub.
+ */
+#define _STUB_IMPLEMENTATION_
+
+#include "cryptolib.h"
+#include "host_key.h"
+#include "host_keyblock.h"
+#include "host_misc.h"
+#include "host_signature.h"
+#include "utility.h"
+#include "vboot_api.h"
+#include "vboot_struct.h"
+
+/**
+ * Create a firmware preamble, signed with [signing_key].
+ *
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL if error.
+ */
+VbFirmwarePreambleHeader *CreateFirmwarePreamble(
+	uint64_t firmware_version,
+	const VbPublicKey *kernel_subkey,
+	const VbSignature *body_signature,
+	const VbPrivateKey *signing_key,
+	uint32_t flags);
+
+/**
+ * Create a kernel preamble, signed with [signing_key].
+ *
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL if error.
+ */
+VbKernelPreambleHeader *CreateKernelPreamble(
+	uint64_t kernel_version,
+	uint64_t body_load_address,
+	uint64_t bootloader_address,
+	uint64_t bootloader_size,
+	const VbSignature *body_signature,
+	uint64_t desired_size,
+	const VbPrivateKey *signing_key);
+
+#endif  /* VBOOT_REFERENCE_HOST_COMMON_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/host_keyblock.h tools/vboot_utils/src/host/lib/include/host_keyblock.h
--- tools-org/vboot_utils/src/host/lib/include/host_keyblock.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/host_keyblock.h	2014-04-27 13:03:45.808120806 +0000
@@ -0,0 +1,45 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host-side functions for verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_HOST_KEYBLOCK_H_
+#define VBOOT_REFERENCE_HOST_KEYBLOCK_H_
+
+#include "host_key.h"
+#include "vboot_struct.h"
+
+
+/* Create a key block header containing [data_key] and [flags], signed
+ * by private key the file [signing_key_pem_file] and algorithm [algorithm]
+ * using the external signer program [external_signer] for all private key
+ * operations.
+ * Caller owns the returned pointer, and must free
+ * it with Free(). */
+VbKeyBlockHeader* KeyBlockCreate_external(const VbPublicKey* data_key,
+                                          const char* signing_key_pem_file,
+                                          uint64_t algorithm,
+                                          uint64_t flags,
+                                          const char* external_signer);
+
+/* Create a key block header containing [data_key] and [flags], signed
+ * by [signing_key].  Caller owns the returned pointer, and must free
+ * it with Free(). */
+VbKeyBlockHeader* KeyBlockCreate(const VbPublicKey* data_key,
+                                 const VbPrivateKey* signing_key,
+                                 uint64_t flags);
+
+
+/* Read a key block from a .keyblock file.  Caller owns the returned
+ * pointer, and must free it with Free().
+ *
+ * Returns NULL if error. */
+VbKeyBlockHeader* KeyBlockRead(const char* filename);
+
+
+/* Write a key block to a file in .keyblock format. */
+int KeyBlockWrite(const char* filename, const VbKeyBlockHeader* key_block);
+
+#endif  /* VBOOT_REFERENCE_HOST_KEYBLOCK_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/host_key.h tools/vboot_utils/src/host/lib/include/host_key.h
--- tools-org/vboot_utils/src/host/lib/include/host_key.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/host_key.h	2014-04-27 13:03:45.808120806 +0000
@@ -0,0 +1,68 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host-side functions for verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_HOST_KEY_H_
+#define VBOOT_REFERENCE_HOST_KEY_H_
+
+#include "cryptolib.h"
+#include "utility.h"
+#include "vboot_struct.h"
+
+
+typedef struct rsa_st RSA;
+
+/* Private key data */
+typedef struct VbPrivateKey {
+  RSA* rsa_private_key;  /* Private key data */
+  uint64_t algorithm;    /* Algorithm to use when signing */
+} VbPrivateKey;
+
+
+/* Read a private key from a .pem file.  Caller owns the returned pointer,
+ * and must free it with PrivateKeyFree(). */
+VbPrivateKey* PrivateKeyReadPem(const char* filename, uint64_t algorithm);
+
+
+/* Free a private key. */
+void PrivateKeyFree(VbPrivateKey* key);
+
+/* Write a private key to a file in .vbprivk format. */
+int PrivateKeyWrite(const char* filename, const VbPrivateKey* key);
+
+/* Read a privake key from a .vbprivk file.  Caller owns the returned
+ * pointer, and must free it with PrivateKeyFree().
+ *
+ * Returns NULL if error. */
+VbPrivateKey* PrivateKeyRead(const char* filename);
+
+
+
+/* Allocate a new public key with space for a [key_size] byte key. */
+VbPublicKey* PublicKeyAlloc(uint64_t key_size, uint64_t algorithm,
+                            uint64_t version);
+
+
+/* Read a public key from a .vbpubk file.  Caller owns the returned
+ * pointer, and must free it with Free().
+ *
+ * Returns NULL if error. */
+VbPublicKey* PublicKeyRead(const char* filename);
+
+
+/* Read a public key from a .keyb file.  Caller owns the returned
+ * pointer, and must free it with Free().
+ *
+ * Returns NULL if error. */
+VbPublicKey* PublicKeyReadKeyb(const char* filename, uint64_t algorithm,
+                               uint64_t version);
+
+
+/* Write a public key to a file in .vbpubk format. */
+int PublicKeyWrite(const char* filename, const VbPublicKey* key);
+
+
+#endif  /* VBOOT_REFERENCE_HOST_KEY_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/host_misc.h tools/vboot_utils/src/host/lib/include/host_misc.h
--- tools-org/vboot_utils/src/host/lib/include/host_misc.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/host_misc.h	2014-04-27 13:03:45.808120806 +0000
@@ -0,0 +1,49 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host-side misc functions for verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_HOST_MISC_H_
+#define VBOOT_REFERENCE_HOST_MISC_H_
+
+#include "utility.h"
+#include "vboot_struct.h"
+
+/* Copy up to dest_size-1 characters from src to dest, ensuring null
+   termination (which strncpy() doesn't do).  Returns the destination
+   string. */
+char* StrCopy(char* dest, const char* src, int dest_size);
+
+/* Read data from [filename].  Store the size of returned data in [size].
+ *
+ * Returns the data buffer, which the caller must Free(), or NULL if
+ * error. */
+uint8_t* ReadFile(const char* filename, uint64_t* size);
+
+/* Read a string from a file.  Passed the destination, dest size, and
+ * filename to read.
+ *
+ * Returns the destination, or NULL if error. */
+char* ReadFileString(char* dest, int size, const char* filename);
+
+/* Read an integer from a file.
+ *
+ * Returns the parsed integer, or -1 if error. */
+int ReadFileInt(const char* filename);
+
+/* Check if a bit is set in a file which contains an integer.
+ *
+ * Returns 1 if the bit is set, 0 if clear, or -1 if error. */
+int ReadFileBit(const char* filename, int bitmask);
+
+/* Writes [size] bytes of [data] to [filename].
+ *
+ * Returns 0 if success, 1 if error. */
+int WriteFile(const char* filename, const void *data, uint64_t size);
+
+/* Prints the sha1sum of the given VbPublicKey to stdout. */
+void PrintPubKeySha1Sum(VbPublicKey* key);
+
+#endif  /* VBOOT_REFERENCE_HOST_MISC_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/host_signature.h tools/vboot_utils/src/host/lib/include/host_signature.h
--- tools-org/vboot_utils/src/host/lib/include/host_signature.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/host_signature.h	2014-04-27 13:03:45.812121081 +0000
@@ -0,0 +1,63 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Host-side functions for verified boot.
+ */
+
+#ifndef VBOOT_REFERENCE_HOST_SIGNATURE_H_
+#define VBOOT_REFERENCE_HOST_SIGNATURE_H_
+
+#include "cryptolib.h"
+#include "host_key.h"
+#include "utility.h"
+#include "vboot_struct.h"
+
+
+/* Initialize a signature struct. */
+void SignatureInit(VbSignature* sig, uint8_t* sig_data,
+                   uint64_t sig_size, uint64_t data_size);
+
+
+/* Allocate a new signature with space for a [sig_size] byte signature. */
+VbSignature* SignatureAlloc(uint64_t sig_size, uint64_t data_size);
+
+
+/* Copy a signature key from [src] to [dest].
+ *
+ * Returns 0 if success, non-zero if error. */
+int SignatureCopy(VbSignature* dest, const VbSignature* src);
+
+
+/* Calculates a SHA-512 checksum.
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL on error. */
+VbSignature* CalculateChecksum(const uint8_t* data, uint64_t size);
+
+
+/* Calculates a hash of the data using the algorithm from the specified key.
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL on error. */
+VbSignature* CalculateHash(const uint8_t* data, uint64_t size,
+                           const VbPrivateKey* key);
+
+/* Calculates a signature for the data using the specified key.
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL on error. */
+VbSignature* CalculateSignature(const uint8_t* data, uint64_t size,
+                                const VbPrivateKey* key);
+
+/* Calculates a signature for the data using the specified key and
+ * an external program.
+ * Caller owns the returned pointer, and must free it with Free().
+ *
+ * Returns NULL on error. */
+VbSignature* CalculateSignature_external(const uint8_t* data, uint64_t size,
+                                         const char* key_file,
+                                         uint64_t key_algorithm,
+                                         const char* external_signer);
+
+#endif  /* VBOOT_REFERENCE_HOST_SIGNATURE_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/include/signature_digest.h tools/vboot_utils/src/host/lib/include/signature_digest.h
--- tools-org/vboot_utils/src/host/lib/include/signature_digest.h	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/include/signature_digest.h	2014-04-27 13:03:45.812121081 +0000
@@ -0,0 +1,36 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef VBOOT_REFERENCE_SIGNATURE_DIGEST_H_
+#define VBOOT_REFERENCE_SIGNATURE_DIGEST_H_
+
+#include <stdint.h>
+
+/* Returns a buffer with DigestInfo (which depends on [algorithm])
+ * prepended to [digest].
+ */
+uint8_t* PrependDigestInfo(unsigned int algorithm, uint8_t* digest);
+
+/* Function that outputs the message digest of the contents of a buffer in a
+ * format that can be used as input to OpenSSL for an RSA signature.
+ * Needed until the stable OpenSSL release supports SHA-256/512 digests for
+ * RSA signatures.
+ *
+ * Returns DigestInfo || Digest where DigestInfo is the OID depending on the
+ * choice of the hash algorithm (see padding.c). Caller owns the returned
+ * pointer and must Free() it.
+ */
+uint8_t* SignatureDigest(const uint8_t* buf, uint64_t len,
+                         unsigned int algorithm);
+
+/* Calculates the signature on a buffer [buf] of length [len] using
+ * the private RSA key file from [key_file] and signature algorithm
+ * [algorithm].
+ *
+ * Returns the signature. Caller owns the buffer and must Free() it.
+ */
+uint8_t* SignatureBuf(const uint8_t* buf, uint64_t len, const char* key_file,
+                      unsigned int algorithm);
+#endif  /* VBOOT_REFERENCE_SIGNATURE_DIGEST_H_ */
diff -Nur tools-org/vboot_utils/src/host/lib/signature_digest.c tools/vboot_utils/src/host/lib/signature_digest.c
--- tools-org/vboot_utils/src/host/lib/signature_digest.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/host/lib/signature_digest.c	2014-04-27 13:03:45.812121081 +0000
@@ -0,0 +1,76 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "signature_digest.h"
+#define OPENSSL_NO_SHA
+#include <openssl/engine.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+
+
+uint8_t* PrependDigestInfo(unsigned int algorithm, uint8_t* digest) {
+  const int digest_size = hash_size_map[algorithm];
+  const int digestinfo_size = digestinfo_size_map[algorithm];
+  const uint8_t* digestinfo = hash_digestinfo_map[algorithm];
+  uint8_t* p = malloc(digestinfo_size + digest_size);
+  Memcpy(p, digestinfo, digestinfo_size);
+  Memcpy(p + digestinfo_size, digest, digest_size);
+  return p;
+}
+
+uint8_t* SignatureDigest(const uint8_t* buf, uint64_t len,
+                         unsigned int algorithm) {
+  uint8_t* info_digest  = NULL;
+  uint8_t* digest = NULL;
+
+  if (algorithm >= kNumAlgorithms) {
+    VBDEBUG(("SignatureDigest() called with invalid algorithm!\n"));
+  } else if ((digest = DigestBuf(buf, len, algorithm))) {
+    info_digest = PrependDigestInfo(algorithm, digest);
+  }
+  free(digest);
+  return info_digest;
+}
+
+uint8_t* SignatureBuf(const uint8_t* buf, uint64_t len, const char* key_file,
+                      unsigned int algorithm) {
+  FILE* key_fp = NULL;
+  RSA* key = NULL;
+  uint8_t* signature = NULL;
+  uint8_t* signature_digest = SignatureDigest(buf, len, algorithm);
+  int signature_digest_len = (hash_size_map[algorithm] +
+                              digestinfo_size_map[algorithm]);
+  key_fp  = fopen(key_file, "r");
+  if (!key_fp) {
+    VBDEBUG(("SignatureBuf(): Couldn't open key file: %s\n", key_file));
+    free(signature_digest);
+    return NULL;
+  }
+  if ((key = PEM_read_RSAPrivateKey(key_fp, NULL, NULL, NULL)))
+    signature = (uint8_t*) malloc(siglen_map[algorithm]);
+  else
+    VBDEBUG(("SignatureBuf(): Couldn't read private key from file: %s\n",
+             key_file));
+  if (signature) {
+    if (-1 == RSA_private_encrypt(signature_digest_len,  /* Input length. */
+                                  signature_digest,  /* Input data. */
+                                  signature,  /* Output signature. */
+                                  key,  /* Key to use. */
+                                  RSA_PKCS1_PADDING))  /* Padding to use. */
+      VBDEBUG(("SignatureBuf(): RSA_private_encrypt() failed.\n"));
+  }
+  fclose(key_fp);
+  if (key)
+    RSA_free(key);
+  free(signature_digest);
+  return signature;
+}
diff -Nur tools-org/vboot_utils/src/Makefile tools/vboot_utils/src/Makefile
--- tools-org/vboot_utils/src/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/Makefile	2014-04-27 13:03:45.724115029 +0000
@@ -0,0 +1,290 @@
+# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# This Makefile normally builds in a 'build' subdir, but use
+#
+#    make BUILD=<dir>
+#
+# to put the output somewhere else.
+
+##############################################################################
+# Make variables come in two flavors, immediate or deferred.
+#
+#   Variable definitions are parsed like this:
+#
+#        IMMEDIATE = DEFERRED
+#    or
+#        IMMEDIATE := IMMEDIATE
+#
+#   Rules are parsed this way:
+#
+#        IMMEDIATE : IMMEDIATE
+#           DEFERRED
+#
+# So you can assign variables in any order if they're only to be used in
+# actions, but if you use a variable in either the target or prerequisite of a
+# rule, the rule will be constructed using only the top-down, immediate value.
+#
+# So we'll try to define all the variables first. Then the rules.
+#
+
+##############################################################################
+# Configuration variables come first.
+#
+# Our convention is that we only use := for variables that will never be
+# changed or appended. They must be defined before being used anywhere.
+
+# We should only run pwd once, not every time we refer to ${BUILD}.
+SRCDIR := $(shell pwd)
+BUILD = $(SRCDIR)/build
+export BUILD
+
+# Stuff for 'make install'
+INSTALL = install
+DESTDIR = /usr/local/bin
+OLDDIR = old_bins
+
+FT_DIR=${DESTDIR}
+F_DIR=${DESTDIR}
+UB_DIR=${DESTDIR}/${OLDDIR}
+
+# Verbose? Use V=1
+ifeq (${V},)
+Q := @
+endif
+
+# Quiet? Use QUIET=1
+ifeq ($(QUIET),)
+PRINTF := printf
+else
+PRINTF := :
+endif
+
+# Flag ordering: arch, then -f, then -m, then -W
+DEBUG_FLAGS := $(if ${DEBUG},-g -O0,-Os)
+COMMON_FLAGS := -nostdinc -pipe \
+	-ffreestanding -fno-builtin -fno-stack-protector \
+	-Werror -Wall -Wstrict-prototypes ${DEBUG_FLAGS}
+
+# Note: FIRMWARE_ARCH is defined by the Chromium OS ebuild.
+# FIRMWARE_ARCH not defined; assuming local compile.
+CC ?= gcc
+CFLAGS += -Wall -Werror # HEY: always want last two?
+
+# Create / use dependency files
+CFLAGS += -MMD -MF $@.d
+
+# These are required to access large disks and files on 32-bit systems.
+CFLAGS += -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
+
+# And a few more default utilities
+LD = ${CC}
+CXX ?= g++ # HEY: really?
+
+##############################################################################
+# Now we need to describe everything we might want or need to build
+
+# Everything wants these headers.
+INCLUDES += \
+	-Ifirmware/include \
+	-Ifirmware/lib/include \
+	-Ifirmware/lib/cgptlib/include \
+	-Ifirmware/lib/cryptolib/include
+
+# Firmware library. TODO: Do we still need to export this?
+FWLIB = ${BUILD}/vboot_fw.a
+
+# Firmware library sources needed by VbInit() call
+VBINIT_SRCS = \
+	firmware/lib/crc8.c \
+	firmware/lib/utility.c \
+	firmware/stub/utility_stub.c
+
+# Additional firmware library sources needed by VbSelectFirmware() call
+VBSF_SRCS = \
+	firmware/lib/cryptolib/padding.c \
+	firmware/lib/cryptolib/rsa.c \
+	firmware/lib/cryptolib/rsa_utility.c \
+	firmware/lib/cryptolib/sha1.c \
+	firmware/lib/cryptolib/sha256.c \
+	firmware/lib/cryptolib/sha512.c \
+	firmware/lib/cryptolib/sha_utility.c \
+	firmware/lib/stateful_util.c \
+	firmware/lib/vboot_common.c \
+	firmware/stub/vboot_api_stub_sf.c
+
+# Additional firmware library sources needed by VbSelectAndLoadKernel() call
+VBSLK_SRCS = \
+	firmware/lib/utility_string.c
+
+VBSF_SRCS += ${VBINIT_SRCS}
+FWLIB_SRCS += ${VBSF_SRCS} ${VBSLK_SRCS}
+
+VBINIT_OBJS = ${VBINIT_SRCS:%.c=${BUILD}/%.o}
+VBSF_OBJS = ${VBSF_SRCS:%.c=${BUILD}/%.o}
+
+FWLIB_OBJS = ${FWLIB_SRCS:%.c=${BUILD}/%.o}
+
+ALL_OBJS += ${FWLIB_OBJS} ${VBINIT_OBJS} ${VBSF_OBJS}
+
+
+# Library to build the utilities. "HOST" mostly means "userspace".
+HOSTLIB = ${BUILD}/libvboot_host.a
+
+HOSTLIB_SRCS = \
+	host/lib/file_keys.c \
+	host/lib/fmap.c \
+	host/lib/host_common.c \
+	host/lib/host_key.c \
+	host/lib/host_keyblock.c \
+	host/lib/host_misc.c \
+	host/lib/host_signature.c \
+	host/lib/signature_digest.c 
+
+HOSTLIB_OBJS = ${HOSTLIB_SRCS:%.c=${BUILD}/%.o}
+ALL_OBJS += ${HOSTLIB_OBJS}
+
+# Scripts to install directly (not compiled)
+UTIL_SCRIPTS = \
+	utility/make_keyblock.sh \
+	utility/make_pair.sh \
+	utility/common.sh
+
+UTIL_NAMES = utility/dumpRSAPublicKey \
+	utility/vbutil_firmware \
+	utility/vbutil_key \
+	utility/vbutil_keyblock 
+
+UTIL_BINS = $(addprefix ${BUILD}/,${UTIL_NAMES})
+ALL_OBJS += $(addsuffix .o,${UTIL_BINS})
+
+
+##############################################################################
+# Finally, some targets. High-level ones first.
+
+# Create output directories if necessary.  Do this via explicit shell commands
+# so it happens before trying to generate/include dependencies.
+SUBDIRS := firmware host utility
+_dir_create := $(foreach d, \
+	$(shell find ${SUBDIRS} -name '*.c' -exec  dirname {} \; | sort -u), \
+	$(shell [ -d ${BUILD}/${d} ] || mkdir -p ${BUILD}/${d}))
+
+
+# Default target.
+.PHONY: all
+all: fwlib host_stuff
+
+# Host targets
+.PHONY: host_stuff
+host_stuff: hostlib utils
+.PHONY: clean
+clean:
+	${Q}/bin/rm -rf ${BUILD}
+
+.PHONY: install
+install: utils_install
+
+# Don't delete intermediate object files
+.SECONDARY:
+
+
+# ----------------------------------------------------------------------------
+# Firmware library
+
+# TPM-specific flags.  These depend on the particular TPM we're targeting for.
+# They are needed here only for compiling parts of the firmware code into
+# user-level tests.
+# Disable rollback TPM when compiling locally, since otherwise
+# load_kernel_test attempts to talk to the TPM.
+${FWLIB_OBJS}: CFLAGS += -DDISABLE_ROLLBACK_TPM
+
+.PHONY: fwlib
+fwlib: ${FWLIB}
+
+${FWLIB}: ${FWLIB_OBJS}
+	@$(PRINTF) "    RM            $(subst ${BUILD}/,,$@)\n"
+	${Q}rm -f $@
+	@$(PRINTF) "    AR            $(subst ${BUILD}/,,$@)\n"
+	${Q}ar qc $@ $^
+
+# ----------------------------------------------------------------------------
+# Host library
+
+.PHONY: hostlib
+hostlib: ${HOSTLIB}
+
+${BUILD}/host/% ${HOSTLIB}: INCLUDES += \
+	-Ihost/include \
+	-Ihost/lib/include
+
+# TODO: better way to make .a than duplicating this recipe each time?
+${HOSTLIB}: ${HOSTLIB_OBJS} ${FWLIB_OBJS}
+	@$(PRINTF) "    RM            $(subst ${BUILD}/,,$@)\n"
+	${Q}rm -f $@
+	@$(PRINTF) "    AR            $(subst ${BUILD}/,,$@)\n"
+	${Q}ar qc $@ $^
+
+# ----------------------------------------------------------------------------
+# Utilities
+
+# These have their own headers too.
+${BUILD}/utility/%: INCLUDES += \
+	-Ihost/include \
+	-Ihost/lib/include \
+	-Iutility/include
+
+# Utilities for auto-update toolkits must be statically linked.
+${UTIL_BINS_STATIC}: LDFLAGS += -static
+
+
+.PHONY: utils
+utils: ${UTIL_BINS} ${UTIL_SCRIPTS}
+	${Q}cp -f ${UTIL_SCRIPTS} ${BUILD}/utility
+	${Q}chmod a+rx $(patsubst %,${BUILD}/%,${UTIL_SCRIPTS})
+
+${UTIL_BINS} ${UTIL_BINS_STATIC}: ${HOSTLIB}
+${UTIL_BINS} ${UTIL_BINS_STATIC}: LIBS = ${HOSTLIB}
+
+.PHONY: utils_install
+utils_install: ${UTIL_BINS} ${UTIL_SCRIPTS}
+	@$(PRINTF) "    INSTALL       UTILS\n"
+	${Q}mkdir -p ${UB_DIR}
+	${Q}${INSTALL} -t ${UB_DIR} ${UTIL_BINS} ${UTIL_SCRIPTS}
+
+# ----------------------------------------------------------------------------
+# Generic build rules. LIBS and OBJS can be overridden to tweak the generic
+# rules for specific targets.
+
+${BUILD}/%: ${BUILD}/%.o ${OBJS} ${LIBS}
+	@$(PRINTF) "    LD            $(subst ${BUILD}/,,$@)\n"
+	${Q}${LD} -o $@ ${CFLAGS} ${LDFLAGS} $< ${OBJS} ${LIBS} ${LDLIBS}
+
+${BUILD}/%.o: %.c
+	@$(PRINTF) "    CC            $(subst ${BUILD}/,,$@)\n"
+	${Q}${CC} ${CFLAGS} ${INCLUDES} -c -o $@ $<
+
+# Rules to recompile a single source file for library and test
+# TODO: is there a tidier way to do this?
+${BUILD}/%_for_lib.o: CFLAGS += -DFOR_LIBRARY
+${BUILD}/%_for_lib.o: %.c
+	@$(PRINTF) "    CC-for-lib    $(subst ${BUILD}/,,$@)\n"
+	${Q}${CC} ${CFLAGS} ${INCLUDES} -c -o $@ $<
+
+# TODO: C++ files don't belong in vboot reference at all.  Convert to C.
+${BUILD}/%.o: %.cc
+	@$(PRINTF) "    CXX           $(subst ${BUILD}/,,$@)\n"
+	${Q}${CXX} ${CFLAGS} ${INCLUDES} -c -o $@ $<
+
+# ----------------------------------------------------------------------------
+# Here are the special tweaks to the generic rules.
+
+# Some utilities need external crypto functions
+${BUILD}/utility/dumpRSAPublicKey: LDLIBS += -lcrypto
+${BUILD}/utility/vbutil_firmware: LDLIBS += -lcrypto
+${BUILD}/utility/vbutil_key: LDLIBS += -lcrypto
+${BUILD}/utility/vbutil_keyblock: LDLIBS += -lcrypto
+
+# Include generated dependencies
+ALL_DEPS += ${ALL_OBJS:%.o=%.o.d}
+-include ${ALL_DEPS}
diff -Nur tools-org/vboot_utils/src/utility/common.sh tools/vboot_utils/src/utility/common.sh
--- tools-org/vboot_utils/src/utility/common.sh	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/common.sh	2014-04-27 13:03:45.812121081 +0000
@@ -0,0 +1,235 @@
+#!/bin/bash
+# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# Common key generation functions.
+
+SCRIPT_DIR="$(dirname "$0")"
+
+# 0 = (RSA1024 SHA1)
+# 1 = (RSA1024 SHA256)
+# 2 = (RSA1024 SHA512)
+# 3 = (RSA2048 SHA1)
+# 4 = (RSA2048 SHA256)
+# 5 = (RSA2048 SHA512)
+# 6 = (RSA4096 SHA1)
+# 7 = (RSA4096 SHA256)
+# 8 = (RSA4096 SHA512)
+# 9 = (RSA8192 SHA1)
+# 10 = (RSA8192 SHA256)
+# 11 = (RSA8192 SHA512)
+function alg_to_keylen {
+  echo $(( 1 << (10 + ($1 / 3)) ))
+}
+
+# Default algorithms.
+EC_ROOT_KEY_ALGOID=7
+EC_DATAKEY_ALGOID=7
+
+ROOT_KEY_ALGOID=11
+RECOVERY_KEY_ALGOID=11
+
+FIRMWARE_DATAKEY_ALGOID=7
+DEV_FIRMWARE_DATAKEY_ALGOID=7
+
+RECOVERY_KERNEL_ALGOID=11
+INSTALLER_KERNEL_ALGOID=11
+KERNEL_SUBKEY_ALGOID=7
+KERNEL_DATAKEY_ALGOID=4
+
+# Keyblock modes determine which boot modes a signing key is valid for use
+# in verification.
+EC_KEYBLOCK_MODE=7  # Only allow RW EC firmware in non-recovery.
+FIRMWARE_KEYBLOCK_MODE=7  # Only allow RW firmware in non-recovery.
+DEV_FIRMWARE_KEYBLOCK_MODE=6  # Only allow in dev mode.
+RECOVERY_KERNEL_KEYBLOCK_MODE=11 # Only in recovery mode.
+KERNEL_KEYBLOCK_MODE=7  # Only allow in non-recovery.
+INSTALLER_KERNEL_KEYBLOCK_MODE=10  # Only allow in Dev + Recovery.
+
+# Emit .vbpubk and .vbprivk using given basename and algorithm
+# NOTE: This function also appears in ../../utility/dev_make_keypair. Making
+# the two implementations the same would require some common.sh, which is more
+# likely to cause problems than just keeping an eye out for any differences. If
+# you feel the need to change this file, check the history of that other file
+# to see what may need updating here too.
+function make_pair {
+  local base=$1
+  local alg=$2
+  local key_version=${3:-1}
+  local len=$(alg_to_keylen $alg)
+
+  echo "creating $base keypair (version = $key_version)..."
+
+  # make the RSA keypair
+  openssl genrsa -F4 -out "${base}_${len}.pem" $len
+  # create a self-signed certificate
+  openssl req -batch -new -x509 -key "${base}_${len}.pem" \
+    -out "${base}_${len}.crt"
+  # generate pre-processed RSA public key
+  dumpRSAPublicKey -cert "${base}_${len}.crt" > "${base}_${len}.keyb"
+
+  # wrap the public key
+  vbutil_key \
+    --pack "${base}.vbpubk" \
+    --key "${base}_${len}.keyb" \
+    --version  "${key_version}" \
+    --algorithm $alg
+
+  # wrap the private key
+  vbutil_key \
+    --pack "${base}.vbprivk" \
+    --key "${base}_${len}.pem" \
+    --algorithm $alg
+
+  # remove intermediate files
+  rm -f "${base}_${len}.pem" "${base}_${len}.crt" "${base}_${len}.keyb"
+}
+
+
+# Emit a .keyblock containing flags and a public key, signed by a private key
+# flags are the bitwise OR of these (passed in decimal, though)
+#   0x01  Developer switch off
+#   0x02  Developer switch on
+#   0x04  Not recovery mode
+#   0x08  Recovery mode
+function make_keyblock {
+  local base=$1
+  local flags=$2
+  local pubkey=$3
+  local signkey=$4
+
+  echo "creating $base keyblock..."
+
+  # create it
+  vbutil_keyblock \
+    --pack "${base}.keyblock" \
+    --flags $flags \
+    --datapubkey "${pubkey}.vbpubk" \
+    --signprivate "${signkey}.vbprivk"
+
+  # verify it
+  vbutil_keyblock \
+    --unpack "${base}.keyblock" \
+    --signpubkey "${signkey}.vbpubk"
+}
+
+# File to read current versions from.
+VERSION_FILE="key.versions"
+
+# ARGS: <VERSION_TYPE>
+get_version() {
+  awk -F= '/^'$1'\>/ { print $NF }' ${2:-${VERSION_FILE}}
+}
+
+# Loads the current versions prints them to stdout and sets the global version
+# variables: CURR_FIRMKEY_VER CURR_FIRM_VER CURR_KERNKEY_VER CURR_KERN_VER
+load_current_versions() {
+  local key_dir=$1
+  local VERSION_FILE="${key_dir}/${VERSION_FILE}"
+  if [[ ! -f ${VERSION_FILE} ]]; then
+    return 1
+  fi
+  CURR_FIRMKEY_VER=$(get_version "firmware_key_version")
+  # Firmware version is the kernel subkey version.
+  CURR_FIRM_VER=$(get_version "firmware_version")
+  # Kernel data key version is the kernel key version.
+  CURR_KERNKEY_VER=$(get_version "kernel_key_version")
+  CURR_KERN_VER=$(get_version "kernel_version")
+
+  cat <<EOF
+Current Firmware key version: ${CURR_FIRMKEY_VER}
+Current Firmware version: ${CURR_FIRM_VER}
+Current Kernel key version: ${CURR_KERNKEY_VER}
+Current Kernel version: ${CURR_KERN_VER}
+EOF
+}
+
+# Make backups of existing kernel subkeys and keyblocks that will be revved.
+# Backup format:
+# for keyblocks: <keyblock_name>.v<datakey version>.v<subkey version>.keyblock
+# Args: SUBKEY_VERSION DATAKEY_VERSION
+backup_existing_kernel_keyblock() {
+  if [[ ! -e kernel.keyblock ]]; then
+    return
+  fi
+  mv --no-clobber kernel.{keyblock,"v$2.v$1.keyblock"}
+}
+
+# Make backups of existing kernel subkeys and keyblocks that will be revved.
+# Backup format:
+# for keys: <key_name>.v<version>.vb{pub|priv}k
+# for keyblocks: <keyblock_name>.v<datakey version>.v<subkey version>.keyblock
+# Args: SUBKEY_VERSION DATAKEY_VERSION
+backup_existing_kernel_subkeys() {
+  local subkey_ver=$1
+  local datakey_ver=$2
+  # --no-clobber to prevent accidentally overwriting existing
+  # backups.
+  mv --no-clobber kernel_subkey.{vbprivk,"v${subkey_ver}.vbprivk"}
+  mv --no-clobber kernel_subkey.{vbpubk,"v${subkey_ver}.vbpubk"}
+  backup_existing_kernel_keyblock ${subkey_ver} ${datakey_ver}
+}
+
+# Make backups of existing kernel data keys and keyblocks that will be revved.
+# Backup format:
+# for keys: <key_name>.v<version>.vb{pub|priv}k
+# for keyblocks: <keyblock_name>.v<datakey version>.v<subkey version>.keyblock
+# Args: SUBKEY_VERSION DATAKEY_VERSION
+backup_existing_kernel_data_keys() {
+  local subkey_ver=$1
+  local datakey_ver=$2
+  # --no-clobber to prevent accidentally overwriting existing
+  # backups.
+  mv --no-clobber kernel_data_key.{vbprivk,"v${datakey_ver}.vbprivk"}
+  mv --no-clobber kernel_data_key.{vbpubk,"v${datakey_ver}.vbpubk"}
+  backup_existing_kernel_keyblock ${subkey_ver} ${datakey_ver}
+}
+
+# Make backups of existing firmware keys and keyblocks that will be revved.
+# Backup format:
+# for keys: <key_name>.v<version>.vb{pub|priv}k
+# for keyblocks: <keyblock_name>.v<datakey version>.v<subkey version>.keyblock
+# Args: SUBKEY_VERSION DATAKEY_VERSION
+backup_existing_firmware_keys() {
+  local subkey_ver=$1
+  local datakey_ver=$2
+  mv --no-clobber firmware_data_key.{vbprivk,"v${subkey_ver}.vbprivk"}
+  mv --no-clobber firmware_data_key.{vbpubk,"v${subkey_ver}.vbpubk"}
+  mv --no-clobber firmware.{keyblock,"v${datakey_ver}.v${subkey_ver}.keyblock"}
+}
+
+
+# Write new key version file with the updated key versions.
+# Args: FIRMWARE_KEY_VERSION FIRMWARE_VERSION KERNEL_KEY_VERSION
+#       KERNEL_VERSION
+write_updated_version_file() {
+  local firmware_key_version=$1
+  local firmware_version=$2
+  local kernel_key_version=$3
+  local kernel_version=$4
+
+  cat > ${VERSION_FILE} <<EOF
+firmware_key_version=${firmware_key_version}
+firmware_version=${firmware_version}
+kernel_key_version=${kernel_key_version}
+kernel_version=${kernel_version}
+EOF
+}
+
+# Returns the incremented version number of the passed in key from the version
+# file.  The options are "firmware_key_version", "firmware_version",
+# "kernel_key_version", or "kernel_version".
+# ARGS: KEY_DIR <key_name>
+increment_version() {
+  local key_dir=$1
+  local VERSION_FILE="${key_dir}/${VERSION_FILE}"
+  local old_version=$(get_version $2)
+  local new_version=$(( ${old_version} + 1 ))
+
+  if [[ ${new_version} -gt 0xffff ]]; then
+    echo "Version overflow!" >&2
+    return 1
+  fi
+  echo ${new_version}
+}
diff -Nur tools-org/vboot_utils/src/utility/dumpRSAPublicKey.c tools/vboot_utils/src/utility/dumpRSAPublicKey.c
--- tools-org/vboot_utils/src/utility/dumpRSAPublicKey.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/dumpRSAPublicKey.c	2014-04-27 13:03:45.816121356 +0000
@@ -0,0 +1,199 @@
+/* Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/* C port of DumpPublicKey.java from the Android Open source project with
+ * support for additional RSA key sizes. (platform/system/core,git/libmincrypt
+ * /tools/DumpPublicKey.java). Uses the OpenSSL X509 and BIGNUM library.
+ */
+
+#include <stdint.h>
+#include <openssl/bn.h>
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/x509.h>
+#include <string.h>
+#include <unistd.h>
+
+/* Command line tool to extract RSA public keys from X.509 certificates
+ * and output a pre-processed version of keys for use by RSA verification
+ * routines.
+ */
+
+int check(RSA* key) {
+  int public_exponent = BN_get_word(key->e);
+  int modulus = BN_num_bits(key->n);
+
+  if (public_exponent != 65537) {
+    fprintf(stderr, "WARNING: Public exponent should be 65537 (but is %d).\n",
+            public_exponent);
+  }
+
+  if (modulus != 1024 && modulus != 2048 && modulus != 4096
+      && modulus != 8192) {
+    fprintf(stderr, "ERROR: Unknown modulus length = %d.\n", modulus);
+    return 0;
+  }
+  return 1;
+}
+
+/* Pre-processes and outputs RSA public key to standard out.
+ */
+void output(RSA* key) {
+  int i, nwords;
+  BIGNUM *N = key->n;
+  BIGNUM *Big1 = NULL, *Big2 = NULL, *Big32 = NULL, *BigMinus1 = NULL;
+  BIGNUM *B = NULL;
+  BIGNUM *N0inv= NULL, *R = NULL, *RR = NULL, *RRTemp = NULL, *NnumBits = NULL;
+  BIGNUM *n = NULL, *rr = NULL;
+  BN_CTX *bn_ctx = BN_CTX_new();
+  uint32_t n0invout;
+
+  N = key->n;
+  /* Output size of RSA key in 32-bit words */
+  nwords = BN_num_bits(N) / 32;
+  if (-1 == write(1, &nwords, sizeof(nwords)))
+    goto failure;
+
+
+  /* Initialize BIGNUMs */
+  Big1 = BN_new();
+  Big2 = BN_new();
+  Big32 = BN_new();
+  BigMinus1 = BN_new();
+  N0inv= BN_new();
+  R = BN_new();
+  RR = BN_new();
+  RRTemp = BN_new();
+  NnumBits = BN_new();
+  n = BN_new();
+  rr = BN_new();
+
+
+  BN_set_word(Big1, 1L);
+  BN_set_word(Big2, 2L);
+  BN_set_word(Big32, 32L);
+  BN_sub(BigMinus1, Big1, Big2);
+
+  B = BN_new();
+  BN_exp(B, Big2, Big32, bn_ctx); /* B = 2^32 */
+
+  /* Calculate and output N0inv = -1 / N[0] mod 2^32 */
+  BN_mod_inverse(N0inv, N, B, bn_ctx);
+  BN_sub(N0inv, B, N0inv);
+  n0invout = BN_get_word(N0inv);
+  if (-1 == write(1, &n0invout, sizeof(n0invout)))
+    goto failure;
+
+  /* Calculate R = 2^(# of key bits) */
+  BN_set_word(NnumBits, BN_num_bits(N));
+  BN_exp(R, Big2, NnumBits, bn_ctx);
+
+  /* Calculate RR = R^2 mod N */
+  BN_copy(RR, R);
+  BN_mul(RRTemp, RR, R, bn_ctx);
+  BN_mod(RR, RRTemp, N, bn_ctx);
+
+
+  /* Write out modulus as little endian array of integers. */
+  for (i = 0; i < nwords; ++i) {
+    uint32_t nout;
+
+    BN_mod(n, N, B, bn_ctx); /* n = N mod B */
+    nout = BN_get_word(n);
+    if (-1 == write(1, &nout, sizeof(nout)))
+      goto failure;
+
+    BN_rshift(N, N, 32); /*  N = N/B */
+  }
+
+  /* Write R^2 as little endian array of integers. */
+  for (i = 0; i < nwords; ++i) {
+    uint32_t rrout;
+
+    BN_mod(rr, RR, B, bn_ctx); /* rr = RR mod B */
+    rrout = BN_get_word(rr);
+    if (-1 == write(1, &rrout, sizeof(rrout)))
+      goto failure;
+
+    BN_rshift(RR, RR, 32); /* RR = RR/B */
+  }
+
+failure:
+  /* Free BIGNUMs. */
+  BN_free(Big1);
+  BN_free(Big2);
+  BN_free(Big32);
+  BN_free(BigMinus1);
+  BN_free(N0inv);
+  BN_free(R);
+  BN_free(RRTemp);
+  BN_free(NnumBits);
+  BN_free(n);
+  BN_free(rr);
+
+}
+
+int main(int argc, char* argv[]) {
+  int cert_mode = 0;
+  FILE* fp;
+  X509* cert = NULL;
+  RSA* pubkey = NULL;
+  EVP_PKEY* key;
+  char *progname;
+
+  if (argc != 3 || (strcmp(argv[1], "-cert") && strcmp(argv[1], "-pub"))) {
+    progname = strrchr(argv[0], '/');
+    if (progname)
+      progname++;
+    else
+      progname = argv[0];
+    fprintf(stderr, "Usage: %s <-cert | -pub> <file>\n", progname);
+    return -1;
+  }
+
+  if (!strcmp(argv[1], "-cert"))
+    cert_mode = 1;
+
+  fp = fopen(argv[2], "r");
+
+  if (!fp) {
+    fprintf(stderr, "Couldn't open file %s!\n", argv[2]);
+    return -1;
+  }
+
+  if (cert_mode) {
+    /* Read the certificate */
+    if (!PEM_read_X509(fp, &cert, NULL, NULL)) {
+      fprintf(stderr, "Couldn't read certificate.\n");
+      goto fail;
+    }
+
+    /* Get the public key from the certificate. */
+    key = X509_get_pubkey(cert);
+
+    /* Convert to a RSA_style key. */
+    if (!(pubkey = EVP_PKEY_get1_RSA(key))) {
+      fprintf(stderr, "Couldn't convert to a RSA style key.\n");
+      goto fail;
+    }
+  } else {
+    /* Read the pubkey in .PEM format. */
+    if (!(pubkey = PEM_read_RSA_PUBKEY(fp, NULL, NULL, NULL))) {
+      fprintf(stderr, "Couldn't read public key file.\n");
+      goto fail;
+    }
+  }
+
+  if (check(pubkey)) {
+    output(pubkey);
+  }
+
+fail:
+  X509_free(cert);
+  RSA_free(pubkey);
+  fclose(fp);
+
+  return 0;
+}
diff -Nur tools-org/vboot_utils/src/utility/make_keyblock.sh tools/vboot_utils/src/utility/make_keyblock.sh
--- tools-org/vboot_utils/src/utility/make_keyblock.sh	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/make_keyblock.sh	2014-04-27 13:03:45.816121356 +0000
@@ -0,0 +1,27 @@
+#!/bin/bash
+# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# Generates a keyblock containing a public key and signed using the given
+# signing key.
+
+# Load common constants and functions.
+. "$(dirname "$0")/common.sh"
+
+if [ $# -ne 4 ]; then
+  cat <<EOF
+Usage: $0 <in_public_key> <in_signing_key> <flags> <out_keyblock>
+
+Emits <out_keyblock>.keyblock containing <in_public_key>.vbpubk signed with
+<in_signing_key>.vbprivk with the given keyblock <flags>.
+EOF
+  exit 1
+fi
+
+in_pubkey=$1
+in_signkey=$2
+keyblock_flags=$3
+out_keyblock=$4
+
+make_keyblock $out_keyblock $keyblock_flags $in_pubkey $in_signkey
diff -Nur tools-org/vboot_utils/src/utility/make_pair.sh tools/vboot_utils/src/utility/make_pair.sh
--- tools-org/vboot_utils/src/utility/make_pair.sh	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/make_pair.sh	2014-04-27 13:03:45.816121356 +0000
@@ -0,0 +1,23 @@
+#!/bin/bash
+# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# Generate .vbpubk and .vbprivk pairs with the given algorithm id.
+
+# Load common constants and functions.
+. "$(dirname "$0")/common.sh"
+
+if [ $# -ne 2 ]; then
+  cat <<EOF
+Usage: $0 <algoid> <out_keypair>
+
+Output: <out_keypair>.vbprivk and <out_keypair>.vbpubk
+EOF
+  exit 1
+fi
+
+algoid=$1
+out_keypair=$2
+
+make_pair $out_keypair $algoid
diff -Nur tools-org/vboot_utils/src/utility/vbutil_firmware.c tools/vboot_utils/src/utility/vbutil_firmware.c
--- tools-org/vboot_utils/src/utility/vbutil_firmware.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/vbutil_firmware.c	2014-04-27 13:03:45.820121631 +0000
@@ -0,0 +1,396 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Verified boot firmware utility
+ */
+
+#include <getopt.h>
+#include <inttypes.h>  /* For PRIu64 */
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "vboot_common.h"
+
+static int opt_vblockonly = 0;
+
+/* Command line options */
+enum {
+  OPT_MODE_VBLOCK = 1000,
+  OPT_MODE_VERIFY,
+  OPT_KEYBLOCK,
+  OPT_SIGNPUBKEY,
+  OPT_SIGNPRIVATE,
+  OPT_VERSION,
+  OPT_FV,
+  OPT_KERNELKEY,
+  OPT_FLAGS,
+  OPT_VBLOCKONLY,  
+};
+
+static struct option long_opts[] = {
+  {"vblock", 1, 0,                    OPT_MODE_VBLOCK             },
+  {"verify", 1, 0,                    OPT_MODE_VERIFY             },
+  {"keyblock", 1, 0,                  OPT_KEYBLOCK                },
+  {"signpubkey", 1, 0,                OPT_SIGNPUBKEY              },
+  {"signprivate", 1, 0,               OPT_SIGNPRIVATE             },
+  {"version", 1, 0,                   OPT_VERSION                 },
+  {"fv", 1, 0,                        OPT_FV                      },
+  {"kernelkey", 1, 0,                 OPT_KERNELKEY               },
+  {"flags", 1, 0,                     OPT_FLAGS                   },
+  {"vblockonly", 0, 0,                OPT_VBLOCKONLY              },
+  {NULL, 0, 0, 0}
+};
+
+
+/* Print help and return error */
+static int PrintHelp(void) {
+
+  puts("vbutil_firmware - Verified boot key block utility\n"
+       "\n"
+       "Usage:  vbutil_firmware <--vblock|--verify> <file> [OPTIONS]\n"
+       "\n"
+       "For '--vblock <file>', required OPTIONS are:\n"
+       "  --keyblock <file>           Key block in .keyblock format\n"
+       "  --signprivate <file>        Signing private key in .vbprivk format\n"
+       "  --version <number>          Firmware version\n"
+       "  --fv <file>                 Firmware volume to sign\n"
+       "  --kernelkey <file>          Kernel subkey in .vbpubk format\n"
+       "optional OPTIONS are:\n"
+       "  --flags <number>            Preamble flags (defaults to 0)\n"
+       "  --vblockonly                Emit just the verification blob\n"
+       "\n"
+       "For '--verify <file>', required OPTIONS are:\n"
+       "  --signpubkey <file>         Signing public key in .vbpubk format\n"
+       "  --fv <file>                 Firmware volume to verify\n"
+       "\n"
+       "For '--verify <file>', optional OPTIONS are:\n"
+       "  --kernelkey <file>          Write the kernel subkey to this file\n"
+       "");
+  return 1;
+}
+
+
+/* Create a firmware .vblock */
+static int Vblock(const char* outfile, const char* keyblock_file,
+                  const char* signprivate, uint64_t version,
+                  const char* fv_file, const char* kernelkey_file,
+                  uint32_t preamble_flags) {
+
+  VbPrivateKey* signing_key;
+  VbPublicKey* kernel_subkey;
+  VbSignature* body_sig;
+  VbFirmwarePreambleHeader* preamble;
+  VbKeyBlockHeader* key_block;
+  uint64_t key_block_size;
+  uint8_t* fv_data;
+  uint64_t fv_size;
+  FILE* f;
+  uint64_t i;
+
+  if (!outfile) {
+    printf("Must specify output filename\n");
+    return 1;
+  }
+  if (!keyblock_file || !signprivate || !kernelkey_file) {
+    printf("Must specify all keys\n");
+    return 1;
+  }
+  if (!fv_file) {
+    printf("Must specify firmware volume\n");
+    return 1;
+  }
+
+  /* Read the key block and keys */
+  key_block = (VbKeyBlockHeader*)ReadFile(keyblock_file, &key_block_size);
+  if (!key_block) {
+    printf("Error reading key block.\n");
+    return 1;
+  }
+
+  signing_key = PrivateKeyRead(signprivate);
+  if (!signing_key) {
+    printf("Error reading signing key.\n");
+    return 1;
+  }
+
+  kernel_subkey = PublicKeyRead(kernelkey_file);
+  if (!kernel_subkey) {
+    printf("Error reading kernel subkey.\n");
+    return 1;
+  }
+
+  /* Read and sign the firmware volume */
+  fv_data = ReadFile(fv_file, &fv_size);
+  if (!fv_data)
+    return 1;
+  if (!fv_size) {
+    printf("Empty firmware volume file\n");
+    return 1;
+  }
+  body_sig = CalculateSignature(fv_data, fv_size, signing_key);
+  if (!body_sig) {
+    printf("Error calculating body signature\n");
+    return 1;
+  }
+  
+  /* Create preamble */
+  preamble = CreateFirmwarePreamble(version,
+                                    kernel_subkey,
+                                    body_sig,
+                                    signing_key,
+                                    preamble_flags);
+  if (!preamble) {
+    printf("Error creating preamble.\n");
+    return 1;
+  }
+
+  /* Write the output file */
+  f = fopen(outfile, "wb");
+  if (!f) {
+    printf("Can't open output file %s\n", outfile);
+    return 1;
+  }
+  i = ((1 != fwrite(key_block, key_block_size, 1, f)) ||
+       (1 != fwrite(preamble, preamble->preamble_size, 1, f)));
+  if (i) {
+    printf("Can't write output file %s\n", outfile);
+    fclose(f);
+    unlink(outfile);
+    return 1;
+  }
+
+  if (!opt_vblockonly) {
+    printf("0x%" PRIx64 " bytes of firmware_blob\n", fv_size);
+    i = (1 != fwrite(fv_data, fv_size, 1, f));
+    if (i) {
+      free(fv_data);
+      fclose(f);
+      unlink(outfile);
+      printf("Can't write output file %s\n", outfile);      
+    }
+  }
+  printf("0x%" PRIx64 " bytes total\n", (fv_size + key_block_size + preamble->preamble_size));
+  free(fv_data);
+  fclose(f);
+
+  /* Success */
+  return 0;
+}
+
+static int Verify(const char* infile, const char* signpubkey,
+                  const char* fv_file, const char* kernelkey_file) {
+
+  VbKeyBlockHeader* key_block;
+  VbFirmwarePreambleHeader* preamble;
+  VbPublicKey* data_key;
+  VbPublicKey* sign_key;
+  VbPublicKey* kernel_subkey;
+  RSAPublicKey* rsa;
+  uint8_t* blob;
+  uint64_t blob_size;
+  uint8_t* fv_data;
+  uint64_t fv_size;
+  uint64_t now = 0;
+  uint32_t flags;
+
+  if (!infile || !signpubkey) {
+    printf("Must specify filename, signpubkey\n");
+    return 1;
+  }
+
+  /* Read public signing key */
+  sign_key = PublicKeyRead(signpubkey);
+  if (!sign_key) {
+    printf("Error reading signpubkey.\n");
+    return 1;
+  }
+
+  /* Read blob */
+  blob = ReadFile(infile, &blob_size);
+  if (!blob) {
+    printf("Error reading input file\n");
+    return 1;
+  }
+
+  /* Verify key block */
+  key_block = (VbKeyBlockHeader*)blob;
+  if (0 != KeyBlockVerify(key_block, blob_size, sign_key, 0)) {
+    printf("Error verifying key block.\n");
+    return 1;
+  }
+  free(sign_key);
+  now += key_block->key_block_size;
+
+  printf("Key block:\n");
+  data_key = &key_block->data_key;
+  printf("  Size:                %" PRIu64 "\n", key_block->key_block_size);
+  printf("  Flags:               %" PRIu64 " (ignored)\n",
+         key_block->key_block_flags);
+  printf("  Data key algorithm:  %" PRIu64 " %s\n", data_key->algorithm,
+         (data_key->algorithm < kNumAlgorithms ?
+          algo_strings[data_key->algorithm] : "(invalid)"));
+  printf("  Data key version:    %" PRIu64 "\n", data_key->key_version);
+  printf("  Data key sha1sum:    ");
+  PrintPubKeySha1Sum(data_key);
+  printf("\n");
+
+  rsa = PublicKeyToRSA(&key_block->data_key);
+  if (!rsa) {
+    printf("Error parsing data key.\n");
+    return 1;
+  }
+
+  /* Verify preamble */
+  preamble = (VbFirmwarePreambleHeader*)(blob + now);
+  if (0 != VerifyFirmwarePreamble(preamble, blob_size - now, rsa)) {
+    printf("Error verifying preamble.\n");
+    return 1;
+  }
+  now += preamble->preamble_size;
+
+  flags = VbGetFirmwarePreambleFlags(preamble);
+  printf("Preamble:\n");
+  printf("  Size:                  %" PRIu64 "\n", preamble->preamble_size);
+  printf("  Header version:        %" PRIu32 ".%" PRIu32"\n",
+         preamble->header_version_major, preamble->header_version_minor);
+  printf("  Firmware version:      %" PRIu64 "\n", preamble->firmware_version);
+  kernel_subkey = &preamble->kernel_subkey;
+  printf("  Kernel key algorithm:  %" PRIu64 " %s\n",
+         kernel_subkey->algorithm,
+         (kernel_subkey->algorithm < kNumAlgorithms ?
+          algo_strings[kernel_subkey->algorithm] : "(invalid)"));
+  printf("  Kernel key version:    %" PRIu64 "\n",
+         kernel_subkey->key_version);
+  printf("  Kernel key sha1sum:    ");
+  PrintPubKeySha1Sum(kernel_subkey);
+  printf("\n");
+  printf("  Firmware body size:    %" PRIu64 "\n",
+         preamble->body_signature.data_size);
+  printf("  Preamble flags:        %" PRIu32 "\n", flags);
+
+  /* TODO: verify body size same as signature size */
+
+  /* Verify body */
+  /* Read firmware volume */
+  if (fv_file) {
+    fv_data = ReadFile(fv_file, &fv_size);
+    if (!fv_data) {
+      printf("Error reading firmware volume\n");
+      return 1;
+    }
+  } else {
+    fv_data = blob + now;
+    fv_size = blob_size - now;
+  }
+
+  if (flags & VB_FIRMWARE_PREAMBLE_USE_RO_NORMAL) {
+    printf("Preamble requests USE_RO_NORMAL; skipping body verification.\n");
+  } else {
+    if (0 != VerifyData(fv_data, fv_size, &preamble->body_signature, rsa)) {
+      printf("Error verifying firmware body.\n");
+      return 1;
+    }
+    printf("Body verification succeeded.\n");
+  }
+
+  if (kernelkey_file) {
+    if (0 != PublicKeyWrite(kernelkey_file, kernel_subkey)) {
+      fprintf(stderr,
+              "vbutil_firmware: unable to write kernel subkey\n");
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+
+int main(int argc, char* argv[]) {
+
+  char* filename = NULL;
+  char* key_block_file = NULL;
+  char* signpubkey = NULL;
+  char* signprivate = NULL;
+  uint64_t version = 0;
+  char* fv_file = NULL;
+  char* kernelkey_file = NULL;
+  uint32_t preamble_flags = 0;
+  int mode = 0;
+  int parse_error = 0;
+  char* e;
+  int i;
+
+  while ((i = getopt_long(argc, argv, "", long_opts, NULL)) != -1) {
+    switch (i) {
+      case '?':
+        /* Unhandled option */
+        printf("Unknown option\n");
+        parse_error = 1;
+        break;
+
+      case OPT_MODE_VBLOCK:
+      case OPT_MODE_VERIFY:
+        mode = i;
+        filename = optarg;
+        break;
+
+      case OPT_KEYBLOCK:
+        key_block_file = optarg;
+        break;
+
+      case OPT_SIGNPUBKEY:
+        signpubkey = optarg;
+        break;
+
+      case OPT_SIGNPRIVATE:
+        signprivate = optarg;
+        break;
+
+      case OPT_FV:
+        fv_file = optarg;
+        break;
+
+      case OPT_KERNELKEY:
+        kernelkey_file = optarg;
+        break;
+
+      case OPT_VERSION:
+        version = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          printf("Invalid --version\n");
+          parse_error = 1;
+        }
+        break;
+
+      case OPT_FLAGS:
+        preamble_flags = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          printf("Invalid --flags\n");
+          parse_error = 1;
+        }
+        break;
+      case OPT_VBLOCKONLY:
+        opt_vblockonly = 1;
+        break;
+    }
+  }
+
+  if (parse_error)
+    return PrintHelp();
+
+  switch(mode) {
+    case OPT_MODE_VBLOCK:
+      return Vblock(filename, key_block_file, signprivate, version, fv_file,
+                    kernelkey_file, preamble_flags);
+    case OPT_MODE_VERIFY:
+      return Verify(filename, signpubkey, fv_file, kernelkey_file);
+    default:
+      printf("Must specify a mode.\n");
+      return PrintHelp();
+  }
+}
diff -Nur tools-org/vboot_utils/src/utility/vbutil_keyblock.c tools/vboot_utils/src/utility/vbutil_keyblock.c
--- tools-org/vboot_utils/src/utility/vbutil_keyblock.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/vbutil_keyblock.c	2014-04-27 13:03:45.820121631 +0000
@@ -0,0 +1,324 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Verified boot key block utility
+ */
+
+#include <getopt.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "vboot_common.h"
+
+
+/* Command line options */
+enum {
+  OPT_MODE_PACK = 1000,
+  OPT_MODE_UNPACK,
+  OPT_DATAPUBKEY,
+  OPT_SIGNPUBKEY,
+  OPT_SIGNPRIVATE,
+  OPT_SIGNPRIVATE_PEM,
+  OPT_PEM_ALGORITHM,
+  OPT_EXTERNAL_SIGNER,
+  OPT_FLAGS,
+};
+
+static struct option long_opts[] = {
+  {"pack", 1, 0,                      OPT_MODE_PACK               },
+  {"unpack", 1, 0,                    OPT_MODE_UNPACK             },
+  {"datapubkey", 1, 0,                OPT_DATAPUBKEY              },
+  {"signpubkey", 1, 0,                OPT_SIGNPUBKEY              },
+  {"signprivate", 1, 0,               OPT_SIGNPRIVATE             },
+  {"signprivate_pem", 1, 0,           OPT_SIGNPRIVATE_PEM         },
+  {"pem_algorithm", 1, 0,             OPT_PEM_ALGORITHM           },
+  {"externalsigner", 1, 0,            OPT_EXTERNAL_SIGNER         },
+  {"flags", 1, 0,                     OPT_FLAGS                   },
+  {NULL, 0, 0, 0}
+};
+
+
+/* Print help and return error */
+static int PrintHelp(char *progname) {
+  fprintf(stderr,
+          "Verified boot key block utility\n"
+          "\n"
+          "Usage:  %s <--pack|--unpack> <file> [OPTIONS]\n"
+          "\n"
+          "For '--pack <file>', required OPTIONS are:\n"
+          "  --datapubkey <file>         Data public key in .vbpubk format\n"
+          "\n"
+          "Optional OPTIONS are:\n"
+          "  --signprivate <file>"
+          "        Signing private key in .vbprivk format.\n"
+          "OR\n"
+          "  --signprivate_pem <file>\n"
+          "  --pem_algorithm <algo>\n"
+          "        Signing private key in .pem format and algorithm id.\n"
+          "(If one of the above arguments is not specified, the keyblock will\n"
+          "not be signed.)\n"
+          "\n"
+          "  --flags <number>            Specifies allowed use conditions.\n"
+          "  --externalsigner \"cmd\""
+          "        Use an external program cmd to calculate the signatures.\n"
+          "\n"
+          "For '--unpack <file>', optional OPTIONS are:\n"
+          "  --signpubkey <file>"
+          "        Signing public key in .vbpubk format. This is required to\n"
+          "                                verify a signed keyblock.\n"
+          "  --datapubkey <file>"
+          "        Write the data public key to this file.\n",
+          progname);
+  return 1;
+}
+
+/* Pack a .keyblock */
+static int Pack(const char* outfile, const char* datapubkey,
+                const char* signprivate,
+                const char* signprivate_pem, uint64_t pem_algorithm,
+                uint64_t flags,
+                const char* external_signer) {
+  VbPublicKey* data_key;
+  VbPrivateKey* signing_key = NULL;
+  VbKeyBlockHeader* block;
+
+  if (!outfile) {
+    fprintf(stderr, "vbutil_keyblock: Must specify output filename.\n");
+    return 1;
+  }
+  if (!datapubkey) {
+    fprintf(stderr, "vbutil_keyblock: Must specify data public key.\n");
+    return 1;
+  }
+
+  data_key = PublicKeyRead(datapubkey);
+  if (!data_key) {
+    fprintf(stderr, "vbutil_keyblock: Error reading data key.\n");
+    return 1;
+  }
+
+  if (signprivate_pem) {
+    if (pem_algorithm >= kNumAlgorithms) {
+      fprintf(stderr, "vbutil_keyblock: Invalid --pem_algorithm %" PRIu64 "\n",
+              pem_algorithm);
+      return 1;
+    }
+    if (external_signer) {
+      /* External signing uses the PEM file directly. */
+      block = KeyBlockCreate_external(data_key,
+                                      signprivate_pem, pem_algorithm,
+                                      flags,
+                                      external_signer);
+    } else {
+      signing_key = PrivateKeyReadPem(signprivate_pem, pem_algorithm);
+      if (!signing_key) {
+        fprintf(stderr, "vbutil_keyblock: Error reading signing key.\n");
+        return 1;
+      }
+      block = KeyBlockCreate(data_key, signing_key, flags);
+    }
+  } else {
+    if (signprivate) {
+      signing_key = PrivateKeyRead(signprivate);
+      if (!signing_key) {
+        fprintf(stderr, "vbutil_keyblock: Error reading signing key.\n");
+        return 1;
+      }
+    }
+    block = KeyBlockCreate(data_key, signing_key, flags);
+  }
+
+  free(data_key);
+  if (signing_key)
+    free(signing_key);
+
+  if (0 != KeyBlockWrite(outfile, block)) {
+    fprintf(stderr, "vbutil_keyblock: Error writing key block.\n");
+    return 1;
+  }
+  free(block);
+  return 0;
+}
+
+static int Unpack(const char* infile, const char* datapubkey,
+                  const char* signpubkey) {
+  VbPublicKey* data_key;
+  VbPublicKey* sign_key = NULL;
+  VbKeyBlockHeader* block;
+
+  if (!infile) {
+    fprintf(stderr, "vbutil_keyblock: Must specify filename\n");
+    return 1;
+  }
+
+  block = KeyBlockRead(infile);
+  if (!block) {
+    fprintf(stderr, "vbutil_keyblock: Error reading key block.\n");
+    return 1;
+  }
+
+  /* If the block is signed, then verify it with the signing public key, since
+     KeyBlockRead() only verified the hash. */
+  if (block->key_block_signature.sig_size && signpubkey) {
+    sign_key = PublicKeyRead(signpubkey);
+    if (!sign_key) {
+      fprintf(stderr, "vbutil_keyblock: Error reading signpubkey.\n");
+      return 1;
+    }
+    if (0 != KeyBlockVerify(block, block->key_block_size, sign_key, 0)) {
+      fprintf(stderr, "vbutil_keyblock: Error verifying key block.\n");
+      return 1;
+    }
+    free(sign_key);
+  }
+
+  printf("Key block file:       %s\n", infile);
+  printf("Signature             %s\n", sign_key ? "valid" : "ignored");
+  printf("Flags:                %" PRIu64 " ", block->key_block_flags);
+  if (block->key_block_flags & KEY_BLOCK_FLAG_DEVELOPER_0)
+    printf(" !DEV");
+  if (block->key_block_flags & KEY_BLOCK_FLAG_DEVELOPER_1)
+    printf(" DEV");
+  if (block->key_block_flags & KEY_BLOCK_FLAG_RECOVERY_0)
+    printf(" !REC");
+  if (block->key_block_flags & KEY_BLOCK_FLAG_RECOVERY_1)
+    printf(" REC");
+  printf("\n");
+
+  data_key = &block->data_key;
+  printf("Data key algorithm:   %" PRIu64 " %s\n", data_key->algorithm,
+         (data_key->algorithm < kNumAlgorithms ?
+          algo_strings[data_key->algorithm] : "(invalid)"));
+  printf("Data key version:     %" PRIu64 "\n", data_key->key_version);
+  printf("Data key sha1sum:     ");
+  PrintPubKeySha1Sum(data_key);
+  printf("\n");
+
+  if (datapubkey) {
+    if (0 != PublicKeyWrite(datapubkey, data_key)) {
+      fprintf(stderr,
+              "vbutil_keyblock: unable to write public key\n");
+      return 1;
+    }
+  }
+
+  free(block);
+  return 0;
+}
+
+
+int main(int argc, char* argv[]) {
+
+  char* filename = NULL;
+  char* datapubkey = NULL;
+  char* signpubkey = NULL;
+  char* signprivate = NULL;
+  char* signprivate_pem = NULL;
+  char* external_signer = NULL;
+  uint64_t flags = 0;
+  uint64_t pem_algorithm = 0;
+  int is_pem_algorithm = 0;
+  int mode = 0;
+  int parse_error = 0;
+  char* e;
+  int i;
+
+  char *progname = strrchr(argv[0], '/');
+  if (progname)
+    progname++;
+  else
+    progname = argv[0];
+
+  while ((i = getopt_long(argc, argv, "", long_opts, NULL)) != -1) {
+    switch (i) {
+      case '?':
+        /* Unhandled option */
+        printf("Unknown option\n");
+        parse_error = 1;
+        break;
+
+      case OPT_MODE_PACK:
+      case OPT_MODE_UNPACK:
+        mode = i;
+        filename = optarg;
+        break;
+
+      case OPT_DATAPUBKEY:
+        datapubkey = optarg;
+        break;
+
+      case OPT_SIGNPUBKEY:
+        signpubkey = optarg;
+        break;
+
+      case OPT_SIGNPRIVATE:
+        signprivate = optarg;
+        break;
+
+      case OPT_SIGNPRIVATE_PEM:
+        signprivate_pem = optarg;
+        break;
+
+      case OPT_PEM_ALGORITHM:
+        pem_algorithm = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          fprintf(stderr, "Invalid --pem_algorithm\n");
+          parse_error = 1;
+        } else {
+          is_pem_algorithm = 1;
+        }
+        break;
+
+      case OPT_EXTERNAL_SIGNER:
+        external_signer = optarg;
+        break;
+
+      case OPT_FLAGS:
+        flags = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          fprintf(stderr, "Invalid --flags\n");
+          parse_error = 1;
+        }
+        break;
+    }
+  }
+
+  /* Check if the right combination of options was provided. */
+  if (signprivate && signprivate_pem) {
+    fprintf(stderr, "Only one of --signprivate or --signprivate_pem must"
+            " be specified\n");
+    parse_error = 1;
+  }
+
+  if (signprivate_pem && !is_pem_algorithm) {
+    fprintf(stderr, "--pem_algorithm must be used with --signprivate_pem\n");
+    parse_error = 1;
+  }
+
+  if (external_signer && !signprivate_pem) {
+    fprintf(stderr, "--externalsigner must be used with --signprivate_pem"
+            "\n");
+    parse_error = 1;
+  }
+
+  if (parse_error)
+    return PrintHelp(progname);
+
+  switch(mode) {
+    case OPT_MODE_PACK:
+      return Pack(filename, datapubkey, signprivate,
+                  signprivate_pem, pem_algorithm,
+                  flags,
+                  external_signer);
+    case OPT_MODE_UNPACK:
+      return Unpack(filename, datapubkey, signpubkey);
+    default:
+      printf("Must specify a mode.\n");
+      return PrintHelp(progname);
+  }
+}
diff -Nur tools-org/vboot_utils/src/utility/vbutil_key.c tools/vboot_utils/src/utility/vbutil_key.c
--- tools-org/vboot_utils/src/utility/vbutil_key.c	1970-01-01 00:00:00.000000000 +0000
+++ tools/vboot_utils/src/utility/vbutil_key.c	2014-04-27 13:03:45.820121631 +0000
@@ -0,0 +1,235 @@
+/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ *
+ * Verified boot key utility
+ */
+
+#include <getopt.h>
+#include <inttypes.h>  /* For PRIu64 */
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "cryptolib.h"
+#include "host_common.h"
+#include "vboot_common.h"
+
+
+/* Command line options */
+enum {
+  OPT_INKEY = 1000,
+  OPT_KEY_VERSION,
+  OPT_ALGORITHM,
+  OPT_MODE_PACK,
+  OPT_MODE_UNPACK,
+  OPT_COPYTO,
+};
+
+static struct option long_opts[] = {
+  {"key", 1, 0,                       OPT_INKEY                   },
+  {"version", 1, 0,                   OPT_KEY_VERSION             },
+  {"algorithm", 1, 0,                 OPT_ALGORITHM               },
+  {"pack", 1, 0,                      OPT_MODE_PACK               },
+  {"unpack", 1, 0,                    OPT_MODE_UNPACK             },
+  {"copyto", 1, 0,                    OPT_COPYTO                  },
+  {NULL, 0, 0, 0}
+};
+
+
+/* Print help and return error */
+static int PrintHelp(char *progname) {
+  int i;
+
+  fprintf(stderr,
+          "This program wraps RSA keys with verified boot headers\n");
+  fprintf(stderr,
+          "\n"
+          "Usage:  %s --pack <outfile> [PARAMETERS]\n"
+          "\n"
+          "  Required parameters:\n"
+          "    --key <infile>              RSA key file (.keyb or .pem)\n"
+          "    --version <number>          Key version number "
+          "(required for .keyb, ignored for .pem)\n"
+          "    --algorithm <number>        Signing algorithm to use with key:\n",
+          progname);
+
+  for (i = 0; i < kNumAlgorithms; i++) {
+    fprintf(stderr,
+            "                                  %d = (%s)\n",
+            i, algo_strings[i]);
+  }
+
+  fprintf(stderr,
+          "\nOR\n\n"
+          "Usage:  %s --unpack <infile>\n"
+          "\n"
+          "  Optional parameters:\n"
+          "    --copyto <file>             "
+          "Write a copy of the key to this file.\n"
+          "\n",
+          progname);
+
+  return 1;
+}
+
+/* Pack a .keyb file into a .vbpubk, or a .pem into a .vbprivk */
+static int Pack(const char *infile, const char *outfile, uint64_t algorithm,
+                uint64_t version) {
+  VbPublicKey* pubkey;
+  VbPrivateKey* privkey;
+
+  if (!infile || !outfile) {
+    fprintf(stderr, "vbutil_key: Must specify --in and --out\n");
+    return 1;
+  }
+
+  if ((pubkey = PublicKeyReadKeyb(infile, algorithm, version))) {
+    if (0 != PublicKeyWrite(outfile, pubkey)) {
+      fprintf(stderr, "vbutil_key: Error writing key.\n");
+      return 1;
+    }
+    free(pubkey);
+    return 0;
+  }
+
+  if ((privkey = PrivateKeyReadPem(infile, algorithm))) {
+    if (0 != PrivateKeyWrite(outfile, privkey)) {
+      fprintf(stderr, "vbutil_key: Error writing key.\n");
+      return 1;
+    }
+    free(privkey);
+    return 0;
+  }
+
+  printf("Unable to parse either .keyb or .pem from %s\n", infile);
+  return 1;
+}
+
+
+/* Unpack a .vbpubk or .vbprivk */
+static int Unpack(const char *infile, const char *outfile) {
+  VbPublicKey* pubkey;
+  VbPrivateKey* privkey;
+
+  if (!infile) {
+    fprintf(stderr, "Need file to unpack\n");
+    return 1;
+  }
+
+  if ((pubkey = PublicKeyRead(infile))) {
+    printf("Public Key file:   %s\n", infile);
+    printf("Algorithm:         %" PRIu64 " %s\n", pubkey->algorithm,
+           (pubkey->algorithm < kNumAlgorithms ?
+            algo_strings[pubkey->algorithm] : "(invalid)"));
+    printf("Key Version:       %" PRIu64 "\n", pubkey->key_version);
+    printf("Key sha1sum:       ");
+    PrintPubKeySha1Sum(pubkey);
+    printf("\n");
+    if (outfile) {
+      if (0 != PublicKeyWrite(outfile, pubkey)) {
+        fprintf(stderr, "vbutil_key: Error writing key copy.\n");
+        free(pubkey);
+        return 1;
+      }
+    }
+    free(pubkey);
+    return 0;
+  }
+
+  if ((privkey = PrivateKeyRead(infile))) {
+    printf("Private Key file:  %s\n", infile);
+    printf("Algorithm:         %" PRIu64 " %s\n", privkey->algorithm,
+           (privkey->algorithm < kNumAlgorithms ?
+            algo_strings[privkey->algorithm] : "(invalid)"));
+    if (outfile) {
+      if (0 != PrivateKeyWrite(outfile, privkey)) {
+        fprintf(stderr, "vbutil_key: Error writing key copy.\n");
+        free(privkey);
+        return 1;
+      }
+    }
+    free(privkey);
+    return 0;
+  }
+
+  printf("Unable to parse either .vbpubk or vbprivk from %s\n", infile);
+  return 1;
+}
+
+
+int main(int argc, char* argv[]) {
+
+  char *infile = NULL;
+  char *outfile = NULL;
+  int mode = 0;
+  int parse_error = 0;
+  uint64_t version = 1;
+  uint64_t algorithm = kNumAlgorithms;
+  char* e;
+  int i;
+
+  char *progname = strrchr(argv[0], '/');
+  if (progname)
+    progname++;
+  else
+    progname = argv[0];
+
+  while ((i = getopt_long(argc, argv, "", long_opts, NULL)) != -1) {
+    switch (i) {
+      case '?':
+        /* Unhandled option */
+        printf("Unknown option\n");
+        parse_error = 1;
+        break;
+
+      case OPT_INKEY:
+        infile = optarg;
+        break;
+
+      case OPT_KEY_VERSION:
+        version = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          printf("Invalid --version\n");
+          parse_error = 1;
+        }
+        break;
+
+      case OPT_ALGORITHM:
+        algorithm = strtoul(optarg, &e, 0);
+        if (!*optarg || (e && *e)) {
+          printf("Invalid --algorithm\n");
+          parse_error = 1;
+        }
+        break;
+
+      case OPT_MODE_PACK:
+        mode = i;
+        outfile = optarg;
+        break;
+
+      case OPT_MODE_UNPACK:
+        mode = i;
+        infile = optarg;
+        break;
+
+      case OPT_COPYTO:
+        outfile = optarg;
+        break;
+    }
+  }
+
+  if (parse_error)
+    return PrintHelp(progname);
+
+  switch(mode) {
+    case OPT_MODE_PACK:
+      return Pack(infile, outfile, algorithm, version);
+    case OPT_MODE_UNPACK:
+      return Unpack(infile, outfile);
+    default:
+      printf("Must specify a mode.\n");
+      return PrintHelp(progname);
+  }
+}
